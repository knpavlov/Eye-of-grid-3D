<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="client-repo" content="knpavlov/Eye-of-grid-3D@main"> 
  <title>Eye of Grid — Complete 3D</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="styles/main.css">
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
  <script type="module" src="./src/main.js"></script>
  </head>
<body>
  <canvas id="three-canvas"></canvas>
  
  <!-- MODULE: UI layout (static) - consider extracting to templates/components -->
  <div id="ui">
    <!-- Боковые панели: слева — игрок A, справа — игрок B -->
    <div id="left-side" class="ui-panel fixed left-4 top-1/2 -translate-y-1/2 space-y-3 z-20 flex flex-col items-center">
      <div id="player-title-0" class="text-2xl md:text-3xl font-semibold text-center w-full">Игрок 1</div>
      <div class="overlay-panel px-4 py-2">
        <div class="text-sm mb-1">Mana</div>
        <div class="mana-bar" id="mana-display-0"></div>
      </div>
      <div class="overlay-panel px-4 py-2 text-sm" id="control-info-0">Controlled cells: 0</div>
    </div>

    <div id="right-side" class="ui-panel fixed right-4 top-1/2 -translate-y-1/2 space-y-3 z-20 flex flex-col items-center">
      <div id="player-title-1" class="text-2xl md:text-3xl font-semibold text-center w-full">Игрок 2</div>
      <div class="overlay-panel px-4 py-2">
        <div class="text-sm mb-1">Mana</div>
        <div class="mana-bar" id="mana-display-1"></div>
      </div>
      <div class="overlay-panel px-4 py-2 text-sm" id="control-info-1">Controlled cells: 0</div>
    </div>

    <!-- Верхний центр: номер хода и круглая кнопка с таймером -->
    <div id="top-center" class="ui-panel fixed top-3 left-1/2 -translate-x-1/2 z-20 flex flex-col items-center">
      <div class="overlay-panel px-4 py-3 flex flex-col items-center gap-2">
        <div id="turn-info" class="text-sm tracking-wide">Turn: 1</div>
        <button id="end-turn-btn" class="end-turn-btn" aria-label="End Turn">
          <span class="time-fill"></span>
          <span class="label-text">End Turn</span>
          <span class="sec-text">100</span>
        </button>
      </div>
      <div id="opponent-hand-count" title="Opponent has 0 cards"></div>
    </div>

    <!-- Правый нижний угол: сервисные кнопки -->
    <div id="corner-right" class="ui-panel fixed right-4 bottom-4 z-20">
      <div class="flex gap-2 opacity-90">
        <button id="log-btn" class="overlay-panel px-3 py-1.5 text-xs bg-slate-600 hover:bg-slate-700 transition-colors">Log</button>
        <button id="help-btn" class="overlay-panel px-3 py-1.5 text-xs bg-slate-600 hover:bg-slate-700 transition-colors">Help</button>
        <button id="new-game-btn" class="overlay-panel px-3 py-1.5 text-xs bg-slate-600 hover:bg-slate-700 transition-colors">Play offline</button>
      </div>
    </div>
    
    <!-- Панель логов -->
    <div id="log-panel" class="ui-panel fixed right-4 bottom-20 w-96 h-80 overlay-panel p-4 hidden z-30">
      <div class="flex justify-between items-center mb-3">
        <h3 class="text-lg font-semibold">Log</h3>
        <button id="close-log-btn" class="text-xl">&times;</button>
      </div>
      <div id="log-content" class="h-full overflow-y-auto text-sm space-y-1"></div>
    </div>
    
    <!-- Панель помощи -->
    <div id="help-panel" class="ui-panel fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden z-40">
      <div class="overlay-panel p-6 max-w-lg">
        <div class="flex justify-between items-center mb-4">
          <h3 class="text-xl font-semibold">How to play</h3>
          <button id="close-help-btn" class="text-xl">&times;</button>
        </div>
        <div class="space-y-3 text-sm">
          <p>• Перетаскивайте карты существ на игровое поле</p>
          <p>• Выбирайте направление после размещения</p>
          <p>• Кликайте по своим существам для атаки или поворота</p>
          <p>• Используйте заклинания, перетаскивая их на цель или на поле</p>
          <p>• Победа: контролируйте 5+ клеток в конце хода</p>
        </div>
      </div>
    </div>
    
    <!-- Панель выбора направления -->
    <div id="orientation-panel" class="ui-panel fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden z-40">
      <div class="overlay-panel p-6">
        <div class="text-center mb-4">Chose direction</div>
        <div class="grid grid-cols-3 gap-2 w-48 mx-auto">
          <div></div>
          <button data-dir="N" class="overlay-panel px-4 py-2 hover:bg-slate-700">↑</button>
          <div></div>
          <button data-dir="W" class="overlay-panel px-4 py-2 hover:bg-slate-700">←</button>
          <div class="overlay-panel px-4 py-2 text-center">•</div>
          <button data-dir="E" class="overlay-panel px-4 py-2 hover:bg-slate-700">→</button>
          <div></div>
          <button data-dir="S" class="overlay-panel px-4 py-2 hover:bg-slate-700">↓</button>
          <div></div>
        </div>
        <div class="text-center mt-4">
          <button id="cancel-orient-btn" class="overlay-panel px-4 py-2 bg-red-600 hover:bg-red-700">Отмена</button>
        </div>
      </div>
    </div>
    
    <!-- Панель действий с существом -->
    <div id="unit-action-panel" class="ui-panel fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden z-40">
      <div class="overlay-panel p-6 space-y-3">
        <div id="unit-info" class="text-center mb-4"></div>
        <button id="attack-btn" class="w-full overlay-panel px-4 py-2 bg-red-600 hover:bg-red-700">Attack</button>
        <div class="grid grid-cols-2 gap-2">
          <button id="rotate-cw-btn" class="overlay-panel px-4 py-2 hover:bg-slate-700">Rotate ↻</button>
          <button id="rotate-ccw-btn" class="overlay-panel px-4 py-2 hover:bg-slate-700">Rotate ↺</button>
        </div>
        <button id="cancel-action-btn" class="w-full overlay-panel px-4 py-2 bg-gray-600 hover:bg-gray-700">Cancel</button>
      </div>
    </div>

    <!-- Постоянная панель подсказок/промптов -->
    <div id="prompt-panel" class="ui-panel fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden z-40">
      <div class="overlay-panel p-6 space-y-4">
        <div id="prompt-text" class="text-center"></div>
        <div class="text-center">
          <button id="cancel-prompt-btn" class="overlay-panel px-4 py-2 bg-gray-600 hover:bg-gray-700">Cancel</button>
        </div>
      </div>
    </div>
    
    <!-- Уведомленчиния -->
    <div id="notifications" class="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-50 pointer-events-none"></div>

    <!-- Баннеры: Turn и Battle -->
    <div id="turn-banner" class="banner fixed inset-0 hidden items-center justify-center z-40"></div>
    <div id="battle-banner" class="banner fixed inset-0 hidden items-center justify-center z-40">
      <div class="battlePop text-5xl font-extrabold bg-gradient-to-br from-red-600/80 to-yellow-500/80 px-10 py-5 rounded-3xl shadow-2xl ring-4 ring-yellow-400/40">BATTLE</div>
    </div>
    <!-- Tooltip -->
    <div id="hover-tooltip" class="hidden overlay-panel px-2 py-1 text-xs"></div>
  </div>

  <!-- Версия билда (сверху слева) -->
  <div id="build-version" class="fixed left-0 top-0 z-20 text-xs text-slate-300 opacity-80 p-1.5"></div>

  <script>
      /* MODULE: runtime globals
         Purpose: multiplayer state shared across modules
         Extracted to src/core/netState.js */
      // ====== ИГРОВАЯ ЛОГИКА (полная версия из 2D) ======
    
    let DIR_VECTORS, OPPOSITE_ELEMENT, elementEmoji, turnCW, turnCCW;
    // Переопределяем ориентации: N должен смотреть к верхнему краю (−Z), S — к нижнему (+Z)
    // В three.js «вперёд» меша по умолчанию это +Z (0°), поэтому:
    // S: 0°, E: -90°, W: 90°, N: 180°
    // Исправление: N (стрелка вверх) = 0°, S (стрелка вниз) = 180°; E/W оставляем как есть
    let facingDeg;
    
    let uid, inBounds, capMana, attackCost;
    
    // Карты
    let CARDS;
    
    // Стартер: только Fire Set + несколько спеллов
    let STARTER_FIRESET;
    
    // Функции игровой логики (полные реализации находятся в core/*)
    let dirsForPattern, computeCellBuff, effectiveStats;

    let shuffle;

    let drawOne;

    // Специальная версия: вынуть верхнюю карту, но НЕ класть в руку (для эффектной анимации)
    let drawOneNoAdd;

    let countControlled;

    let startGame;
      // ====== БОЕВАЯ СИСТЕМА (порт из 2D) ======
      let hasAdjacentGuard;
      let computeHits;

    let stagedAttack;
    let magicAttack;
    
      /* MODULE: 3D scene setup and rendering
         Target module: src/scene/*.js (board, cards, units). Inline code below
         duplicates logic already present in modules; keep until migration
         complete. */
      // ====== THREE.JS СЦЕНА ======

      let scene, camera, renderer, raycaster, mouse;
      let boardGroup, cardGroup, effectsGroup, metaGroup;
      let tileMeshes = [];    // 2D массив мешей клеток игрового поля
      let tileFrames = [];    // рамки подсветки/выделения клеток
    let unitMeshes = [];      // текущие меши юнитов на поле
    let handCardMeshes = [];  // меши карт в руке игрока
      let gameState = null;
      // Tile textures are now managed by scene/board module
    // Настройки показа большой карты при доборе — можно править из консоли
    window.DRAW_CARD_TUNE = {
      posY: 8.5,   // высота
      posZ: 2.4,    // дистанция к камере (чем меньше, тем ближе)
      scale: 1.7,   // масштаб
      // Ручная довращалка (в градусах):
      pitchDeg: 45,  // наклон вперёд/назад (ось X)
      yawDeg: 0,    // поворот влево/вправо (ось Y)
      rollDeg: 0    // крен (ось Z)
    };
    // Очереди догоняющих анимаций боя для наблюдателя
    let PENDING_BATTLE_ANIMS = [];
    let PENDING_RETALIATIONS = [];
    // Recently shown remote damage (to avoid duplicate delta popups)
    let RECENT_REMOTE_DAMAGE = new Map();
    try { window.RECENT_REMOTE_DAMAGE = RECENT_REMOTE_DAMAGE; } catch {}
    // Pending HP popups scheduled by playDeltaAnimations, so we can cancel if battleAnim shows earlier
    // HP popup scheduling moved to src/scene/effects.js
    let PENDING_HIDE_HAND_CARDS = [];
    // Управление анимациями заставки хода и добора карты
    let pendingRitualSpellHandIndex = null;
    let pendingRitualSpellCard = null; // ссылка на сам объект карты-спелла, чтобы скрывать по идентичности
    // Сколько последних добранных карт временно скрывать из моей руки (для красивой анимации влёта)
    let pendingDrawCount = 0;
    // Отступ руки по оси Z (положительное — дальше от камеры)
    const HAND_Z_OFFSET = 1.0;
    // Смещение колод/кладбищ от камеры вдоль оси Z (положительное значение — дальше от камеры)
    const META_Z_AWAY = 1.5;
    // 3D объекты справа (колоды/кладбища)
    let deckMeshes = [];
    let graveyardMeshes = [];

    // === THREE.JS SCENE INITIALIZATION ===
    function initThreeJS() {
      if (window.__scene && typeof window.__scene.initThreeJS === 'function') {
        const ctx = window.__scene.initThreeJS({ canvasId: 'three-canvas', clearColor: 0x0b1220 });
        renderer = ctx.renderer;
        scene = ctx.scene;
        camera = ctx.camera;
        raycaster = ctx.raycaster;
        mouse = ctx.mouse;
        boardGroup = ctx.boardGroup;
        cardGroup = ctx.cardGroup;
        effectsGroup = ctx.effectsGroup;
        metaGroup = ctx.metaGroup;
        try { window.renderer = renderer; window.scene = scene; window.camera = camera; window.boardGroup = boardGroup; } catch {}
      } else {
        throw new Error('Scene module not available');
      }
    }
    // preloadCardImages removed (module handles lazy loading)

    // Request deferred redraw of units and hand after state mutations.
    function requestCardsRedraw() {
      clearTimeout(window.__cardsRedrawT);
      window.__cardsRedrawT = setTimeout(() => { updateUnits(); updateHand(); }, 10);
    }

    // Возврат материала тайла по его элементу; делегируется модулю доски
    function getTileMaterial(element) {
      if (window.__board && window.__board.getTileMaterial) {
        return window.__board.getTileMaterial(element);
      }
      return null;
    }

    function updateTileMaterialsFor(elementKey) {
      if (window.__board && window.__board.updateTileMaterialsFor) {
        window.__board.updateTileMaterialsFor(elementKey);
      }
    }

    // Build or rebuild the 3D board tiles.
    function createBoard() {
      try { window.__cards.preloadCardTextures(); } catch {}
      if (window.__board && window.__scene) {
        window.__board.createBoard(gameState);
        const ctx = window.__scene.getCtx();
        tileMeshes = ctx.tileMeshes || [];
        tileFrames = ctx.tileFrames || [];
        try { window.tileMeshes = tileMeshes; window.tileFrames = tileFrames; } catch {}
      }
    }
    
    // Delegator: module cards implementation
    function createCard3D(cardData, isInHand = false, hpOverride = null, atkOverride = null) {
      if (window.__cards && typeof window.__cards.createCard3D === 'function') {
        return window.__cards.createCard3D(cardData, isInHand, hpOverride, atkOverride);
      }
      throw new Error('[bridge] __cards.createCard3D not available; modules must be loaded.');
    }
    // Delegator: module cards implementation
    function drawCardFace(ctx, cardData, width, height, hpOverride = null, atkOverride = null) {
      if (window.__cards && typeof window.__cards.drawCardFace === 'function') {
        return window.__cards.drawCardFace(ctx, cardData, width, height, hpOverride, atkOverride);
      }
      throw new Error('[bridge] __cards.drawCardFace not available; modules must be loaded.');
    }
    

    
    // ====== HAND RENDERING AND LAYOUT ======
    function updateHand() {
      if (window.__hand && typeof window.__hand.updateHand === 'function') {
        window.__hand.updateHand(gameState);
        const ctx = window.__scene && typeof window.__scene.getCtx === 'function'
          ? window.__scene.getCtx() : null;
        if (ctx && ctx.handCardMeshes) {
          handCardMeshes = ctx.handCardMeshes;
        }
      }
      hoveredHandCard = null;
    }

    function setHandCardHoverVisual(mesh, hovered) {
      if (window.__hand && typeof window.__hand.setHandCardHoverVisual === 'function') {
        window.__hand.setHandCardHoverVisual(mesh, hovered);
      }
    }

    async function animateDrawnCardToHand(cardTpl) {
      if (window.__hand && typeof window.__hand.animateDrawnCardToHand === 'function') {
        return window.__hand.animateDrawnCardToHand(cardTpl);
      }
    }

    // Синхронизирует 3D-модели юнитов с текущим состоянием gameState
    function updateUnits() {
      if (window.__units && typeof window.__units.updateUnits === 'function') {
        window.__units.updateUnits(gameState);
        const ctx = window.__scene && typeof window.__scene.getCtx === 'function'
          ? window.__scene.getCtx() : null;
        if (ctx && ctx.unitMeshes) {
          unitMeshes = ctx.unitMeshes;
          try { window.unitMeshes = unitMeshes; } catch {}
        }
      }
    }

    // Визуализировать изменения между предыдущим и новым состоянием (для наблюдателя/оппонента)
    // Показывает визуальные различия на поле между предыдущим и новым состоянием
    function playDeltaAnimations(prevState, nextState) {
      try {
        if (!prevState || !nextState) return;
        
        // Для активного игрока не показываем числа HP из playDeltaAnimations - они идут из локальных анимаций
        const isActivePlayer = (typeof MY_SEAT === 'number' && typeof gameState !== 'undefined' && gameState && typeof gameState.active === 'number' && MY_SEAT === gameState.active);
        
        const prevB = prevState.board || [];
        const nextB = nextState.board || [];
        
        // Обрабатываем появление/исчезновение юнитов для всех игроков
        for (let r = 0; r < 3; r++) {
          for (let c = 0; c < 3; c++) {
            const pu = (prevB[r] && prevB[r][c] && prevB[r][c].unit) ? prevB[r][c].unit : null;
            const nu = (nextB[r] && nextB[r][c] && nextB[r][c].unit) ? nextB[r][c].unit : null;
            if (pu && !nu) {
              // Юнит исчез — проигрываем шейдерное «исчезновение» фантома и орб маны
              try {
                const tile = tileMeshes?.[r]?.[c]; if (!tile) continue;
                const ghost = createCard3D(CARDS[pu.tplId], false);
                ghost.position.copy(tile.position).add(new THREE.Vector3(0, 0.28, 0));
                try { effectsGroup.add(ghost); } catch { cardGroup.add(ghost); }
                window.__fx.dissolveAndAsh(ghost, new THREE.Vector3(0,0,0.6), 0.9);
                const p = tile.position.clone().add(new THREE.Vector3(0, 1.2, 0));
                animateManaGainFromWorld(p, pu.owner, true);
                try { if (!NET_ACTIVE && gameState && gameState.players && typeof pu.owner === 'number') { gameState.players[pu.owner].mana = capMana((gameState.players[pu.owner].mana||0) + 1); updateUI(); } } catch {}
              } catch {}
            } else if (!pu && nu) {
              // Юнит появился — лёгкий «поп» масштаба
              try {
                const tMesh = unitMeshes.find(m => m.userData.row === r && m.userData.col === c);
                if (tMesh) {
                  const s = tMesh.scale.clone();
                  tMesh.scale.set(s.x * 0.7, s.y * 0.7, s.z * 0.7);
                  gsap.to(tMesh.scale, { x: s.x, y: s.y, z: s.z, duration: 0.28, ease: 'power2.out' });
                }
              } catch {}
            }
          }
        }
        
        // Для активного игрока не показываем числа HP - они есть в локальных анимациях
        if (isActivePlayer) {
          return;
        }

        // Для неактивного игрока показываем числа HP с последовательными задержками
        const hpChanges = [];
        for (let r = 0; r < 3; r++) {
          for (let c = 0; c < 3; c++) {
            const pu = (prevB[r] && prevB[r][c] && prevB[r][c].unit) ? prevB[r][c].unit : null;
            const nu = (nextB[r] && nextB[r][c] && nextB[r][c].unit) ? nextB[r][c].unit : null;
            if (pu && nu) {
              const pHP = (typeof pu.currentHP === 'number') ? pu.currentHP : pu.hp;
              const nHP = (typeof nu.currentHP === 'number') ? nu.currentHP : nu.hp;
              const delta = (typeof pHP === 'number' && typeof nHP === 'number') ? (nHP - pHP) : 0;
              if (delta !== 0) {
                hpChanges.push({ r, c, delta });
              }
            }
          }
        }

        // Показываем HP изменения последовательно
        // Первая половина изменений - через 500мс (после первой атаки)
        // Вторая половина - через 1300мс (после контратаки)
        // Filter out recent remote damage already shown during battleAnim/retaliation
        const __now = Date.now();
        const pendingHpChanges = (typeof window !== 'undefined' && window.RECENT_REMOTE_DAMAGE && window.RECENT_REMOTE_DAMAGE.size)
          ? hpChanges.filter(change => {
              try {
                const key = `${change.r},${change.c}`;
                const rec = window.RECENT_REMOTE_DAMAGE.get(key);
                return !(rec && rec.delta === change.delta && (__now - rec.ts) < 2000);
              } catch { return true; }
            })
          : hpChanges;

        // Schedule HP popups in a cancelable way to sync with remote battle shakes
        const halfCount = Math.ceil(pendingHpChanges.length / 2);
        for (let i = 0; i < halfCount && i < pendingHpChanges.length; i++) {
          const change = pendingHpChanges[i];
          window.__fx.scheduleHpPopup(change.r, change.c, change.delta, 800);
        }
        if (pendingHpChanges.length > halfCount) {
          for (let i = halfCount; i < pendingHpChanges.length; i++) {
            const change = pendingHpChanges[i];
            window.__fx.scheduleHpPopup(change.r, change.c, change.delta, 1600);
          }
        }
      } catch {}
    }
    // attachHpOverlay удалён, т.к. HP теперь перерисовывается на самой карте
    
      // Взаимодействия с 3D-сценой вынесены в модуль src/scene/interactions.js
    
    async function initGame() {
      gameState = startGame(STARTER_FIRESET, STARTER_FIRESET);
      try { window.gameState = gameState; } catch {}
      
      // Сразу строим сцену и мета-объекты, без задержки появления
      createBoard();
      createMetaObjects();
      updateUnits();
      updateHand();
      updateUI();
      // Заставка хода при старте игры с резервом (ускорена)
      try { 
        if (window.__ui && window.__ui.banner) {
          const b = window.__ui.banner; const t = gameState?.turn;
          const fn = (typeof b.ensureTurnSplashVisible === 'function') ? b.ensureTurnSplashVisible : b.forceTurnSplashWithRetry;
          await fn.call(b, 2, t);
        } else {
          await forceTurnSplashWithRetry(2, gameState?.turn);
        }
      } catch {}
      // Запуск таймера на первом ходу
      try { if (window.__turnTimerId) clearInterval(window.__turnTimerId); } catch {}
      window.__turnTimerSeconds = 100;
      (function syncBtn(){ try {
        const btn = document.getElementById('end-turn-btn');
        if (btn) {
          const fill = btn.querySelector('.time-fill');
          const txt = btn.querySelector('.sec-text');
          if (txt) txt.textContent = `${window.__turnTimerSeconds}`;
          if (fill) fill.style.top = `0%`;
        }
      } catch {} })();
      try {
        if (window.__ui && window.__ui.turnTimer) {
          const tt = window.__ui.turnTimer.attach('end-turn-btn');
          const online = (typeof NET_ON === 'function') ? NET_ON() : !!(typeof NET_ACTIVE !== 'undefined' && NET_ACTIVE);
          if (online) { tt.stop(); } else { tt.reset(100).start(); }
        }
      } catch {}
      
      addLog('The game has begun! Player 1 goes first.');
      addLog('Drag units to the field, use spells by clicking.');
    }
    
    // endTurn перенесён в ui/actions.js
    
    function animate() {
      if (window.__scene && typeof window.__scene.animate === 'function') {
        window.__scene.animate();
      }
    }

    function wireModules() {
      try {
        DIR_VECTORS = window.DIR_VECTORS; OPPOSITE_ELEMENT = window.OPPOSITE_ELEMENT; elementEmoji = window.elementEmoji;
        turnCW = window.turnCW; turnCCW = window.turnCCW; facingDeg = window.facingDeg;
        uid = window.uid; inBounds = window.inBounds; capMana = window.capMana; attackCost = window.attackCost;
        CARDS = window.CARDS; STARTER_FIRESET = window.STARTER_FIRESET || [];
        dirsForPattern = window.dirsForPattern; computeCellBuff = window.computeCellBuff; effectiveStats = window.effectiveStats;
        hasAdjacentGuard = window.hasAdjacentGuard; computeHits = window.computeHits; stagedAttack = window.stagedAttack; magicAttack = window.magicAttack;
        shuffle = window.shuffle; drawOne = window.drawOne; drawOneNoAdd = window.drawOneNoAdd; countControlled = window.countControlled; startGame = window.startGame;
      } catch {}
    }

    function init() {
      wireModules();
      initThreeJS();
      // Start render loop early so scene is visible even if game init fails
      animate();
      initGame();
      
      // Привязка обработчиков взаимодействия теперь в модуле interactions
      window.__interactions.setupInteractions();
    }
    try { window.init = init; window.initThreeJS = initThreeJS; window.initGame = initGame; window.animate = animate; } catch {}

    // UI wrappers: use modules only
    // animateTurnManaGain теперь вызывается напрямую через модуль
      

    function createMetaObjects() {
      // Очистить предыдущие
      deckMeshes.forEach(m => m.parent && m.parent.remove(m));
      graveyardMeshes.forEach(m => m.parent && m.parent.remove(m));
      deckMeshes = []; graveyardMeshes = [];
      if (!gameState) return;
      const baseX = (6.2 + 0.2) * 1 + 6.6; // правее поля
      const zA = -5.2 - META_Z_AWAY; const zB = 0.2 + META_Z_AWAY; // Важно (смещение колоды/кладбища от камеры)
      function buildDeck(player, z) {
        const g = new THREE.Group(); g.position.set(baseX, 0.5, z); g.userData = { metaType: 'deck', player };
        const sideMap = (CARD_TEX && CARD_TEX.deckSide) ? CARD_TEX.deckSide : window.__cards.getCachedTexture('textures/card_deck_side_view.jpeg');
        const backMap = (CARD_TEX && CARD_TEX.back) ? CARD_TEX.back : window.__cards.getCachedTexture('textures/card_back_main.jpeg');
        const sideMat = new THREE.MeshStandardMaterial({ map: sideMap, color: 0xffffff, metalness: 0.3, roughness: 0.85 });
        const body = new THREE.Mesh(new THREE.BoxGeometry(3.6, 0.8, 5.0), sideMat);
        body.castShadow = true; body.receiveShadow = true; body.userData = { metaType: 'deck', player };
        const top = new THREE.Mesh(new THREE.BoxGeometry(3.62, 0.04, 5.02), new THREE.MeshStandardMaterial({ map: backMap, color: 0xffffff }));
        top.position.y = 0.42; top.userData = { metaType: 'deck', player };
        g.add(body); g.add(top); metaGroup.add(g); deckMeshes.push(g);
      }
      function buildGrave(player, z) {
        const g = new THREE.Group(); g.position.set(baseX + 4.2, 0.5, z); g.userData = { metaType: 'grave', player };
        const base = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.2, 0.3, 20), new THREE.MeshStandardMaterial({ color: 0x334155 }));
        base.userData = { metaType: 'grave', player };
        const icon = new THREE.Mesh(new THREE.BoxGeometry(1.0, 1.2, 0.1), new THREE.MeshStandardMaterial({ color: 0x64748b }));
        icon.position.y = 0.9; icon.rotation.y = Math.PI / 8; icon.userData = { metaType: 'grave', player };
        g.add(base); g.add(icon); metaGroup.add(g); graveyardMeshes.push(g);
      }
      buildDeck(0, zA); buildDeck(1, zB); buildGrave(0, zA); buildGrave(1, zB);
    }
    
    // Обработчики UI
    document.getElementById('end-turn-btn').addEventListener('click', () => {
      try { window.__ui?.actions?.endTurn?.(); } catch {}
    });
    refreshInputLockUI();
    document.getElementById('new-game-btn').addEventListener('click', () => location.reload());
    document.getElementById('log-btn').addEventListener('click', () => {
      const lp = document.getElementById('log-panel');
      lp.classList.toggle('hidden');
      // На всякий случай жёстко позиционируем ниже контролов
      lp.style.top = (document.getElementById('controls').offsetHeight + 40) + 'px';
      if (!lp.classList.contains('hidden')) lp.style.pointerEvents = 'auto';
    });
    document.getElementById('close-log-btn').addEventListener('click', () => {
      document.getElementById('log-panel').classList.add('hidden');
    });
    document.getElementById('help-btn').addEventListener('click', () => {
      document.getElementById('help-panel').classList.remove('hidden');
    });
    document.getElementById('close-help-btn').addEventListener('click', () => {
      document.getElementById('help-panel').classList.add('hidden');
    });
    // Prompt handlers
      document.getElementById('cancel-prompt-btn').addEventListener('click', () => {
        const prompt = window.activePrompt;
        if (prompt && typeof prompt.onCancel === 'function') {
          try { prompt.onCancel(); } catch {}
        }
        window.__ui.panels.hidePrompt();
      });
      document.getElementById('cancel-orient-btn').addEventListener('click', () => {
        const pp = window.__interactions.getPendingPlacement();
        if (pp) {
          window.__interactions.returnCardToHand(pp.card);
        }
        window.__ui.panels.hideOrientationPanel();
        window.__interactions.clearPendingPlacement();
      });
      document.getElementById('cancel-action-btn').addEventListener('click', () => {
        window.__interactions.clearSelectedUnit();
        window.__ui.panels.hideUnitActionPanel();
      });
      // Действия в панели юнита
      document.getElementById('rotate-cw-btn').addEventListener('click', () => {
        const u = window.__interactions.getSelectedUnit();
        if (u) window.__ui.actions.rotateUnit(u, 'cw');
      });
      document.getElementById('rotate-ccw-btn').addEventListener('click', () => {
        const u = window.__interactions.getSelectedUnit();
        if (u) window.__ui.actions.rotateUnit(u, 'ccw');
      });
      document.getElementById('attack-btn').addEventListener('click', () => {
        const u = window.__interactions.getSelectedUnit();
        if (u) window.__ui.actions.performUnitAttack(u);
      });
    
    document.querySelectorAll('[data-dir]').forEach(btn => {
      btn.addEventListener('click', () => {
        const direction = btn.getAttribute('data-dir');
        const pso = window.__interactions.getPendingSpellOrientation();
        if (pso) {
          const { spellCardMesh, unitMesh } = pso;
          const idx = spellCardMesh.userData.handIndex;
          const pl = gameState.players[gameState.active];
          const tpl = pl.hand[idx];
          const r = unitMesh.userData.row; const c = unitMesh.userData.col; const u = gameState.board[r][c].unit;
          if (tpl && tpl.id === 'SPELL_BEGUILING_FOG' && u) {
            u.facing = direction;
            addLog(`${tpl.name}: ${CARDS[u.tplId].name} повёрнут в ${direction}.`);
            pl.discard.push(tpl); pl.hand.splice(idx, 1);
            window.__interactions.resetCardSelection(); updateHand(); updateUnits(); updateUI();
          }
          window.__interactions.clearPendingSpellOrientation();
          window.__ui.panels.hideOrientationPanel();
          return;
        }
        window.__interactions.placeUnitWithDirection(direction);
      });
    });
    
    document.addEventListener('DOMContentLoaded', init);

      /* UI action helpers moved to src/ui/actions.js */
    
    
    // (убраны несуществующие обработчики magic-btn и draw-btn)
  </script>
<!-- MODULE: network/multiplayer (socket.io sync, queue, indicator) -->
<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
<script type="module" src="./src/net/client.js"></script>
</body>
</html>
