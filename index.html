<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="client-repo" content="knpavlov/Eye-of-grid-3D@main"> 
  <title>Eye of Grid — Complete 3D</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="styles/main.css">
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
  <script type="module" src="./src/main.js"></script>
  <script>
    // Early globals so later scripts never crash if earlier code aborted
    (function(){
      try { if (typeof window.NET_ACTIVE === 'undefined') window.NET_ACTIVE = false; } catch(e){}
      try { if (typeof window.MY_SEAT === 'undefined') window.MY_SEAT = null; } catch(e){}
      try { if (typeof window.APPLYING === 'undefined') window.APPLYING = false; } catch(e){}
      try { if (typeof window.NET_ON === 'undefined') window.NET_ON = function(){ try { return !!window.NET_ACTIVE; } catch(e){ return false; } }; } catch(e){}

      // Define core UI lock flags upfront to avoid ReferenceError on first access
      try { if (typeof window.__endTurnInProgress === 'undefined') window.__endTurnInProgress = false; } catch(e){}
      try { if (typeof window.drawAnimationActive === 'undefined') window.drawAnimationActive = false; } catch(e){}
      try { if (typeof window.splashActive === 'undefined') window.splashActive = false; } catch(e){}

      // nothing else inside IIFE
    })();
    // Also create global bindings (var) so bare identifiers work in this file
    try {
      /* eslint-disable no-var */
      var __endTurnInProgress = window.__endTurnInProgress;
      var drawAnimationActive = window.drawAnimationActive;
      var splashActive = window.splashActive;
      // keep window properties in sync (assign again just in case)
      window.__endTurnInProgress = __endTurnInProgress;
      window.drawAnimationActive = drawAnimationActive;
      window.splashActive = splashActive;
    } catch(e){}
  </script>
</head>
<body>
  <canvas id="three-canvas"></canvas>
  
  <div id="ui">
    <!-- Боковые панели: слева — игрок A, справа — игрок B -->
    <div id="left-side" class="ui-panel fixed left-4 top-1/2 -translate-y-1/2 space-y-3 z-20 flex flex-col items-center">
      <div id="player-title-0" class="text-2xl md:text-3xl font-semibold text-center w-full">Игрок 1</div>
      <div class="overlay-panel px-4 py-2">
        <div class="text-sm mb-1">Mana</div>
        <div class="mana-bar" id="mana-display-0"></div>
      </div>
      <div class="overlay-panel px-4 py-2 text-sm" id="control-info-0">Controlled cells: 0</div>
    </div>

    <div id="right-side" class="ui-panel fixed right-4 top-1/2 -translate-y-1/2 space-y-3 z-20 flex flex-col items-center">
      <div id="player-title-1" class="text-2xl md:text-3xl font-semibold text-center w-full">Игрок 2</div>
      <div class="overlay-panel px-4 py-2">
        <div class="text-sm mb-1">Mana</div>
        <div class="mana-bar" id="mana-display-1"></div>
      </div>
      <div class="overlay-panel px-4 py-2 text-sm" id="control-info-1">Controlled cells: 0</div>
    </div>

    <!-- Верхний центр: номер хода и круглая кнопка с таймером -->
    <div id="top-center" class="ui-panel fixed top-3 left-1/2 -translate-x-1/2 z-20">
      <div class="overlay-panel px-4 py-3 flex flex-col items-center gap-2">
        <div id="turn-info" class="text-sm tracking-wide">Turn: 1</div>
        <button id="end-turn-btn" class="end-turn-btn" aria-label="End Turn">
          <span class="time-fill"></span>
          <span class="label-text">End Turn</span>
          <span class="sec-text">100</span>
        </button>
      </div>
    </div>

    <!-- Правый нижний угол: сервисные кнопки -->
    <div id="corner-right" class="ui-panel fixed right-4 bottom-4 z-20">
      <div class="flex gap-2 opacity-90">
        <button id="log-btn" class="overlay-panel px-3 py-1.5 text-xs bg-slate-600 hover:bg-slate-700 transition-colors">Log</button>
        <button id="help-btn" class="overlay-panel px-3 py-1.5 text-xs bg-slate-600 hover:bg-slate-700 transition-colors">Help</button>
        <button id="new-game-btn" class="overlay-panel px-3 py-1.5 text-xs bg-slate-600 hover:bg-slate-700 transition-colors">Play offline</button>
      </div>
    </div>
    
    <!-- Панель логов -->
    <div id="log-panel" class="ui-panel fixed right-4 bottom-20 w-96 h-80 overlay-panel p-4 hidden z-30">
      <div class="flex justify-between items-center mb-3">
        <h3 class="text-lg font-semibold">Log</h3>
        <button id="close-log-btn" class="text-xl">&times;</button>
      </div>
      <div id="log-content" class="h-full overflow-y-auto text-sm space-y-1"></div>
    </div>
    
    <!-- Панель помощи -->
    <div id="help-panel" class="ui-panel fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden z-40">
      <div class="overlay-panel p-6 max-w-lg">
        <div class="flex justify-between items-center mb-4">
          <h3 class="text-xl font-semibold">How to play</h3>
          <button id="close-help-btn" class="text-xl">&times;</button>
        </div>
        <div class="space-y-3 text-sm">
          <p>• Перетаскивайте карты существ на игровое поле</p>
          <p>• Выбирайте направление после размещения</p>
          <p>• Кликайте по своим существам для атаки или поворота</p>
          <p>• Используйте заклинания, перетаскивая их на цель или на поле</p>
          <p>• Победа: контролируйте 5+ клеток в конце хода</p>
        </div>
      </div>
    </div>
    
    <!-- Панель выбора направления -->
    <div id="orientation-panel" class="ui-panel fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden z-40">
      <div class="overlay-panel p-6">
        <div class="text-center mb-4">Chose direction</div>
        <div class="grid grid-cols-3 gap-2 w-48 mx-auto">
          <div></div>
          <button data-dir="N" class="overlay-panel px-4 py-2 hover:bg-slate-700">↑</button>
          <div></div>
          <button data-dir="W" class="overlay-panel px-4 py-2 hover:bg-slate-700">←</button>
          <div class="overlay-panel px-4 py-2 text-center">•</div>
          <button data-dir="E" class="overlay-panel px-4 py-2 hover:bg-slate-700">→</button>
          <div></div>
          <button data-dir="S" class="overlay-panel px-4 py-2 hover:bg-slate-700">↓</button>
          <div></div>
        </div>
        <div class="text-center mt-4">
          <button id="cancel-orient-btn" class="overlay-panel px-4 py-2 bg-red-600 hover:bg-red-700">Отмена</button>
        </div>
      </div>
    </div>
    
    <!-- Панель действий с существом -->
    <div id="unit-action-panel" class="ui-panel fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden z-40">
      <div class="overlay-panel p-6 space-y-3">
        <div id="unit-info" class="text-center mb-4"></div>
        <button id="attack-btn" class="w-full overlay-panel px-4 py-2 bg-red-600 hover:bg-red-700">Attack</button>
        <div class="grid grid-cols-2 gap-2">
          <button id="rotate-cw-btn" class="overlay-panel px-4 py-2 hover:bg-slate-700">Rotate ↻</button>
          <button id="rotate-ccw-btn" class="overlay-panel px-4 py-2 hover:bg-slate-700">Rotate ↺</button>
        </div>
        <button id="cancel-action-btn" class="w-full overlay-panel px-4 py-2 bg-gray-600 hover:bg-gray-700">Cancel</button>
      </div>
    </div>

    <!-- Постоянная панель подсказок/промптов -->
    <div id="prompt-panel" class="ui-panel fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden z-40">
      <div class="overlay-panel p-6 space-y-4">
        <div id="prompt-text" class="text-center"></div>
        <div class="text-center">
          <button id="cancel-prompt-btn" class="overlay-panel px-4 py-2 bg-gray-600 hover:bg-gray-700">Cancel</button>
        </div>
      </div>
    </div>
    
    <!-- Уведомленчиния -->
    <div id="notifications" class="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-50 pointer-events-none"></div>

    <!-- Баннеры: Turn и Battle -->
    <div id="turn-banner" class="banner fixed inset-0 hidden items-center justify-center z-40"></div>
    <div id="battle-banner" class="banner fixed inset-0 hidden items-center justify-center z-40">
      <div class="battlePop text-5xl font-extrabold bg-gradient-to-br from-red-600/80 to-yellow-500/80 px-10 py-5 rounded-3xl shadow-2xl ring-4 ring-yellow-400/40">BATTLE</div>
    </div>
    <!-- Tooltip -->
    <div id="hover-tooltip" class="hidden overlay-panel px-2 py-1 text-xs"></div>
  </div>

  <!-- Версия билда (сверху слева) -->
  <div id="build-version" class="fixed left-0 top-0 z-20 text-xs text-slate-300 opacity-80 p-1.5"></div>

  <script>
    // ====== ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ ======
    // Переменные для мультиплеера (должны быть доступны везде)
    var NET_ACTIVE = false;
    var MY_SEAT = null;
    var APPLYING = false;
    
    // ====== ИГРОВАЯ ЛОГИКА (полная версия из 2D) ======
    
    let DIR_VECTORS, OPPOSITE_ELEMENT, elementEmoji, turnCW, turnCCW;
    // Переопределяем ориентации: N должен смотреть к верхнему краю (−Z), S — к нижнему (+Z)
    // В three.js «вперёд» меша по умолчанию это +Z (0°), поэтому:
    // S: 0°, E: -90°, W: 90°, N: 180°
    // Исправление: N (стрелка вверх) = 0°, S (стрелка вниз) = 180°; E/W оставляем как есть
    let facingDeg;
    
    let uid, inBounds, capMana, attackCost;
    
    // Карты
    let CARDS;
    
    // Стартер: только Fire Set + несколько спеллов
    let STARTER_FIRESET;
    
    // Функции игровой логики
    let dirsForPattern;
    
    const computeCellBuff = (cellElement, unitElement) => {
      if (cellElement === unitElement) return { atk: 0, hp: 2 };
      if (cellElement === 'MECH') return { atk: 0, hp: 0 };
      const opp = OPPOSITE_ELEMENT[unitElement];
      if (cellElement === opp) return { atk: 0, hp: -2 };
      return { atk: 0, hp: 0 };
    };
    
    let effectiveStats;
    
    const randomBoard = () => {
      // 5 элементов: FIRE, WATER, EARTH, FOREST, MECH
      // Центр (1,1) = MECH. Остальные 8 клеток: из FIRE/WATER/EARTH/FOREST по 2 штуки каждого
      const picks = ['FIRE','FIRE','WATER','WATER','EARTH','EARTH','FOREST','FOREST'];
      // Перемешаем и разложим по клеткам, пропуская центр
      for (let i = picks.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [picks[i], picks[j]] = [picks[j], picks[i]]; }
      let k = 0;
      const board = Array.from({ length: 3 }, () => Array.from({ length: 3 }, () => ({ element: 'FIRE' })));
      for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 3; c++) {
          if (r === 1 && c === 1) { board[r][c].element = 'MECH'; continue; }
          board[r][c].element = picks[k++];
        }
      }
      return board;
    };
    
    let shuffle;
    
    let drawOne;

    // Специальная версия: вынуть верхнюю карту, но НЕ класть в руку (для эффектной анимации)
    let drawOneNoAdd;
    
    let countControlled;
    
    let startGame;
    
    // ====== БОЕВАЯ СИСТЕМА (порт из 2D) ======
    let hasAdjacentGuard;
    let computeHits;
/*          const backDir = turnCW[turnCW[B.facing]];
          const [bdr, bdc] = DIR_VECTORS[backDir];
          const isBack = (nr + bdr === r && nc + bdc === c);
          // Определяем направление на атакующего относительно ПОВОРОТА цели
          const dirAbs = (() => {
            if (r === nr - 1 && c === nc) return 'N';
            if (r === nr + 1 && c === nc) return 'S';
            if (r === nr && c === nc - 1) return 'W';
            return 'E';
          })();
          const ORDER = ['N','E','S','W'];
          const absIdx = ORDER.indexOf(dirAbs);
          const faceIdx = ORDER.indexOf(B.facing);
          const relIdx = (absIdx - faceIdx + 4) % 4;
          const dirRel = ORDER[relIdx];
          const blind = CARDS[B.tplId].blindspots || ['S'];
          const inBlind = blind.includes(dirRel);
          // Исключаем двойное начисление за спину: максимум +1
          const extraTotal = isBack ? 1 : (inBlind ? 1 : 0);
          const dmg = Math.max(0, atk + extraTotal);
          hits.push({ r: nr, c: nc, dmg, backstab: isBack });
          break; // первая цель по лучу
        }
      }
      return hits;
    */
    
    let stagedAttack;
    let magicAttack;
    
    // ====== THREE.JS СЦЕНА ======
    
    let scene, camera, renderer, raycaster, mouse;
    let boardGroup, cardGroup, effectsGroup, metaGroup;
    let tileMeshes = [];
    let tileFrames = [];
    let unitMeshes = [];
    let handCardMeshes = [];
    let gameState = null;
    let logEntries = [];
    let TILE_TEXTURES = {};
    // Legacy CARD_TEX placeholder: modules expose window.CARD_TEX when preloaded
    var CARD_TEX;
    let PROC_TILE_TEXTURES = {};
    // Настройки показа большой карты при доборе — можно править из консоли
    window.DRAW_CARD_TUNE = {
      posY: 8.5,   // высота
      posZ: 2.4,    // дистанция к камере (чем меньше, тем ближе)
      scale: 1.7,   // масштаб
      // Ручная довращалка (в градусах):
      pitchDeg: 45,  // наклон вперёд/назад (ось X)
      yawDeg: 0,    // поворот влево/вправо (ось Y)
      rollDeg: 0    // крен (ось Z)
    };
    // Legacy CARD_IMAGES/CARD_PENDING removed (handled in modules)
    // Очереди догоняющих анимаций боя для наблюдателя
    let PENDING_BATTLE_ANIMS = [];
    let PENDING_RETALIATIONS = [];
    // Recently shown remote damage (to avoid duplicate delta popups)
    let RECENT_REMOTE_DAMAGE = new Map();
    try { window.RECENT_REMOTE_DAMAGE = RECENT_REMOTE_DAMAGE; } catch {}
    // Pending HP popups scheduled by playDeltaAnimations, so we can cancel if battleAnim shows earlier
    let PENDING_HP_POPUPS = [];
    function cancelPendingHpPopup(key, delta){
      try {
        if (!PENDING_HP_POPUPS || !PENDING_HP_POPUPS.length) return;
        for (const item of PENDING_HP_POPUPS) {
          if (!item.canceled && item.key === key && item.delta === delta) {
            try { clearTimeout(item.timerId); } catch {}
            item.canceled = true;
          }
        }
        PENDING_HP_POPUPS = PENDING_HP_POPUPS.filter(x => !x.canceled);
      } catch {}
    }
    function scheduleHpPopup(r,c,delta,delayMs){
      try {
        const key = `${r},${c}`;
        const timerId = setTimeout(()=>{
          try {
            const tMesh = unitMeshes.find(m => m.userData.row === r && m.userData.col === c);
            if (tMesh) {
              const color = delta > 0 ? '#22c55e' : '#ef4444';
              spawnDamageText(tMesh, `${delta > 0 ? '+' : ''}${delta}`, color);
            }
          } catch {}
        }, Math.max(0, delayMs));
        PENDING_HP_POPUPS.push({ key, delta, timerId, scheduledAt: Date.now() + Math.max(0, delayMs), canceled: false });
      } catch {}
    }
    let PENDING_HIDE_HAND_CARDS = [];
    // Управление анимациями заставки хода и добора карты
    let lastTurnSplashPromise = Promise.resolve();
    let lastSplashTurnRequested = 0;
    let lastSplashTurnShown = 0;
    let turnSplashTurnQueued = 0;
    function queueTurnSplash(title) {
      try {
        lastTurnSplashPromise = lastTurnSplashPromise.then(() => showTurnSplash(title));
      } catch {}
      return lastTurnSplashPromise;
    }
    
    // Функция показа заставки хода
    async function showTurnSplash(title) {
      splashActive = true;
      refreshInputLockUI();
      
      const banner = document.getElementById('turn-banner');
      if (banner) {
        banner.innerHTML = `<div class="text-4xl font-bold bg-gradient-to-br from-blue-600/80 to-purple-500/80 px-8 py-4 rounded-2xl shadow-2xl ring-4 ring-blue-400/40">${title}</div>`;
        banner.classList.remove('hidden');
        banner.classList.add('flex');
        
        // Показываем заставку на 1 секунду <-- важно - длительность заставки боя!
        setTimeout(() => {
          banner.classList.add('hidden');
          banner.classList.remove('flex');
          splashActive = false;
          refreshInputLockUI();
        }, 1000);
      }
      
      return new Promise(resolve => setTimeout(resolve, 1000));
    }
    // Резерв: гарантированно показать заставку с повтором, если вдруг не отрисовалась
    async function forceTurnSplashWithRetry(maxRetries = 2) {
      let tries = 0;
      let shown = false;
      while (tries <= maxRetries && !shown) {
        tries += 1;
        await requestTurnSplash();
        // ждем 2 кадра, чтобы DOM успел применить display:flex
        await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
        try {
          const tb = document.getElementById('turn-banner');
          shown = !!tb && (tb.classList.contains('flex') || tb.style.display === 'flex');
        } catch {}
      }
      // Страховка от зависания блокировки ввода
      setTimeout(() => { splashActive = false; refreshInputLockUI(); }, 1000);
    }
    async function requestTurnSplash() {
      if (!gameState) return;
      const currentTurn = gameState.turn;
      // если уже показали в этом ходу — ничего не делаем
      if (lastSplashTurnShown >= currentTurn) return lastTurnSplashPromise;
      // если уже стоит в очереди на этот ход — возвращаем существующий промис
      if (turnSplashTurnQueued === currentTurn) return lastTurnSplashPromise;
      lastSplashTurnRequested = currentTurn;
      turnSplashTurnQueued = currentTurn;
      const title = `Ход ${currentTurn} - Игрок ${gameState.active + 1}`;
      // Оборачиваем в промис, который по завершении отмечает ход показанным
      lastTurnSplashPromise = queueTurnSplash(title).then(() => {
        try { lastSplashTurnShown = currentTurn; } catch {}
        if (turnSplashTurnQueued === currentTurn) turnSplashTurnQueued = 0;
      });
      return lastTurnSplashPromise;
    }
    
    let manaGainActive = false;
    let PENDING_MANA_ANIM = null; // { ownerIndex, startIdx, endIdx }
    let PENDING_MANA_BLOCK = [0,0]; // by player index
    try { window.manaGainActive = manaGainActive; } catch {}
// Ожидаемая анимация маны: диапазон новых орбов, которые должны появиться синхронно со вспышкой
        try { window.PENDING_MANA_ANIM = PENDING_MANA_ANIM; } catch {}
    // Блокировка появления N последних орбов маны на панели до завершения «полетевших» визуальных орбов (смерть/эффекты)
        try { window.PENDING_MANA_BLOCK = PENDING_MANA_BLOCK; } catch {}
    // Прячет один экземпляр ритуального спелла в руке активного игрока, пока ждём выбора жертвы
    let pendingRitualSpellHandIndex = null;
    let pendingRitualSpellCard = null; // ссылка на сам объект карты-спелла, чтобы скрывать по идентичности
    // Сколько последних добранных карт временно скрывать из моей руки (для красивой анимации влёта)
    let pendingDrawCount = 0;
    function isInputLocked() {
  const splash = (typeof window !== 'undefined' && window.__ui && window.__ui.banner)
    ? !!window.__ui.banner.getState()._splashActive : false;
  const mana = (typeof window !== 'undefined' && typeof window.manaGainActive === 'boolean')
    ? !!window.manaGainActive : false;
  const endTurn = (typeof window !== 'undefined' && typeof window.__endTurnInProgress === 'boolean')
    ? !!window.__endTurnInProgress : !!__endTurnInProgress;
  const draw = (typeof window !== 'undefined' && typeof window.drawAnimationActive === 'boolean')
    ? !!window.drawAnimationActive : !!drawAnimationActive;
  return endTurn || draw || splash || mana;
}
    function refreshInputLockUI() {
      try {
        const endBtn = document.getElementById('end-turn-btn');
        if (endBtn) endBtn.disabled = isInputLocked();
      } catch {}
    }
    // Отступ руки по оси Z (положительное — дальше от камеры)
    const HAND_Z_OFFSET = 1.0;
    // Смещение колод/кладбищ от камеры вдоль оси Z (положительное значение — дальше от камеры)
    const META_Z_AWAY = 1.5;
    // 3D объекты справа (колоды/кладбища)
    let deckMeshes = [];
    let graveyardMeshes = [];
    let hoveredMeta = null; // { metaType: 'deck'|'grave', player: 0|1 }
    
    // Состояние взаимодействия
    let draggedCard = null;
    let hoveredTile = null;
    let hoveredHandCard = null;
    let selectedCard = null;
    let pendingPlacement = null;
    let selectedUnit = null;
    let magicFrom = null; // { r, c }
    // Паузы/состояния для новых механик
    let pendingSpellOrientation = null; // { spellCardMesh, unitMesh }
    let pendingDiscardSelection = null; // { requiredType: 'UNIT', onPicked: function }
    let activePrompt = null; // { text: string, onCancel: function }
    let pendingRitualBoardMesh = null; // временный меш спелла на поле
    let spellDragHandled = false; // флаг, что возврат карты в руку уже не нужен

    
    function initThreeJS() {
      const canvas = document.getElementById('three-canvas');
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.setClearColor(0x0b1220);
      // Цветовое пространство и экспозиция — повысим читаемость текстур
      if (THREE.SRGBColorSpace) {
        renderer.outputColorSpace = THREE.SRGBColorSpace;
      }
      renderer.toneMappingExposure = 1.08;
      
      scene = new THREE.Scene();
      // Сделаем даль менее тёмной: убираем туман
      scene.fog = null;
      
      camera = new THREE.PerspectiveCamera(54, window.innerWidth / window.innerHeight, 0.1, 120);
      camera.position.set(0, 22, 13);
      camera.lookAt(0, 1.2, 0);
      
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();
      
      boardGroup = new THREE.Group();
      cardGroup = new THREE.Group();
      effectsGroup = new THREE.Group();
      metaGroup = new THREE.Group();
      scene.add(boardGroup);
      scene.add(cardGroup);
      scene.add(effectsGroup);
      scene.add(metaGroup);
      try { window.renderer = renderer; window.scene = scene; window.camera = camera; window.boardGroup = boardGroup; } catch {}
      
      // Освещение
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
      directionalLight.position.set(10, 20, 10);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.set(2048, 2048);
      directionalLight.shadow.camera.near = 1;
      directionalLight.shadow.camera.far = 50;
      directionalLight.shadow.camera.left = -15;
      directionalLight.shadow.camera.right = 15;
      directionalLight.shadow.camera.top = 15;
      directionalLight.shadow.camera.bottom = -15;
      scene.add(directionalLight);
      // Дополнительный полушарной свет, чтобы вдали было светлее
      const hemi = new THREE.HemisphereLight(0xcadfff, 0x1a2a3a, 0.6);
      scene.add(hemi);
      
      // Платформа
      const platformGeometry = new THREE.CylinderGeometry(32, 32, 0.7, 48);
      const platformMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x1a2332, 
        metalness: 0.7, 
        roughness: 0.3 
      });
      const platform = new THREE.Mesh(platformGeometry, platformMaterial);
      platform.position.y = -0.35;
      platform.receiveShadow = true;
      scene.add(platform);
      // Загрузка текстур тайлов поля из папки textures/
      const loader = new THREE.TextureLoader();
      const ASSET_VERSION = '2';
      const baseMap = { FIRE: './textures/tile_fire.png', WATER: './textures/tile_water.png', EARTH: './textures/tile_earth.png', FOREST: './textures/tile_forest.png', MECH: './textures/tile_mech.png' };
      for (const k in baseMap) {
        const path = `${baseMap[k]}?v=${ASSET_VERSION}`;
        loader.load(
          path,
          (tex) => {
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(1, 1);
            tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
            if (THREE.SRGBColorSpace) tex.colorSpace = THREE.SRGBColorSpace;
            TILE_TEXTURES[k] = tex;
            tex.needsUpdate = true;
            // Если поле уже создано — обновим материалы соответствующих тайлов
            try { updateTileMaterialsFor(k); } catch {}
          },
          undefined,
          () => {
            // если не удалось — оставим процедурную текстуру как фолбэк
            try { console.warn('Could not load tile texture', k, path); } catch {}
          }
        );
      }
    }

    function worldToScreen(vec3) {
      const v = vec3.clone().project(camera);
      const x = (v.x + 1) / 2 * renderer.domElement.clientWidth;
      const y = (1 - v.y) / 2 * renderer.domElement.clientHeight;
      return { x, y };
    }

    function animateManaGainFromWorld(pos, ownerIndex, visualOnly = true) {
      try {
        const start = worldToScreen(pos);
        const barEl = document.getElementById(`mana-display-${ownerIndex}`);
        if (!barEl) return;
        // определить целевую ячейку
        const currentMana = (gameState && gameState.players && gameState.players[ownerIndex]) ? (gameState.players[ownerIndex].mana || 0) : 0;
        let targetIdx = Math.min(9, currentMana);
        // В visualOnly режиме орб всегда летит в позицию currentMana - 1 (последний свободный слот)
        try {
          if (visualOnly) {
            // Если мана уже учтена в state (т.е. currentMana включает +1 от только что убитого существа),
            // то орб должен лететь в индекс currentMana - 1 (последний реально свободный орб).
            // Подстрахуемся и не уйдём левее нуля.
            targetIdx = Math.max(0, Math.min(9, currentMana - 1));
          }
        } catch {}
        // Блокируем появление орба в панели до завершения полета
        if (visualOnly && typeof ownerIndex === 'number') {
          try {
            const mySeat = (typeof window !== 'undefined' && typeof window.MY_SEAT === 'number') ? window.MY_SEAT : null;
            // Блокируем орб для всех игроков до завершения анимации полета
            PENDING_MANA_BLOCK[ownerIndex] = window.PENDING_MANA_BLOCK[ownerIndex] = Math.max(0, (PENDING_MANA_BLOCK[ownerIndex] || 0) + 1);
            updateUI();
          } catch {}
        }
        const child = barEl.children && barEl.children[targetIdx];
        let tx, ty;
        if (child) {
          const srect = child.getBoundingClientRect();
          tx = srect.left + srect.width / 2;
          ty = srect.top + srect.height / 2;
        } else {
          const rect = barEl.getBoundingClientRect();
          tx = rect.left + rect.width / 2;
          ty = rect.top + rect.height / 2;
        }
        const orb = document.createElement('div');
        orb.className = 'mana-orb';
        orb.style.position = 'fixed';
        orb.style.left = start.x + 'px';
        orb.style.top = start.y + 'px';
        orb.style.transform = 'translate(-50%, -50%) scale(0.3)';
        orb.style.opacity = '0';
        orb.style.zIndex = '60';
        document.body.appendChild(orb);
        const tl = gsap.timeline({ onComplete: () => {
          if (orb && orb.parentNode) orb.parentNode.removeChild(orb);
          // Визуальный эффект завершён - теперь показываем орб в панели
          try {
            if (visualOnly && typeof ownerIndex === 'number') {
              // Разблокируем орб для всех игроков когда анимация полета завершена
              PENDING_MANA_BLOCK[ownerIndex] = window.PENDING_MANA_BLOCK[ownerIndex] = Math.max(0, (PENDING_MANA_BLOCK[ownerIndex] || 0) - 1);
              updateUI(); // Орб появится в панели именно в этот момент
            }
          } catch {}
        }});
        // 0.5с появление, затем 2.0с полёт к панели
        tl.to(orb, { duration: 0.5, ease: 'back.out(1.4)', opacity: 1, transform: 'translate(-50%, -50%) scale(1)' })
          .to(orb, { duration: 2.0, ease: 'power2.inOut', left: tx, top: ty }, '>-0.1');
      } catch {}
    }

    // Legacy animateTurnManaGain перенесена в модуль src/ui/mana.js

    // preloadCardImages removed (module handles lazy loading)

    function requestCardsRedraw() {
      clearTimeout(window.__cardsRedrawT);
      window.__cardsRedrawT = setTimeout(() => { updateUnits(); updateHand(); }, 10);
    }

    function createProceduralTileTexture(element) {
      if (PROC_TILE_TEXTURES[element]) return PROC_TILE_TEXTURES[element];
      const c = document.createElement('canvas');
      c.width = 256; c.height = 256; const ctx = c.getContext('2d');
      // фон
      const base = {
        FIRE: '#3b0d0d', WATER: '#0d243b', EARTH: '#2f2b24', FOREST: '#0f2b1a', MECH: '#1f2937'
      }[element] || '#2a2a2a';
      ctx.fillStyle = base; ctx.fillRect(0,0,256,256);
      ctx.globalAlpha = 0.5;
      if (element === 'FIRE') {
        for (let i= -64; i<256; i+=24) {
          ctx.fillStyle = i % 48 === 0 ? '#b91c1c' : '#ef4444';
          ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i+64,0); ctx.lineTo(i+256,256); ctx.lineTo(i+192,256); ctx.closePath(); ctx.fill();
        }
      } else if (element === 'WATER') {
        ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 3; ctx.globalAlpha = 0.7;
        for (let y=20; y<256; y+=24) {
          ctx.beginPath(); for (let x=0; x<=256; x+=8) { ctx.lineTo(x, y + Math.sin((x+y)/20)*6); } ctx.stroke();
        }
      } else if (element === 'EARTH') {
        for (let y=0; y<256; y+=16) {
          for (let x=0; x<256; x+=16) {
            const v = 40 + Math.floor(Math.random()*30);
            ctx.fillStyle = `rgb(${v+60},${v+40},${v})`; ctx.fillRect(x,y,16,16);
          }
        }
      } else if (element === 'FOREST') {
        ctx.fillStyle = '#16a34a';
        for (let i=0; i<180; i++) {
          const x = Math.random()*256; const y = Math.random()*256; const r = Math.random()*3+1;
          ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
        }
        ctx.strokeStyle = '#22c55e'; ctx.globalAlpha = 0.35;
        for (let i=0; i<40; i++) { ctx.beginPath(); ctx.moveTo(Math.random()*256, Math.random()*256); ctx.lineTo(Math.random()*256, Math.random()*256); ctx.stroke(); }
      } else if (element === 'MECH') {
        // простая техно-сетка
        ctx.globalAlpha = 0.6; ctx.strokeStyle = '#9ca3af'; ctx.lineWidth = 1.5;
        for (let y=16; y<256; y+=16) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(256,y); ctx.stroke(); }
        for (let x=16; x<256; x+=16) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,256); ctx.stroke(); }
        ctx.globalAlpha = 0.9; ctx.fillStyle = '#94a3b8';
        for (let i=0; i<40; i++) { const x= Math.floor(Math.random()*16)*16+2; const y=Math.floor(Math.random()*16)*16+2; ctx.fillRect(x,y,2,2); }
      }
      const tex = new THREE.CanvasTexture(c); tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
      tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping; tex.repeat.set(1,1);
      PROC_TILE_TEXTURES[element] = tex; return tex;
    }
    
    // Базовые цвета для элементов (фолбэк, если текстуры не загрузились)
    const ELEMENT_BASE_COLORS = {
      FIRE: 0xdc2626,
      WATER: 0x0369a1,
      EARTH: 0x525252,
      FOREST: 0x166534,
      MECH: 0x334155
    };

    function getTileMaterial(element) {
      let tex = TILE_TEXTURES[element];
      // Если текстура ещё не готова, используем процедурную
      if (!tex || !tex.image || !tex.image.width) tex = createProceduralTileTexture(element);
      if (tex) return new THREE.MeshBasicMaterial({ map: tex });
      return new THREE.MeshStandardMaterial({
        color: ELEMENT_BASE_COLORS[element] || 0x64748b,
        metalness: 0.12,
        roughness: 0.6,
        emissive: 0x1a1a1a,
        emissiveIntensity: 0.18
      });
    }

    // Обновить материалы уже созданных тайлов при подгрузке текстуры
    function updateTileMaterialsFor(elementKey) {
      if (!tileMeshes || !tileMeshes.length) return;
      const tex = TILE_TEXTURES[elementKey];
      if (!tex) return;
      for (let r = 0; r < tileMeshes.length; r++) {
        const row = tileMeshes[r]; if (!row) continue;
        for (let c = 0; c < row.length; c++) {
          const tile = row[c]; if (!tile) continue;
          const cell = (gameState && gameState.board && gameState.board[r] && gameState.board[r][c]) ? gameState.board[r][c] : null;
          if (cell && cell.element === elementKey) {
            // освобождаем старый материал и назначаем новый с текстурой
            try { tile.material.dispose && tile.material.dispose(); } catch {}
            const mat = new THREE.MeshBasicMaterial({ map: tex });
            tile.material = mat;
            tile.material.needsUpdate = true;
          }
        }
      }
      // Перерисуем кадр
      try { renderer && renderer.render(scene, camera); } catch {}
    }
    
    function createBoard() {
      try { preloadCardTextures(); } catch {}
      tileMeshes.forEach(row => row.forEach(tile => {
        if (tile) boardGroup.remove(tile);
      }));
      tileFrames.forEach(row => row.forEach(f => { if (f) boardGroup.remove(f); }));
      tileMeshes = [];
      tileFrames = [];
      
      if (!gameState) return;
      
      const tileSize = 6.2; // увеличено
      const tileHeight = 0.35;
      const spacing = 0.2;
      const boardYOffset = 0.0; // опущено ближе к платформе. Важно
      const boardZShift = -3.5; // отодвинуть поле дальше от камеры/руки. Важно
      
      for (let r = 0; r < 3; r++) {
        const row = [];
        const frameRow = [];
        for (let c = 0; c < 3; c++) {
          const cell = gameState.board[r][c];
          
          const geometry = new THREE.BoxGeometry(tileSize, tileHeight, tileSize);
          const material = getTileMaterial(cell.element);
          const tile = new THREE.Mesh(geometry, material);
          
          const x = (c - 1) * (tileSize + spacing);
          const z = (r - 1) * (tileSize + spacing) + boardZShift;
          tile.position.set(x, tileHeight / 2 + boardYOffset, z);
          tile.castShadow = false;
          tile.receiveShadow = true;
          
          tile.userData = { type: 'tile', row: r, col: c, element: cell.element };
          
          boardGroup.add(tile);
          row.push(tile);

          // Рамка владения (толстая, из 4 сегментов)
          const frame = new THREE.Group();
          const borderT = 0.18; // толщина рамки (увеличено)
          const h = 0.018; // высота рамки над тайлом
          const frameMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, depthTest: true, depthWrite: false, opacity: 0.0 });
          const top    = new THREE.Mesh(new THREE.BoxGeometry(tileSize + 0.04, h, borderT), frameMat.clone());
          const bottom = new THREE.Mesh(new THREE.BoxGeometry(tileSize + 0.04, h, borderT), frameMat.clone());
          const left   = new THREE.Mesh(new THREE.BoxGeometry(borderT, h, tileSize + 0.04), frameMat.clone());
          const right  = new THREE.Mesh(new THREE.BoxGeometry(borderT, h, tileSize + 0.04), frameMat.clone());
          top.position.set(x, tileHeight + boardYOffset + h/2 + 0.002, z - (tileSize/2 - borderT/2));
          bottom.position.set(x, tileHeight + boardYOffset + h/2 + 0.002, z + (tileSize/2 - borderT/2));
          left.position.set(x - (tileSize/2 - borderT/2), tileHeight + boardYOffset + h/2 + 0.002, z);
          right.position.set(x + (tileSize/2 - borderT/2), tileHeight + boardYOffset + h/2 + 0.002, z);
          for (const seg of [top, bottom, left, right]) { seg.renderOrder = 600; frame.add(seg); }
          frame.renderOrder = 800; // ниже карт в руке, но выше тайла
          boardGroup.add(frame);
          frameRow.push(frame);
        }
        tileMeshes.push(row);
        tileFrames.push(frameRow);
      }
      try { window.tileMeshes = tileMeshes; window.tileFrames = tileFrames; } catch {}
    }
    
    // Delegator: module cards implementation
    function createCard3D(cardData, isInHand = false, hpOverride = null, atkOverride = null) {
      if (window.__cards && typeof window.__cards.createCard3D === 'function') {
        return window.__cards.createCard3D(cardData, isInHand, hpOverride, atkOverride);
      }
      // Fallback to legacy if module is missing
      return __legacy_createCard3D(cardData, isInHand, hpOverride, atkOverride);
    }

    function __legacy_createCard3D(cardData, isInHand = false, hpOverride = null, atkOverride = null) {
      // disabled legacy body
      return null;
    }

    // Legacy kept only for offline file:// fallback (modules handle normally)
    function __legacy_attachIllustrationPlane(cardMesh, cardData) {
      // disabled legacy body
      return;
    }
    // Delegator: module cards implementation
    function drawCardFace(ctx, cardData, width, height, hpOverride = null, atkOverride = null) {
      if (window.__cards && typeof window.__cards.drawCardFace === 'function') {
        return window.__cards.drawCardFace(ctx, cardData, width, height, hpOverride, atkOverride);
      }
      return __legacy_drawCardFace(ctx, cardData, width, height, hpOverride, atkOverride);
    }

    function __legacy_drawCardFace(ctx, cardData, width, height, hpOverride = null, atkOverride = null) {
      // disabled legacy body
      return;
    }
    

    
    function updateHand() {
      // Во время полёта карты не перерисовываем руку, чтобы не ломать предраскладку
      if (drawAnimationActive) return;
      handCardMeshes.forEach(card => {
        if (card.parent) card.parent.remove(card);
      });
      handCardMeshes = [];
      hoveredHandCard = null;
      
      if (!gameState) return;

      // В онлайне всегда показываем СВОЮ руку, а не руку активного игрока
      const viewerSeat = (typeof window !== 'undefined' && typeof window.MY_SEAT === 'number')
        ? window.MY_SEAT
        : gameState.active;
      let hand = (gameState.players && gameState.players[viewerSeat] && gameState.players[viewerSeat].hand)
        ? gameState.players[viewerSeat].hand.slice()
        : [];
      // В момент анимации добора скрываем N последних карт, чтобы не было дублирования
      try {
        if (viewerSeat === (typeof window !== 'undefined' ? window.MY_SEAT : viewerSeat) && pendingDrawCount > 0) {
          hand = hand.slice(0, Math.max(0, hand.length - pendingDrawCount));
        }
      } catch {}
      // Скрыть один экземпляр ритуального спелла у активного игрока (во время выбора жертвы)
      let indices = [];
      for (let i = 0; i < hand.length; i++) {
        // Скрываем выбранный для ритуала спелл
        if (viewerSeat === gameState.active && typeof pendingRitualSpellHandIndex === 'number' && i === pendingRitualSpellHandIndex) continue;
        // Скрываем карты, которые клиент пометил «спрятать» (например, выбранные для Holy Feast до прихода снапшота)
        if (Array.isArray(PENDING_HIDE_HAND_CARDS) && PENDING_HIDE_HAND_CARDS.includes(i)) continue;
        indices.push(i);
      }
      const handSize = indices.length;
      
      if (handSize === 0) return;
      
      // Параметры для веерного расположения
      const spread = Math.min(4.0, Math.max(2.0, 20 / (handSize + 2)));
      const angleSpread = Math.min(0.3, 1.2 / (handSize + 1));
      const radius = 8.0;  // Разумный радиус для видимости
      const baseY = 6.0;   // Рука над полем, но не слишком высоко
      
      for (let k = 0; k < handSize; k++) {
        const i = indices[k];
        const cardData = hand[i];
        const card = createCard3D(cardData, true);
        
        // Вычисляем позицию для веерного расположения
        const angle = (k - (handSize - 1) / 2) * angleSpread;
        const x = Math.sin(angle) * radius;
        const z = radius + Math.cos(angle) * radius * 0.3 - HAND_Z_OFFSET;
        const y = baseY + Math.sin(angle) * 1.5; // Небольшое изменение по Y для объема
        
        card.position.set(x, y, z);
        
        // Поворот карты для веерного эффекта
        card.rotation.set(
            -0.2 + angle * 0.1,   // Наклон вперед
            angle * 0.5,           // Поворот в сторону
            0                       // Без крена
        );
        
        card.userData.originalPosition.copy(card.position);
        card.userData.originalRotation.copy(card.rotation);
        card.userData.handIndex = i;
        card.userData.cardData = cardData;
        
        card.renderOrder = 2000; // поверх рамок
        cardGroup.add(card);
        handCardMeshes.push(card);
      }
    }

    function computeHandTransform(index, total) {
      const handSize = Math.max(1, total);
      const angleSpread = Math.min(0.3, 1.2 / (handSize + 1));
      const radius = 8.0;
      const baseY = 6.0;
      const angle = (index - (handSize - 1) / 2) * angleSpread;
      const x = Math.sin(angle) * radius;
      const z = radius + Math.cos(angle) * radius * 0.3 - HAND_Z_OFFSET;
      const y = baseY + Math.sin(angle) * 1.5;
      const rot = new THREE.Euler(
        -0.2 + angle * 0.1,
        angle * 0.5,
        0
      );
      const pos = new THREE.Vector3(x, y, z);
      const scale = new THREE.Vector3(0.54, 1, 0.54);
      return { position: pos, rotation: rot, scale };
    }

    function setHandCardHoverVisual(mesh, hovered) {
      if (!mesh) return;
      const materials = [];
      const collect = (obj) => {
        if (!obj) return;
        if (obj.material) {
          if (Array.isArray(obj.material)) materials.push(...obj.material);
          else materials.push(obj.material);
        }
        (obj.children || []).forEach(collect);
      };
      collect(mesh);
      if (hovered) {
        mesh.renderOrder = 10000;
        // ВАЖНО: оставляем depthWrite=true, чтобы карта корректно рисовала свою лицевую сторону над своими же гранями/рубашкой
        materials.forEach(m => { if (m) { m.depthTest = true; m.depthWrite = true; m.needsUpdate = true; } });
        // Поднимем и немного приблизим к камере вдоль направления взгляда
        try {
          if (mesh.userData && mesh.userData.originalPosition) {
            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);
            const towardCamera = camDir.clone().multiplyScalar(-0.7); // шаг к камере
            const target = mesh.userData.originalPosition.clone().add(new THREE.Vector3(0, 0.9, 0)).add(towardCamera);
            gsap.to(mesh.position, { x: target.x, y: target.y, z: target.z, duration: 0.18 });
          }
        } catch {}
        // Поднимем иллюстрационный плейн (если есть) поверх самой карты
        try { (mesh.children || []).forEach(ch => { if (ch && ch.userData && ch.userData.kind === 'illustrationPlane') { ch.renderOrder = mesh.renderOrder + 1; } }); } catch {}
      } else {
        mesh.renderOrder = 2000;
        // Возвращаем стандартные тест/запись глубины
        materials.forEach(m => { if (m) { m.depthTest = true; m.depthWrite = true; m.needsUpdate = true; } });
        try { if (mesh.userData && mesh.userData.originalPosition) { const p = mesh.userData.originalPosition; gsap.to(mesh.position, { x: p.x, y: p.y, z: p.z, duration: 0.18 }); } } catch {}
        try { (mesh.children || []).forEach(ch => { if (ch && ch.userData && ch.userData.kind === 'illustrationPlane') { ch.renderOrder = mesh.renderOrder + 1; } }); } catch {}
      }
    }

    async function animateDrawnCardToHand(cardTpl) {
      try {
        if (!cardTpl) return;
        drawAnimationActive = true; refreshInputLockUI();
        // Создаём временный крупный меш (не относится к руке), и ориентируем как «билборд» к камере
        const big = createCard3D(cardTpl, false);
        // Разместим карту выше и ближе к центру стола, чтобы не пересекалась с рукой
        const T = window.DRAW_CARD_TUNE || {};
        big.position.set(0, (T.posY ?? 10.0), (T.posZ ?? 2.4));
        // Повернуть параллельно камере: фронт карты на камеру, без уголка перспект.
        // Камера смотрит на (0,1.2,0), берем её yaw вокруг Y
        try {
          // Ориентируем карту строго к камере: лицевая нормаль = -направление взгляда камеры,
          // верх карты выровнен с up камерой.
          const camForward = new THREE.Vector3();
          camera.getWorldDirection(camForward); // куда смотрит камера
          const faceNormal = camForward.clone().negate().normalize(); // лицом к камере
          const camUpWorld = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion).normalize();
          let right = new THREE.Vector3().crossVectors(camUpWorld, faceNormal);
          if (right.lengthSq() < 1e-6) right.set(1, 0, 0); else right.normalize();
          const upInPlane = new THREE.Vector3().crossVectors(faceNormal, right).normalize();
          const basis = new THREE.Matrix4().makeBasis(right, faceNormal, upInPlane);
          const q = new THREE.Quaternion().setFromRotationMatrix(basis);
          big.setRotationFromQuaternion(q);
        } catch { big.rotation.set(0, 0, 0); }
        big.scale.set((T.scale ?? 1.7), (T.scale ?? 1.7), (T.scale ?? 1.7));
        big.renderOrder = 9000;
        // Соберём все материалы (включая накладные плейны иллюстрации и оверлей лица),
        // чтобы обеспечить плавное проявление без мгновенного всплытия слоёв
        const mats = Array.isArray(big.material) ? big.material : [big.material];
        const allMaterials = [];
        const collectMaterials = (obj) => {
          if (!obj) return;
          if (obj.material) {
            if (Array.isArray(obj.material)) allMaterials.push(...obj.material);
            else allMaterials.push(obj.material);
          }
          (obj.children || []).forEach(collectMaterials);
        };
        collectMaterials(big);
        allMaterials.forEach(m => { if (m) { m.transparent = true; m.opacity = 0; } });
        cardGroup.add(big);

        // Целевая позиция в руке — вычислим, как будто карта станет последней
        // В момент анимации мы уже спрятали последнюю карту (pendingDrawCount=1),
        // поэтому берём фактический рендеримый размер руки и прибавляем 1.
        const totalVisible = Math.max(0, handCardMeshes.filter(m => m?.userData?.isInHand).length);
        const totalAfter = totalVisible + 1;
        const indexAfter = totalAfter - 1;
        const target = computeHandTransform(indexAfter, totalAfter);

        // Предраскладка: заранее сместим существующие карты руки в положения для totalAfter,
        // чтобы к моменту прилёта новой карты соседи уже стояли на своих местах
        try {
          const preLayoutDuration = 0.6;
          for (let i = 0; i < handCardMeshes.length; i++) {
            const mesh = handCardMeshes[i];
            if (!mesh || !mesh.userData || !mesh.userData.isInHand) continue;
            // Учтём, что new card займёт позицию indexAfter, поэтому старые индексы не сдвигаем чрезмерно
            const t = computeHandTransform(i, totalAfter);
            gsap.to(mesh.position, {
              x: t.position.x,
              y: t.position.y,
              z: t.position.z,
              duration: preLayoutDuration,
              ease: 'power2.inOut'
            });
            gsap.to(mesh.rotation, {
              x: t.rotation.x,
              y: t.rotation.y,
              z: t.rotation.z,
              duration: preLayoutDuration,
              ease: 'power2.inOut'
            });
            // Вернём масштаб к стандартному для руки на случай, если какая-то карта была наведена
            gsap.to(mesh.scale, { x: 0.54, y: 1, z: 0.54, duration: 0.18 });
            // Обновим базовые позиции/углы для корректного ховера после анимации
            try { mesh.userData.originalPosition.copy(t.position); } catch {}
            try { mesh.userData.originalRotation.copy(t.rotation); } catch {}
          }
        } catch {}

        await new Promise(resolve => {
          const tl = gsap.timeline({ onComplete: resolve });
          // Проявление ≤ 1.0с
          tl.to(allMaterials, { opacity: 1, duration: 0.8, ease: 'power2.out' })
            // Полёт в руку ≤ 0.7с, все трансформации синхронно
            .to(big.position, { x: target.position.x, y: target.position.y, z: target.position.z, duration: 0.7, ease: 'power2.inOut' }, 'fly')
            .to(big.rotation, { x: target.rotation.x, y: target.rotation.y, z: target.rotation.z, duration: 0.7, ease: 'power2.inOut' }, 'fly')
            .to(big.scale, { x: target.scale.x, y: target.scale.y, z: target.scale.z, duration: 0.7, ease: 'power2.inOut' }, 'fly');
          // После ориентации к камере применим ручные углы (в градусах)
          try {
            big.rotateX(THREE.MathUtils.degToRad(T.pitchDeg || 0));
            big.rotateY(THREE.MathUtils.degToRad(T.yawDeg || 0));
            big.rotateZ(THREE.MathUtils.degToRad(T.rollDeg || 0));
          } catch {}
        });
        try { cardGroup.remove(big); } catch {}
        drawAnimationActive = false; refreshInputLockUI();
      } catch {}
    }
    
    function updateUnits() {
      unitMeshes.forEach(unit => {
        if (unit.parent) unit.parent.remove(unit);
      });
      unitMeshes = [];
      
      if (!gameState) return;
      
      const tileSize = 6.2;
      const spacing = 0.2;
      const boardZShift = -3.5;
      
      for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 3; c++) {
          const unit = gameState.board[r][c].unit;
          // Обновим рамки владения
          if (tileFrames[r] && tileFrames[r][c]) {
            const frame = tileFrames[r][c];
            const setFrame = (opacity, color) => {
              frame.traverse(child => { if (child.isMesh && child.material) { child.material.opacity = opacity; child.material.color = new THREE.Color(color); } });
            };
            if (unit) {
              // В онлайне: подсветка по владельцу относительно моего места (MY_SEAT)
              // Оффлайн: по владельцу (0 зелёный, 1 красный)
              // Определяем место зрителя: онлайн — MY_SEAT, офлайн — текущий активный
              let viewerSeat = null;
              try {
                if (typeof window !== 'undefined' && typeof window.MY_SEAT === 'number') viewerSeat = window.MY_SEAT;
                else viewerSeat = gameState.active;
              } catch { viewerSeat = gameState.active; }
              const isMine = (unit.owner === viewerSeat);
              const col = isMine ? 0x22c55e : 0xef4444;
              setFrame(0.95, col);
            } else {
              setFrame(0.0, 0x000000);
            }
          }
          if (!unit) continue;
          
          const cardData = CARDS[unit.tplId];
          const stats = effectiveStats(gameState.board[r][c], unit);
          const unitMesh = createCard3D(cardData, false, unit.currentHP, stats.atk);
          
          const x = (c - 1) * (tileSize + spacing);
          const z = (r - 1) * (tileSize + spacing) + boardZShift + 0.0; // Важно - смещение карт на поле?
          const yBase = tileFrames[r] && tileFrames[r][c] ? (tileFrames[r][c].children?.[0]?.position?.y || (0.5 + 0.5)) : (0.5 + 0.5);
          unitMesh.position.set(x, yBase + 0.28, z);
          
          const facingAngle = facingDeg[unit.facing] * Math.PI / 180;
          unitMesh.rotation.y = facingAngle;
          
          const ownerColor = unit.owner === 0 ? 0x22c55e : 0xef4444;
          const glowMaterial = new THREE.MeshStandardMaterial({
            color: ownerColor,
            emissive: ownerColor,
            emissiveIntensity: 0.2,
            transparent: true,
            opacity: 0.3
          });
          
          const glowGeometry = new THREE.BoxGeometry(1.8, 0.02, 2.4);
          const glow = new THREE.Mesh(glowGeometry, glowMaterial);
          glow.position.set(0, -0.05, 0);
          unitMesh.add(glow);
          
          unitMesh.userData = {
            type: 'unit',
            row: r,
            col: c,
            unitData: unit,
            cardData: cardData
          };
          // Убрали дополнительный HP-оверлей, так как цифра HP рисуется на самой карте
          
          cardGroup.add(unitMesh);
          unitMeshes.push(unitMesh);
        }
      }
    }

    // Визуализировать изменения между предыдущим и новым состоянием (для наблюдателя/оппонента)
    function playDeltaAnimations(prevState, nextState) {
      try {
        if (!prevState || !nextState) return;
        
        // Для активного игрока не показываем числа HP из playDeltaAnimations - они идут из локальных анимаций
        const isActivePlayer = (typeof MY_SEAT === 'number' && typeof gameState !== 'undefined' && gameState && typeof gameState.active === 'number' && MY_SEAT === gameState.active);
        
        const prevB = prevState.board || [];
        const nextB = nextState.board || [];
        
        // Обрабатываем появление/исчезновение юнитов для всех игроков
        for (let r = 0; r < 3; r++) {
          for (let c = 0; c < 3; c++) {
            const pu = (prevB[r] && prevB[r][c] && prevB[r][c].unit) ? prevB[r][c].unit : null;
            const nu = (nextB[r] && nextB[r][c] && nextB[r][c].unit) ? nextB[r][c].unit : null;
            if (pu && !nu) {
              // Юнит исчез — проигрываем шейдерное «исчезновение» фантома и орб маны
              try {
                const tile = tileMeshes?.[r]?.[c]; if (!tile) continue;
                const ghost = createCard3D(CARDS[pu.tplId], false);
                ghost.position.copy(tile.position).add(new THREE.Vector3(0, 0.28, 0));
                try { effectsGroup.add(ghost); } catch { cardGroup.add(ghost); }
                dissolveAndAsh(ghost, new THREE.Vector3(0,0,0.6), 0.9);
                const p = tile.position.clone().add(new THREE.Vector3(0, 1.2, 0));
                animateManaGainFromWorld(p, pu.owner, true);
                try { if (!NET_ACTIVE && gameState && gameState.players && typeof pu.owner === 'number') { gameState.players[pu.owner].mana = capMana((gameState.players[pu.owner].mana||0) + 1); updateUI(); } } catch {}
              } catch {}
            } else if (!pu && nu) {
              // Юнит появился — лёгкий «поп» масштаба
              try {
                const tMesh = unitMeshes.find(m => m.userData.row === r && m.userData.col === c);
                if (tMesh) {
                  const s = tMesh.scale.clone();
                  tMesh.scale.set(s.x * 0.7, s.y * 0.7, s.z * 0.7);
                  gsap.to(tMesh.scale, { x: s.x, y: s.y, z: s.z, duration: 0.28, ease: 'power2.out' });
                }
              } catch {}
            }
          }
        }
        
        // Для активного игрока не показываем числа HP - они есть в локальных анимациях
        if (isActivePlayer) {
          return;
        }

        // Для неактивного игрока показываем числа HP с последовательными задержками
        const hpChanges = [];
        for (let r = 0; r < 3; r++) {
          for (let c = 0; c < 3; c++) {
            const pu = (prevB[r] && prevB[r][c] && prevB[r][c].unit) ? prevB[r][c].unit : null;
            const nu = (nextB[r] && nextB[r][c] && nextB[r][c].unit) ? nextB[r][c].unit : null;
            if (pu && nu) {
              const pHP = (typeof pu.currentHP === 'number') ? pu.currentHP : pu.hp;
              const nHP = (typeof nu.currentHP === 'number') ? nu.currentHP : nu.hp;
              const delta = (typeof pHP === 'number' && typeof nHP === 'number') ? (nHP - pHP) : 0;
              if (delta !== 0) {
                hpChanges.push({ r, c, delta });
              }
            }
          }
        }

        // Показываем HP изменения последовательно
        // Первая половина изменений - через 500мс (после первой атаки)
        // Вторая половина - через 1300мс (после контратаки)
        // Filter out recent remote damage already shown during battleAnim/retaliation
        const __now = Date.now();
        const pendingHpChanges = (typeof window !== 'undefined' && window.RECENT_REMOTE_DAMAGE && window.RECENT_REMOTE_DAMAGE.size)
          ? hpChanges.filter(change => {
              try {
                const key = `${change.r},${change.c}`;
                const rec = window.RECENT_REMOTE_DAMAGE.get(key);
                return !(rec && rec.delta === change.delta && (__now - rec.ts) < 2000);
              } catch { return true; }
            })
          : hpChanges;

        // Schedule HP popups in a cancelable way to sync with remote battle shakes
        try {
          const halfCount = Math.ceil(pendingHpChanges.length / 2);
          for (let i = 0; i < halfCount && i < pendingHpChanges.length; i++) {
            const change = pendingHpChanges[i];
            scheduleHpPopup(change.r, change.c, change.delta, 800);
          }
          if (pendingHpChanges.length > halfCount) {
            for (let i = halfCount; i < pendingHpChanges.length; i++) {
              const change = pendingHpChanges[i];
              scheduleHpPopup(change.r, change.c, change.delta, 1600);
            }
          }
          // Prevent legacy fallback from double-displaying numbers
          return;
        } catch {}

        const halfCount = Math.ceil(pendingHpChanges.length / 2);
        
        // Первая волна чисел (урон по атакованным целям) <-- важно
        setTimeout(() => {
          for (let i = 0; i < halfCount && i < pendingHpChanges.length; i++) {
            const change = pendingHpChanges[i];
            try {
              const tMesh = unitMeshes.find(m => m.userData.row === change.r && m.userData.col === change.c);
              if (tMesh) {
                const color = change.delta > 0 ? '#22c55e' : '#ef4444';
                spawnDamageText(tMesh, `${change.delta > 0 ? '+' : ''}${change.delta}`, color);
              }
            } catch {}
          }
        }, 500);
        
        // Вторая волна чисел (урон по атакующему от контратаки) <-- важно
        if (pendingHpChanges.length > halfCount) {
          setTimeout(() => {
            for (let i = halfCount; i < pendingHpChanges.length; i++) {
              const change = pendingHpChanges[i];
              try {
                const tMesh = unitMeshes.find(m => m.userData.row === change.r && m.userData.col === change.c);
                if (tMesh) {
                  const color = change.delta > 0 ? '#22c55e' : '#ef4444';
                  spawnDamageText(tMesh, `${change.delta > 0 ? '+' : ''}${change.delta}`, color);
                }
              } catch {}
            }
          }, 1300);
        }
      } catch {}
    }
    // attachHpOverlay удалён, т.к. HP теперь перерисовывается на самой карте
    
    function updateUI() {
      if (!gameState) return;      
      // Защита от обновлений во время критических анимаций
      if (splashActive && typeof window !== 'undefined' && window.__ui && window.__ui.banner) {
        const bannerState = window.__ui.banner.getState();
        if (bannerState._splashActive) {
          // Отложим обновление UI до завершения заставки
          setTimeout(() => updateUI(), 100);
          return;
        }
      }
      
      document.getElementById('turn-info').textContent = `Ход: ${gameState.turn}`;
      // Обновить числовой текст таймера в круглой кнопке и высоту заполнения
      try {
        const btn = document.getElementById('end-turn-btn');
        if (btn) {
          const fill = btn.querySelector('.time-fill');
          const txt = btn.querySelector('.sec-text');
          if (typeof window.__turnTimerSeconds === 'number') {
            const s = Math.max(0, Math.min(100, window.__turnTimerSeconds));
            if (txt) txt.textContent = `${s}`;
            // Инверсия: опускаем верхнюю границу жёлтой заливки сверху вниз
            const percent = s / 100; // 1 -> top:0%, 0 -> top:100%
            if (fill) fill.style.top = `${Math.round((1 - percent) * 100)}%`;
          }
        }
      } catch {}
      // Выделение активного игрока - с гарантией обновления
      try {
        const leftSide = document.getElementById('left-side');
        const rightSide = document.getElementById('right-side');
        const t0 = document.getElementById('player-title-0');
        const t1 = document.getElementById('player-title-1');
        if (leftSide && rightSide && t0 && t1) {
          // Сначала убираем все подсветки
          leftSide.querySelectorAll('.overlay-panel').forEach(el => el.classList.remove('active-player-panel'));
          rightSide.querySelectorAll('.overlay-panel').forEach(el => el.classList.remove('active-player-panel'));
          t0.classList.remove('title-pulse');
          t1.classList.remove('title-pulse');
          
          // Затем добавляем подсветку активному игроку
          if (gameState.active === 0) {
            // Force reflow для гарантии применения изменений
            requestAnimationFrame(() => {
              leftSide.querySelectorAll('.overlay-panel').forEach(el => el.classList.add('active-player-panel'));
              t0.classList.add('title-pulse');
            });
          } else {
            requestAnimationFrame(() => {
              rightSide.querySelectorAll('.overlay-panel').forEach(el => el.classList.add('active-player-panel'));
              t1.classList.add('title-pulse');
            });
          }
        }
      } catch {}
      
      // Обновляем две панели маны (для обоих игроков) - ТОЛЬКО через модуль
      try { 
        if (window.__ui && window.__ui.mana && typeof window.__ui.mana.renderBars === 'function') { 
          window.__ui.mana.renderBars(gameState); 
        } else { 
          console.warn('Mana module not available, skipping mana UI update');
        } 
      } catch (e) {
        console.error('Error updating mana UI:', e);
      }

      const controlA = countControlled(gameState, 0);
      const controlB = countControlled(gameState, 1);
      const ci0 = document.getElementById('control-info-0'); if (ci0) ci0.textContent = `Контроль: ${controlA}`;
      const ci1 = document.getElementById('control-info-1'); if (ci1) ci1.textContent = `Контроль: ${controlB}`;
      
      if (controlA >= 5) {
        showNotification('Player 1 wins!', 'success');
        gameState.winner = 0;
      } else if (controlB >= 5) {
        showNotification('Player 2 wins!', 'success');
        gameState.winner = 1;
      }
    }
    
    function showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.className = `overlay-panel p-4 mb-2 ${type === 'success' ? 'bg-green-600' : type === 'error' ? 'bg-red-600' : 'bg-blue-600'}`;
      notification.textContent = message;
      
      const container = document.getElementById('notifications');
      container.appendChild(notification);
      
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 3000);
    }
    
    function addLog(message) {
      logEntries.unshift(`• ${message}`);
      if (logEntries.length > 100) logEntries.pop();
      
      const logContent = document.getElementById('log-content');
      if (logContent) {
        logContent.innerHTML = logEntries.map(entry => `<div>${entry}</div>`).join('');
      }
    }
    
    // Взаимодействие
    function onMouseMove(event) {
      if (isInputLocked()) return;
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      
      if (draggedCard) {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(tileMeshes.flat());
        
        if (hoveredTile) {
          hoveredTile.material.emissiveIntensity = 0.1;
        }
        
        if (intersects.length > 0) {
          hoveredTile = intersects[0].object;
          hoveredTile.material.emissiveIntensity = 0.3;
          
          const targetPos = hoveredTile.position.clone();
          targetPos.y = 2;
          gsap.to(draggedCard.position, {
            x: targetPos.x,
            y: targetPos.y,
            z: targetPos.z,
            duration: 0.1
          });
        } else {
          hoveredTile = null;
        }
      } else {
        // Ховер по картам в руке: увеличиваем наведённую, уменьшаем предыдущую, поднимаем над стеком
        raycaster.setFromCamera(mouse, camera);
        const handHits = drawAnimationActive ? [] : raycaster.intersectObjects(handCardMeshes, true);
        const newHover = handHits.length > 0 ? (handHits[0].object.userData?.isInHand ? handHits[0].object : handHits[0].object.parent) : null;
        if (hoveredHandCard && hoveredHandCard !== newHover) {
          gsap.to(hoveredHandCard.scale, { x: 0.54, y: 1, z: 0.54, duration: 0.18 });
          setHandCardHoverVisual(hoveredHandCard, false);
          hoveredHandCard = null;
        }
        if (newHover && newHover.userData && newHover.userData.isInHand) {
          hoveredHandCard = newHover;
          gsap.to(newHover.scale, { x: 0.675, y: 1, z: 0.675, duration: 0.18 });
          setHandCardHoverVisual(newHover, true);
        }
      }
      // Подсветка потенциальных целей при открытой панели действий юнита
      if (selectedUnit) {
        const r = selectedUnit.userData.row; const c = selectedUnit.userData.col;
        const hits = computeHits(gameState, r, c);
        // убираем прошлую подсветку
        unitMeshes.forEach(m => { if (m.material && m.material[2]) { } });
        // подсветим цели небольшим всплеском по Y
        for (const h of hits) {
          const m = unitMeshes.find(m => m.userData.row === h.r && m.userData.col === h.c);
          if (m) gsap.to(m.position, { y: 0.7, yoyo: true, repeat: 1, duration: 0.2 });
        }
      }

      // Tooltip для колод/кладбищ
      {
        raycaster.setFromCamera(mouse, camera);
        const metaHits = raycaster.intersectObjects([...deckMeshes, ...graveyardMeshes], true);
        const tip = document.getElementById('hover-tooltip');
        if (metaHits.length > 0) {
          const obj = metaHits[0].object;
          const data = obj.userData || obj.parent?.userData || {};
          if (data && data.metaType) {
            const p = data.player ?? 0;
            hoveredMeta = { metaType: data.metaType, player: p };
            if (tip) {
              const deckCount = gameState?.players?.[p]?.deck?.length ?? 0;
              const gyCount = gameState?.players?.[p]?.graveyard?.length ?? 0;
              tip.textContent = data.metaType === 'deck' ? `Deck - Player ${p===0? '1':'2'}: ${deckCount}` : `Graveyard - Player ${p===0? '1':'2'}: ${gyCount}`;
              tip.style.left = (event.clientX + 16) + 'px';
              tip.style.top = (event.clientY + 16) + 'px';
              tip.classList.remove('hidden');
            }
          }
        } else {
          hoveredMeta = null;
          const tipEl = document.getElementById('hover-tooltip');
          if (tipEl) tipEl.classList.add('hidden');
        }
      }
    }
    
    function onMouseDown(event) {
      if (!gameState || gameState.winner !== null) return;
      if (isInputLocked()) return;
      
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      
      const handIntersects = raycaster.intersectObjects(handCardMeshes, true);
      if (handIntersects.length > 0) {
        const hitObj = handIntersects[0].object;
        const card = hitObj.userData?.isInHand ? hitObj : hitObj.parent;
        const cardData = card.userData.cardData;
        // Если ждём ритуального дискарда — перехват клика по руке
        if (pendingDiscardSelection && cardData && cardData.type === (pendingDiscardSelection.requiredType || cardData.type)) {
          console.log('[HF:click] Clicked on creature card for Holy Feast', {
            cardType: cardData.type,
            requiredType: pendingDiscardSelection.requiredType,
            handIdx: card.userData.handIndex,
            NET_ACTIVE
          });
          const owner = gameState.players[gameState.active];
          const handIdx = card.userData.handIndex;
          try { 
            console.log('[HF:click] Calling onPicked with handIdx:', handIdx);
            pendingDiscardSelection.onPicked(handIdx); 
          } catch (e) {
            console.error('[HF:click] Error in onPicked:', e);
          }
          pendingDiscardSelection = null;
          console.log('[HF:click] Reset pendingDiscardSelection to null');
          return;
        }
        
        if (cardData.type === 'UNIT') {
          startCardDrag(card);
        } else if (cardData.type === 'SPELL') {
          // Новый принцип: спеллы разыгрываются перетаскиванием, а не кликом
          startCardDrag(card);
        }
        return;
      }
      
      const unitIntersects = raycaster.intersectObjects(unitMeshes, true);
      if (unitIntersects.length > 0) {
        const hitObj = unitIntersects[0].object;
        let unit = hitObj;
        while (unit && (!unit.userData || unit.userData.type !== 'unit')) unit = unit.parent;
        if (!unit) return;
        // если в режиме магической атаки
        if (magicFrom) {
          performMagicAttack(magicFrom, unit);
          magicFrom = null;
          return;
        }
        if (selectedCard && selectedCard.userData.cardData.type === 'SPELL') {
          castSpellOnUnit(selectedCard, unit);
        } else if (unit.userData.unitData.owner === gameState.active) {
          showUnitActionPanel(unit);
        }
        return;
      }
      
      if (selectedCard) {
        resetCardSelection();
      }
      // Отмена ритуального дискарда кликом по полю
      if (pendingDiscardSelection) {
        try { hidePrompt(); } catch {}
        pendingDiscardSelection = null;
        // Вернём визуально карту спелла, если она была перетянута
        if (draggedCard && draggedCard.userData && draggedCard.userData.cardData && draggedCard.userData.cardData.type === 'SPELL') {
          returnCardToHand(draggedCard);
        }
      }
    }
    
    function onMouseUp(event) {
      if (isInputLocked()) { endCardDrag(); return; }
      if (draggedCard) {
        const cardData = draggedCard.userData.cardData;
        // Определим, навели ли на юнита
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const unitIntersects = raycaster.intersectObjects(unitMeshes, true);
        let unitMesh = null;
        if (unitIntersects.length > 0) {
          let u = unitIntersects[0].object;
          while (u && (!u.userData || u.userData.type !== 'unit')) u = u.parent;
          unitMesh = u;
        }
        if (cardData.type === 'SPELL') {
          // Перетаскивание спелла: каст по цели (юнит/клетка)
          try { castSpellByDrag(draggedCard, unitMesh, hoveredTile); } catch {}
          // Если логика каста создала бордовый меш/сожгла карту (spellDragHandled=true) — не возвращаем; иначе вернуть в руку
          if (!spellDragHandled) {
            returnCardToHand(draggedCard);
          }
          spellDragHandled = false;
        } else if (cardData.type === 'UNIT') {
          // Перетаскивание существа: прежняя логика размещения на пустую клетку
          if (hoveredTile) {
            const row = hoveredTile.userData.row;
            const col = hoveredTile.userData.col;
            if (gameState.board[row][col].unit) {
              showNotification('Cell is already occupied!', 'error');
              returnCardToHand(draggedCard);
            } else {
              pendingPlacement = {
                card: draggedCard,
                row: row,
                col: col,
                handIndex: draggedCard.userData.handIndex
              };
              showOrientationPanel();
            }
          } else {
            returnCardToHand(draggedCard);
          }
        }
        endCardDrag();
        return;
      }
      endCardDrag();
    }
    
    function startCardDrag(card) {
      draggedCard = card;
      // если карта была увеличена ховером — вернём к стандартному масштабу руки
      if (hoveredHandCard) {
        gsap.to(hoveredHandCard.scale, { x: 0.54, y: 1, z: 0.54, duration: 0.1 });
        setHandCardHoverVisual(hoveredHandCard, false);
        hoveredHandCard = null;
      }
      
      gsap.to(card.position, {
        y: card.position.y + 1,
        duration: 0.2,
        ease: "power2.out"
      });
      
      gsap.to(card.rotation, {
        x: 0,
        z: 0,
        duration: 0.2
      });
      
      gsap.to(card.scale, {
        x: 1.1,
        y: 1.1,
        z: 1.1,
        duration: 0.2
      });
    }
    
    function endCardDrag() {
      if (hoveredTile) {
        hoveredTile.material.emissiveIntensity = 0.1;
        hoveredTile = null;
      }
      draggedCard = null;
    }
    
    function returnCardToHand(card) {
      gsap.to(card.position, {
        x: card.userData.originalPosition.x,
        y: card.userData.originalPosition.y,
        z: card.userData.originalPosition.z,
        duration: 0.3,
        ease: "power2.inOut"
      });
      
      gsap.to(card.rotation, {
        x: card.userData.originalRotation.x,
        y: card.userData.originalRotation.y,
        z: card.userData.originalRotation.z,
        duration: 0.3
      });
      
      gsap.to(card.scale, {
        x: card.userData && card.userData.isInHand ? 0.54 : 1,
        y: 1,
        z: card.userData && card.userData.isInHand ? 0.54 : 1,
        duration: 0.3
      });
    }
    

    
    function resetCardSelection() {
      if (selectedCard) {
        returnCardToHand(selectedCard);
        selectedCard.material[2].emissive = new THREE.Color(0x000000);
        selectedCard.material[2].emissiveIntensity = 0;
        selectedCard = null;
      }
    }
    
    function showOrientationPanel() {
      document.getElementById('orientation-panel').classList.remove('hidden');
    }
    
    function hideOrientationPanel() {
      document.getElementById('orientation-panel').classList.add('hidden');
      pendingPlacement = null;
    }
    
    function showUnitActionPanel(unitMesh) {
      selectedUnit = unitMesh;
      const unitData = unitMesh.userData.unitData;
      const cardData = unitMesh.userData.cardData;
      
      document.getElementById('unit-info').textContent = 
        `${cardData.name} (${unitMesh.userData.row + 1},${unitMesh.userData.col + 1})`;
      
      const alreadyAttacked = unitData.lastAttackTurn === gameState.turn;
      const attackBtn = document.getElementById('attack-btn');
      attackBtn.disabled = alreadyAttacked;
      const cost = attackCost(cardData);
      attackBtn.textContent = alreadyAttacked ? 'Already attacked' : `Attack (−${cost})`;
      // Ротация: платное действие, 1 раз за ход
      const rotateCost = attackCost(cardData);
      const alreadyRotated = unitData.lastRotateTurn === gameState.turn;
      const rCw = document.getElementById('rotate-cw-btn');
      const rCcw = document.getElementById('rotate-ccw-btn');
      if (rCw && rCcw) {
        rCw.disabled = !!alreadyRotated;
        rCcw.disabled = !!alreadyRotated;
        rCw.textContent = alreadyRotated ? 'Already rotated' : `Rotate ↻ (−${rotateCost})`;
        rCcw.textContent = alreadyRotated ? 'Already rotated' : `Rotate ↺ (−${rotateCost})`;
      }
      // Подсветка потенциальных целей в панели действий
      const hits = computeHits(gameState, selectedUnit.userData.row, selectedUnit.userData.col);
      for (const h of hits) {
        const m = unitMeshes.find(m => m.userData.row === h.r && m.userData.col === h.c);
        if (!m) continue;
        const ringGeom = new THREE.RingGeometry(0.6, 0.8, 24);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0xf97316, transparent:true, opacity:0.7, side:THREE.DoubleSide });
        const ring = new THREE.Mesh(ringGeom, ringMat);
        ring.rotation.x = -Math.PI/2;
        ring.position.copy(m.position).add(new THREE.Vector3(0, -0.45, 0));
        effectsGroup.add(ring);
        gsap.to(ring.material, { opacity: 0, duration: 0.8, onComplete: ()=> effectsGroup.remove(ring) });
      }
      
      document.getElementById('unit-action-panel').classList.remove('hidden');
    }
    
    function hideUnitActionPanel() {
      document.getElementById('unit-action-panel').classList.add('hidden');
      selectedUnit = null;
    }
    
    async function initGame() {
      gameState = startGame(STARTER_FIRESET, STARTER_FIRESET);
      try { window.gameState = gameState; } catch {}
      
      // Сразу строим сцену и мета-объекты, без задержки появления
      createBoard();
      createMetaObjects();
      updateUnits();
      updateHand();
      updateUI();
      // Заставка хода при старте игры с резервом (ускорена)
      try { 
        if (window.__ui && window.__ui.banner) {
          const b = window.__ui.banner; const t = gameState?.turn;
          const fn = (typeof b.ensureTurnSplashVisible === 'function') ? b.ensureTurnSplashVisible : b.forceTurnSplashWithRetry;
          await fn.call(b, 2, t);
        } else {
          await forceTurnSplashWithRetry(2, gameState?.turn);
        }
      } catch {}
      // Запуск таймера на первом ходу
      try { if (window.__turnTimerId) clearInterval(window.__turnTimerId); } catch {}
      window.__turnTimerSeconds = 100;
      (function syncBtn(){ try {
        const btn = document.getElementById('end-turn-btn');
        if (btn) {
          const fill = btn.querySelector('.time-fill');
          const txt = btn.querySelector('.sec-text');
          if (txt) txt.textContent = `${window.__turnTimerSeconds}`;
          if (fill) fill.style.top = `0%`;
        }
      } catch {} })();
      try {
        if (window.__ui && window.__ui.turnTimer) {
          const tt = window.__ui.turnTimer.attach('end-turn-btn');
          const online = (typeof NET_ON === 'function') ? NET_ON() : !!(typeof NET_ACTIVE !== 'undefined' && NET_ACTIVE);
          if (online) { tt.stop(); } else { tt.reset(100).start(); }
        }
      } catch {}
      
      addLog('The game has begun! Player 1 goes first.');
      addLog('Drag units to the field, use spells by clicking.');
    }
    
    async function endTurn() {
      if (!gameState || gameState.winner !== null) return;
      if (isInputLocked()) return;
      // Онлайн-гейт: не позволяем завершить ход, если сейчас не ваш ход
      try {
        if (typeof window !== 'undefined' && typeof window.MY_SEAT === 'number') {
          if (gameState.active !== window.MY_SEAT) { showNotification('Opponent\'s turn', 'error'); return; }
        }
      } catch {}
      
      // Защита от преждевременного завершения хода во время анимаций
      if (typeof isInputLocked === 'function' ? isInputLocked() : (manaGainActive || drawAnimationActive || splashActive)) {
        showNotification('Wait for animations to complete', 'warning');
        return;
      }
      
      __endTurnInProgress = true;
      // Сброс и запуск таймера хода на 100 секунд
      try { if (window.__turnTimerId) clearInterval(window.__turnTimerId); } catch {}
      window.__turnTimerSeconds = 100;
      (function syncBtn(){ try {
        const btn = document.getElementById('end-turn-btn');
        if (btn) {
          const fill = btn.querySelector('.time-fill');
          const txt = btn.querySelector('.sec-text');
          if (txt) txt.textContent = `${window.__turnTimerSeconds}`;
          if (fill) fill.style.top = `0%`;
        }
      } catch {} })();
      window.__turnTimerId = setInterval(() => {
        if (typeof window.__turnTimerSeconds !== 'number') window.__turnTimerSeconds = 100;
        if (window.__turnTimerSeconds > 0) window.__turnTimerSeconds -= 1;
        try {
          const btn = document.getElementById('end-turn-btn');
          if (btn) {
            const fill = btn.querySelector('.time-fill');
            const txt = btn.querySelector('.sec-text');
            const s = Math.max(0, Math.min(100, window.__turnTimerSeconds));
            if (txt) txt.textContent = `${s}`;
            const percent = s / 100; // 1 -> top:0%, 0 -> top:100%
            if (fill) fill.style.top = `${Math.round((1 - percent) * 100)}%`;
            // Пульсация рамки в последние 10 секунд
            if (s <= 10) { btn.classList.add('urgent'); } else { btn.classList.remove('urgent'); }
          }
        } catch {}
      }, 1000);
      try { if (window.__turnTimerId) { clearInterval(window.__turnTimerId); window.__turnTimerId = null; } } catch {}
      try {
        if (window.__ui && window.__ui.turnTimer) {
          const tt = window.__ui.turnTimer.attach('end-turn-btn');
          const online = (typeof NET_ON === 'function') ? NET_ON() : !!(typeof NET_ACTIVE !== 'undefined' && NET_ACTIVE);
          if (online) { tt.stop(); } else { tt.reset(100).start(); }
        }
      } catch {}

      // Online: delegate authoritative turn advance to the server
      try {
        const online = (typeof NET_ON === 'function') ? NET_ON() : !!(typeof NET_ACTIVE !== 'undefined' && NET_ACTIVE);
        if (online) {
          try { (window.socket || socket).emit('endTurn'); } catch {}
          // Keep input locked until server pushes new state/turnSwitched
          refreshInputLockUI();
          return;
        }
      } catch {}
      
      const controlledCells = countControlled(gameState, gameState.active);
      if (controlledCells >= 5) {
        gameState.winner = gameState.active;
        showNotification(`${gameState.players[gameState.active].name} побеждает!`, 'success');
        return;
      }
      
      // Очистить временные бафы, действующие «до конца хода кастера»
      try {
        for (let rr = 0; rr < 3; rr++) for (let cc = 0; cc < 3; cc++) {
          const u = gameState.board[rr][cc].unit; if (!u) continue;
          if (typeof u.tempAtkBuff === 'number' && u.tempBuffOwner === gameState.active) {
            delete u.tempAtkBuff; delete u.tempBuffOwner;
          }
        }
      } catch {}
      gameState.active = gameState.active === 0 ? 1 : 0;
      gameState.turn += 1;
      
      const player = gameState.players[gameState.active];
      const before = player.mana;
      const manaAfter = capMana(before + 2);
      // Карта для анимации: извлекаем
      const drawnTpl = drawOneNoAdd(gameState, gameState.active);
      
      // ВАЖНО: НЕ применяем ману к gameState до анимации - это предотвратит появление орбов до вспышки
      // Заблокировать преждевременное появление новых орбов до анимации вспышки
      try { 
        if (!PENDING_MANA_ANIM && !manaGainActive) {
          PENDING_MANA_ANIM = window.PENDING_MANA_ANIM = { ownerIndex: gameState.active, startIdx: Math.max(0, Math.min(9, before)), endIdx: Math.max(-1, Math.min(9, manaAfter - 1)) }; 
        }
      } catch {}
      // Clamp UI to beforeMana until animation completes
      try { if (typeof window !== 'undefined' && window.gameState && window.gameState.players && window.gameState.players[gameState.active]) { window.gameState.players[gameState.active]._beforeMana = before; } } catch {}
      let shouldAnimateDraw = false;
      try {
        const amIActiveNow = (typeof window !== 'undefined' && typeof window.MY_SEAT === 'number')
          ? (window.MY_SEAT === gameState.active)
          : true;
        shouldAnimateDraw = !!(amIActiveNow && drawnTpl);
        if (!shouldAnimateDraw && drawnTpl) {
          // Если это не наш клиент — добавим карту сразу (без анимации)
          try { gameState.players[gameState.active].hand.push(drawnTpl); } catch {}
        }
      } catch {}
      updateHand();
      // Offline: locally apply state, online path returned earlier
      try { schedulePush('endTurn-apply', { force: true }); } catch {}
      
      resetCardSelection();
      
      updateHand();
      updateUnits();
      // updateUI выполнится вместе с анимацией маны (после заставки)
      // Показ заставки хода: строго блокирующе (визуальная последовательность)
      try { await forceTurnSplashWithRetry(2, gameState?.turn); } catch {}
      // Перезапустить таймер хода на 100 сек после заставки (анимация таймера локально у обоих)
      try { if (window.__turnTimerId) clearInterval(window.__turnTimerId); } catch {}
      window.__turnTimerSeconds = 100;
      (function syncBtn(){ try {
        const btn = document.getElementById('end-turn-btn');
        if (btn) {
          const fill = btn.querySelector('.time-fill');
          const txt = btn.querySelector('.sec-text');
          if (txt) txt.textContent = `${window.__turnTimerSeconds}`;
          if (fill) fill.style.top = `0%`;
        }
      } catch {} })();
      window.__turnTimerId = setInterval(() => {
        if (typeof window.__turnTimerSeconds !== 'number') window.__turnTimerSeconds = 100;
        if (window.__turnTimerSeconds > 0) window.__turnTimerSeconds -= 1;
        try {
          const btn = document.getElementById('end-turn-btn');
          if (btn) {
            const fill = btn.querySelector('.time-fill');
            const txt = btn.querySelector('.sec-text');
            const s = Math.max(0, Math.min(100, window.__turnTimerSeconds));
            if (txt) txt.textContent = `${s}`;
            const percent = s / 100;
            if (fill) fill.style.top = `${Math.round((1 - percent) * 100)}%`;
            if (s <= 10) { btn.classList.add('urgent'); } else { btn.classList.remove('urgent'); }
          }
        } catch {}
      }, 1000);
      // Эффектная анимация маны: показываем у обоих игроков, но для активного — анимируем его панель
      try { if (window.__turnTimerId) { clearInterval(window.__turnTimerId); window.__turnTimerId = null; } } catch {}
      try {
        if (window.__ui && window.__ui.turnTimer) {
          const tt = window.__ui.turnTimer.attach('end-turn-btn');
          const online = (typeof NET_ON === 'function') ? NET_ON() : !!(typeof NET_ACTIVE !== 'undefined' && NET_ACTIVE);
          if (online) { tt.stop(); } else { tt.reset(100).start(); }
        }
      } catch {}
      try { 
        // Используем модульную функцию с интегрированной анимацией блесток
        if (window.__ui && window.__ui.mana && typeof window.__ui.mana.animateTurnManaGain === 'function') {
          await window.__ui.mana.animateTurnManaGain(gameState.active, before, manaAfter, 1500);
        } else {
          console.warn('Module mana animation not available, skipping');
        }
        // Применяем ману ПОСЛЕ анимации вспышки
        player.mana = manaAfter;
      } catch {}
      // Минимальная задержка (<0.1с) перед началом проявления большой карты
      await sleep(80);
      // ВИЗУАЛ: локально проигрываем анимации добора ТОЛЬКО если это наш клиент
      updateUI();
      try {
        if (shouldAnimateDraw && drawnTpl) {
          // Скрываем «задержанную» карту из руки, пока идёт полёт
          pendingDrawCount = 1; updateHand();
          refreshInputLockUI();
          await animateDrawnCardToHand(drawnTpl);
          // После полёта добавляем карту в руку и показываем её
          try { gameState.players[gameState.active].hand.push(drawnTpl); } catch {}
          pendingDrawCount = 0; updateHand();
        }
      } catch { pendingDrawCount = 0; }
      
      addLog(`Ход ${gameState.turn}. ${player.name} получает +2 маны и добирает карту.`);
      
      // Гарантированная разблокировка ввода
      __endTurnInProgress = false;
      manaGainActive = false;
      refreshInputLockUI();
    }
    function placeUnitWithDirection(direction) {
      if (!pendingPlacement) return;
      
      const { card, row, col, handIndex } = pendingPlacement;
      const cardData = card.userData.cardData;
      const player = gameState.players[gameState.active];
      
      if (cardData.cost > player.mana) {
        showNotification('Insufficient mana!', 'error');
        returnCardToHand(card);
        hideOrientationPanel();
        return;
      }
      
      const unit = {
        uid: uid(),
        owner: gameState.active,
        tplId: cardData.id,
        currentHP: cardData.hp,
        facing: direction
      };
      
      gameState.board[row][col].unit = unit;
      
      player.mana -= cardData.cost;
      player.discard.push(cardData);
      player.hand.splice(handIndex, 1);
      
      const cellElement = gameState.board[row][col].element;
      const buff = computeCellBuff(cellElement, cardData.element);
      if (buff.hp !== 0) {
        const before = unit.currentHP;
        unit.currentHP = Math.max(0, unit.currentHP + buff.hp);
        if (buff.hp > 0) {
          addLog(`Элемент усиливает ${cardData.name}: HP ${before}→${unit.currentHP}`);
        } else {
          addLog(`Элемент ослабляет ${cardData.name}: HP ${before}→${unit.currentHP}`);
        }
      }
      
      if (unit.currentHP <= 0) {
        addLog(`${cardData.name} погибает от неблагоприятной стихии!`);
        const owner = unit.owner;
        // анимация возврата маны + учёт кладбища
        try { gameState.players[owner].graveyard.push(CARDS[unit.tplId]); } catch {}
        const pos = tileMeshes[row][col].position.clone().add(new THREE.Vector3(0, 1.2, 0));
        animateManaGainFromWorld(pos, owner);
        gameState.board[row][col].unit = null;
      }
      
      const targetPos = tileMeshes[row][col].position.clone();
      targetPos.y = tileMeshes[row][col].position.y + 0.28;
      
      gsap.to(card.position, {
        x: targetPos.x,
        y: targetPos.y,
        z: targetPos.z,
        duration: 0.5,
        ease: "power2.inOut"
      });
      
      gsap.to(card.rotation, {
        x: 0,
        y: (facingDeg[direction]) * Math.PI / 180,
        z: 0,
        duration: 0.5,
        onComplete: () => {
          updateHand();
          updateUnits();
          updateUI();
          // После размещения — если есть цели, запускаем единый боевой сценарий
          const hitsNow = computeHits(gameState, row, col);
          if (hitsNow && hitsNow.length) performBattleSequence(row, col, false);
        }
      });
      
      addLog(`${player.name} призывает ${cardData.name} на (${row + 1},${col + 1})`);
      hideOrientationPanel();
    }
    
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function wireModules() {
      try {
        DIR_VECTORS = window.DIR_VECTORS; OPPOSITE_ELEMENT = window.OPPOSITE_ELEMENT; elementEmoji = window.elementEmoji;
        turnCW = window.turnCW; turnCCW = window.turnCCW; facingDeg = window.facingDeg;
        uid = window.uid; inBounds = window.inBounds; capMana = window.capMana; attackCost = window.attackCost;
        CARDS = window.CARDS; STARTER_FIRESET = window.STARTER_FIRESET || [];
        dirsForPattern = window.dirsForPattern; effectiveStats = window.effectiveStats;
        hasAdjacentGuard = window.hasAdjacentGuard; computeHits = window.computeHits; stagedAttack = window.stagedAttack; magicAttack = window.magicAttack;
        shuffle = window.shuffle; drawOne = window.drawOne; drawOneNoAdd = window.drawOneNoAdd; countControlled = window.countControlled; startGame = window.startGame;
      } catch {}
      // Fallbacks to ensure offline scene renders even if module failed to load
      try {
        if (!startGame || typeof startGame !== 'function') {
          startGame = (deck0, deck1) => ({
            board: randomBoard(),
            players: [
              { name: 'Player 1', deck: Array.isArray(deck0)?deck0.slice():[], hand: [], discard: [], graveyard: [], mana: 2 },
              { name: 'Player 2', deck: Array.isArray(deck1)?deck1.slice():[], hand: [], discard: [], graveyard: [], mana: 0 }
            ],
            active: 0,
            turn: 1,
            winner: null
          });
        }
      } catch {}
    }

    // ---- Lightweight on-screen diagnostics for module/scene wiring ----
    function mountModuleStatusChip(){
      if (document.getElementById('mod-status')) return;
      const el = document.createElement('div');
      el.id = 'mod-status';
      el.style.cssText = 'position:fixed;left:8px;top:8px;z-index:9999;font:12px/1.2 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;color:#cbd5e1;background:rgba(15,23,42,.85);border:1px solid #334155;border-radius:8px;padding:6px 8px;pointer-events:none;';
      el.textContent = 'status…';
      document.body.appendChild(el);
      // Position below build-version (if present) to avoid overlap
      function positionModStatus(){
        try {
          const bv = document.getElementById('build-version');
          let top = 8;
          if (bv) {
            const r = bv.getBoundingClientRect();
            top = Math.max(8, Math.round((r.bottom || 0) + 8));
          }
          el.style.top = top + 'px';
        } catch { el.style.top = '36px'; }
      }
      try {
        positionModStatus();
        window.addEventListener('resize', positionModStatus);
        const bv = document.getElementById('build-version');
        if (bv && window.MutationObserver) {
          const mo = new MutationObserver(positionModStatus);
          mo.observe(bv, { childList: true, characterData: true, subtree: true });
        }
      } catch {}
      updateModuleStatus();
      try { if (!window.__modStatusTimer) window.__modStatusTimer = setInterval(updateModuleStatus, 1000); } catch {}
      window.addEventListener('error', (e)=>{ try { el.setAttribute('data-last', String(e.message||'error')); updateModuleStatus(); } catch {} });
    }
    function okBadge(ok){ return `<span style="color:${ok?'#22c55e':'#ef4444'}">●</span>`; }
    function updateModuleStatus(){
      const el = document.getElementById('mod-status'); if (!el) return;
      const hasCards = !!(CARDS && Object.keys(CARDS||{}).length);
      const starterLen = (STARTER_FIRESET && STARTER_FIRESET.length) || 0;
      const rulesOk = [dirsForPattern, effectiveStats, computeHits, stagedAttack, magicAttack].every(fn => typeof fn === 'function');
      const stateOk = [startGame, drawOne, drawOneNoAdd, shuffle, countControlled].every(fn => typeof fn === 'function');
      const threeOk = !!(renderer && scene && camera);
      const boardOk = !!(tileMeshes && tileMeshes.length && tileMeshes[0] && tileMeshes[0].length);
      const gs = (typeof gameState === 'object' && gameState && Array.isArray(gameState.board)) ? 'ok' : 'none';
      const net = (typeof NET_ACTIVE !== 'undefined' && NET_ACTIVE) ? 'online' : 'offline';
      const last = el.getAttribute('data-last') || '';
      el.innerHTML = [
        `${okBadge(hasCards)} cards (${starterLen})`,
        `${okBadge(rulesOk)} rules`,
        `${okBadge(stateOk)} state`,
        `${okBadge(threeOk)} three`,
        `${okBadge(boardOk)} board`,
        `${okBadge(gs==='ok')} gState`,
        `${okBadge(net==='online')} net:${net}`,
        last ? `<div style="color:#fca5a5;margin-top:4px;max-width:240px;">${last}</div>` : ''
      ].join(' · ');
    }
    
    // Bridge helpers for gradual migration to modules
    function initThreeJSBridge(){
      if (window.__scene && typeof window.__scene.initThreeJS === 'function') {
        try {
          const ctx = window.__scene.initThreeJS({ canvasId: 'three-canvas' });
          renderer = ctx.renderer; scene = ctx.scene; camera = ctx.camera;
          raycaster = ctx.raycaster; mouse = ctx.mouse;
          boardGroup = ctx.boardGroup; cardGroup = ctx.cardGroup; effectsGroup = ctx.effectsGroup; metaGroup = ctx.metaGroup;
          try { window.renderer = renderer; window.scene = scene; window.camera = camera; window.boardGroup = boardGroup; } catch {}
          return true;
        } catch (e) { console.error('[bridge] initThreeJS via module failed, fallback', e); }
      }
      try { initThreeJS(); return true; } catch (e) { console.error('[bridge] legacy initThreeJS failed', e); return false; }
    }
    let __sceneLoopStarted = false;
    function animateBridge(){
      if (window.__scene && typeof window.__scene.animate === 'function') {
        if (!__sceneLoopStarted) { __sceneLoopStarted = true; try { window.__scene.animate(); } catch (e) { console.error('[bridge] animate via module failed', e); } }
        return;
      }
      try { animate(); } catch (e) { console.error('[bridge] legacy animate failed', e); }
    }
    function createBoardBridge(){
      if (window.__board && typeof window.__board.createBoard === 'function' && window.__scene && typeof window.__scene.getCtx === 'function') {
        try {
          window.__board.createBoard(gameState);
          const ctx = window.__scene.getCtx();
          tileMeshes = ctx.tileMeshes || []; tileFrames = ctx.tileFrames || [];
          try { window.tileMeshes = tileMeshes; window.tileFrames = tileFrames; } catch {}
          return true;
        } catch (e) { console.error('[bridge] createBoard via module failed, fallback', e); }
      }
      try { createBoard(); return true; } catch (e) { console.error('[bridge] legacy createBoard failed', e); return false; }
    }

    // Override legacy createBoard to route through bridge when modules are present
    try {
      const __legacyCreateBoard = createBoard;
      createBoard = function() {
        if (window.__board && window.__scene && typeof window.__board.createBoard === 'function') {
          window.__board.createBoard(gameState);
          const ctx = window.__scene.getCtx();
          tileMeshes = ctx.tileMeshes || []; tileFrames = ctx.tileFrames || [];
          try { window.tileMeshes = tileMeshes; window.tileFrames = tileFrames; } catch {}
          return;
        }
        console.error('[bridge] __board.createBoard not available; modules must be loaded.');
        throw new Error('Module board missing');
      };
    } catch {}
    // Board material helpers: delegate to window.__board
    try {
      const __legacyCreateProc = createProceduralTileTexture;
      createProceduralTileTexture = function(element) {
        if (window.__board && typeof window.__board.createProceduralTileTexture === 'function') {
          return window.__board.createProceduralTileTexture(element);
        }
        return __legacyCreateProc ? __legacyCreateProc(element) : null;
      };
    } catch {}
    try {
      const __legacyGetTileMat = getTileMaterial;
      getTileMaterial = function(element) {
        if (window.__board && typeof window.__board.getTileMaterial === 'function') {
          return window.__board.getTileMaterial(element);
        }
        return __legacyGetTileMat ? __legacyGetTileMat(element) : new THREE.MeshStandardMaterial({ color: 0x64748b });
      };
    } catch {}

    // Bridge card helpers to module implementations when available
    try {
      getCachedTexture = function(url) {
        if (window.__cards && typeof window.__cards.getCachedTexture === 'function') {
          return window.__cards.getCachedTexture(url);
        }
        console.error('[bridge] __cards.getCachedTexture not available; modules must be loaded.');
        throw new Error('Module cards missing');
      };
    } catch {}
    try {
      preloadCardTextures = function() {
        if (window.__cards && typeof window.__cards.preloadCardTextures === 'function') {
          return window.__cards.preloadCardTextures();
        }
        console.error('[bridge] __cards.preloadCardTextures not available; modules must be loaded.');
        throw new Error('Module cards missing');
      };
    } catch {}
    try {
      createCard3D = function() {
        if (window.__cards && typeof window.__cards.createCard3D === 'function') {
          return window.__cards.createCard3D.apply(null, arguments);
        }
        console.error('[bridge] __cards.createCard3D not available; modules must be loaded.');
        throw new Error('Module cards missing');
      };
    } catch {}
    try {
      drawCardFace = function() {
        if (window.__cards && typeof window.__cards.drawCardFace === 'function') {
          return window.__cards.drawCardFace.apply(null, arguments);
        }
        console.error('[bridge] __cards.drawCardFace not available; modules must be loaded.');
        throw new Error('Module cards missing');
      };
    } catch {}
    try {
      updateUnits = function() {
        if (window.__units && typeof window.__units.updateUnits === 'function') {
          window.__units.updateUnits(gameState);
          const ctx = (window.__scene && typeof window.__scene.getCtx === 'function') ? window.__scene.getCtx() : null;
          if (ctx && ctx.unitMeshes) { unitMeshes = ctx.unitMeshes; try { window.unitMeshes = unitMeshes; } catch {} }
          return;
        }
        console.error('[bridge] __units.updateUnits not available; modules must be loaded.');
        throw new Error('Module units missing');
      };
    } catch {}

    // Bridge UI banner helpers to module implementations when available
    try {
      const __legacyShowTurnSplash = showTurnSplash;
      showTurnSplash = function(title) {
        if (window.__ui && window.__ui.banner && typeof window.__ui.banner.showTurnSplash === 'function') {
          return window.__ui.banner.showTurnSplash(title);
        }
        return __legacyShowTurnSplash ? __legacyShowTurnSplash(title) : Promise.resolve();
      };
    } catch {}
    try {
      const __legacyQueueTurnSplash = queueTurnSplash;
      queueTurnSplash = function(title) {
        if (window.__ui && window.__ui.banner && typeof window.__ui.banner.queueTurnSplash === 'function') {
          return window.__ui.banner.queueTurnSplash(title);
        }
        return __legacyQueueTurnSplash ? __legacyQueueTurnSplash(title) : Promise.resolve();
      };
    } catch {}
    try {
      const __legacyRequestTurnSplash = requestTurnSplash;
      requestTurnSplash = function() {
        if (window.__ui && window.__ui.banner && typeof window.__ui.banner.requestTurnSplash === 'function') {
          const t = (typeof gameState?.turn === 'number') ? gameState.turn : null;
          return window.__ui.banner.requestTurnSplash(t);
        }
        return __legacyRequestTurnSplash ? __legacyRequestTurnSplash() : Promise.resolve();
      };
    } catch {}
    try {
      const __legacyForceTurnSplashWithRetry = forceTurnSplashWithRetry;
      forceTurnSplashWithRetry = function(maxRetries) {
        const t = (typeof gameState?.turn === 'number') ? gameState.turn : null;
        if (window.__ui && window.__ui.banner) {
          const b = window.__ui.banner;
          if (typeof b.ensureTurnSplashVisible === 'function') return b.ensureTurnSplashVisible(maxRetries, t);
          if (typeof b.forceTurnSplashWithRetry === 'function') return b.forceTurnSplashWithRetry(maxRetries, t);
        }
        return __legacyForceTurnSplashWithRetry ? __legacyForceTurnSplashWithRetry(maxRetries) : Promise.resolve();
      };
    } catch {}

    // Bridge mana world->bar animation to module implementation
    try {
      const __legacyAnimateManaGainFromWorld = animateManaGainFromWorld;
      animateManaGainFromWorld = function(pos, ownerIndex, visualOnly = true) {
        if (window.__ui && window.__ui.mana && typeof window.__ui.mana.animateManaGainFromWorld === 'function') {
          return window.__ui.mana.animateManaGainFromWorld(pos, ownerIndex, visualOnly);
        }
        return __legacyAnimateManaGainFromWorld ? __legacyAnimateManaGainFromWorld(pos, ownerIndex, visualOnly) : undefined;
      };
    } catch {}

    function init() {
      wireModules();
      mountModuleStatusChip();
      initThreeJSBridge();
      // Start render loop early so scene is visible even if game init fails
      animateBridge();
      initGame();
      
      renderer.domElement.addEventListener('mousemove', onMouseMove);
      renderer.domElement.addEventListener('mousedown', onMouseDown);
      renderer.domElement.addEventListener('mouseup', onMouseUp);
      renderer.domElement.addEventListener('mouseleave', () => {
        if (hoveredHandCard) {
          gsap.to(hoveredHandCard.scale, { x: 0.54, y: 1, z: 0.54, duration: 0.18 });
          setHandCardHoverVisual(hoveredHandCard, false);
          hoveredHandCard = null;
        }
      });
      window.addEventListener('resize', onWindowResize);
      
    }
    try { window.init = init; window.initThreeJS = initThreeJS; window.initGame = initGame; window.animate = animate; } catch {}

    // UI wrappers: use modules only (no legacy fallback)
    try { showNotification = (message, type) => window.__ui.notifications.show(message, type); } catch {}
    try { addLog = (message) => window.__ui.log.add(message); } catch {}
    try { animateManaGainFromWorld = (pos, ownerIndex, visualOnly) => window.__ui.mana.animateManaGainFromWorld(pos, ownerIndex, visualOnly); } catch {}
    // animateTurnManaGain теперь вызывается напрямую через модуль
    try { showUnitActionPanel = (unitMesh) => { try { selectedUnit = unitMesh; window.selectedUnit = unitMesh; } catch {}; return window.__ui.panels.showUnitActionPanel(unitMesh); }; } catch {}
    try { hideUnitActionPanel = () => { try { selectedUnit = null; window.selectedUnit = null; } catch {}; return window.__ui.panels.hideUnitActionPanel();}; } catch {}
    try { showOrientationPanel = () => window.__ui.panels.showOrientationPanel(); } catch {}
    try { hideOrientationPanel = () => window.__ui.panels.hideOrientationPanel(); } catch {}
    try { showPrompt = (text, onCancel) => window.__ui.panels.showPrompt(text, onCancel); } catch {}
    try { hidePrompt = () => window.__ui.panels.hidePrompt(); } catch {}

    function createMetaObjects() {
      // Очистить предыдущие
      deckMeshes.forEach(m => m.parent && m.parent.remove(m));
      graveyardMeshes.forEach(m => m.parent && m.parent.remove(m));
      deckMeshes = []; graveyardMeshes = [];
      if (!gameState) return;
      const baseX = (6.2 + 0.2) * 1 + 6.6; // правее поля
      const zA = -5.2 - META_Z_AWAY; const zB = 0.2 + META_Z_AWAY; // Важно (смещение колоды/кладбища от камеры)
      function buildDeck(player, z) {
        const g = new THREE.Group(); g.position.set(baseX, 0.5, z); g.userData = { metaType: 'deck', player };
        const sideMap = (CARD_TEX && CARD_TEX.deckSide) ? CARD_TEX.deckSide : getCachedTexture('textures/card_deck_side_view.jpeg');
        const backMap = (CARD_TEX && CARD_TEX.back) ? CARD_TEX.back : getCachedTexture('textures/card_back_main.jpeg');
        const sideMat = new THREE.MeshStandardMaterial({ map: sideMap, color: 0xffffff, metalness: 0.3, roughness: 0.85 });
        const body = new THREE.Mesh(new THREE.BoxGeometry(3.6, 0.8, 5.0), sideMat);
        body.castShadow = true; body.receiveShadow = true; body.userData = { metaType: 'deck', player };
        const top = new THREE.Mesh(new THREE.BoxGeometry(3.62, 0.04, 5.02), new THREE.MeshStandardMaterial({ map: backMap, color: 0xffffff }));
        top.position.y = 0.42; top.userData = { metaType: 'deck', player };
        g.add(body); g.add(top); metaGroup.add(g); deckMeshes.push(g);
      }
      function buildGrave(player, z) {
        const g = new THREE.Group(); g.position.set(baseX + 4.2, 0.5, z); g.userData = { metaType: 'grave', player };
        const base = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.2, 0.3, 20), new THREE.MeshStandardMaterial({ color: 0x334155 }));
        base.userData = { metaType: 'grave', player };
        const icon = new THREE.Mesh(new THREE.BoxGeometry(1.0, 1.2, 0.1), new THREE.MeshStandardMaterial({ color: 0x64748b }));
        icon.position.y = 0.9; icon.rotation.y = Math.PI / 8; icon.userData = { metaType: 'grave', player };
        g.add(base); g.add(icon); metaGroup.add(g); graveyardMeshes.push(g);
      }
      buildDeck(0, zA); buildDeck(1, zB); buildGrave(0, zA); buildGrave(1, zB);
    }
    
    // Обработчики UI
    document.getElementById('end-turn-btn').addEventListener('click', () => {
      try { if (typeof window.endTurn === 'function') window.endTurn(); } catch {}
    });
    refreshInputLockUI();
    document.getElementById('new-game-btn').addEventListener('click', () => location.reload());
    document.getElementById('log-btn').addEventListener('click', () => {
      const lp = document.getElementById('log-panel');
      lp.classList.toggle('hidden');
      // На всякий случай жёстко позиционируем ниже контролов
      lp.style.top = (document.getElementById('controls').offsetHeight + 40) + 'px';
      if (!lp.classList.contains('hidden')) lp.style.pointerEvents = 'auto';
    });
    document.getElementById('close-log-btn').addEventListener('click', () => {
      document.getElementById('log-panel').classList.add('hidden');
    });
    document.getElementById('help-btn').addEventListener('click', () => {
      document.getElementById('help-panel').classList.remove('hidden');
    });
    document.getElementById('close-help-btn').addEventListener('click', () => {
      document.getElementById('help-panel').classList.add('hidden');
    });
    // Prompt handlers
    document.getElementById('cancel-prompt-btn').addEventListener('click', () => {
      if (activePrompt && typeof activePrompt.onCancel === 'function') {
        try { activePrompt.onCancel(); } catch {}
      }
      hidePrompt();
    });
    document.getElementById('cancel-orient-btn').addEventListener('click', () => {
      if (pendingPlacement) {
        returnCardToHand(pendingPlacement.card);
      }
      hideOrientationPanel();
    });
    document.getElementById('cancel-action-btn').addEventListener('click', hideUnitActionPanel);
    // Действия в панели юнита
    document.getElementById('rotate-cw-btn').addEventListener('click', () => {
      if (selectedUnit) rotateUnit(selectedUnit, 'cw');
    });
    document.getElementById('rotate-ccw-btn').addEventListener('click', () => {
      if (selectedUnit) rotateUnit(selectedUnit, 'ccw');
    });
    document.getElementById('attack-btn').addEventListener('click', () => {
      if (selectedUnit) performUnitAttack(selectedUnit);
    });
    
    document.querySelectorAll('[data-dir]').forEach(btn => {
      btn.addEventListener('click', () => {
        // Явное соответствие символов на кнопках и направлений
        const direction = btn.getAttribute('data-dir'); // 'N' | 'E' | 'S' | 'W'
        // Если ожидается выбор направления для спелла — применим его и завершим
        if (pendingSpellOrientation) {
          const { spellCardMesh, unitMesh } = pendingSpellOrientation;
          const idx = spellCardMesh.userData.handIndex;
          const pl = gameState.players[gameState.active];
          const tpl = pl.hand[idx];
          const r = unitMesh.userData.row; const c = unitMesh.userData.col; const u = gameState.board[r][c].unit;
          if (tpl && tpl.id === 'SPELL_BEGUILING_FOG' && u) {
            u.facing = direction;
            addLog(`${tpl.name}: ${CARDS[u.tplId].name} повёрнут в ${direction}.`);
            pl.discard.push(tpl); pl.hand.splice(idx, 1);
            resetCardSelection(); updateHand(); updateUnits(); updateUI();
          }
          pendingSpellOrientation = null; hideOrientationPanel();
          return;
        }
        // Иначе — штатное размещение юнита
        if (direction === 'N') return placeUnitWithDirection('N');
        if (direction === 'E') return placeUnitWithDirection('E');
        if (direction === 'S') return placeUnitWithDirection('S');
        if (direction === 'W') return placeUnitWithDirection('W');
      });
    });
    
    document.addEventListener('DOMContentLoaded', init);

    // ====== ДОПОЛНИТЕЛЬНЫЕ ФУНКЦИИ ДЕЙСТВИЙ ======
    function showPrompt(text, onCancel) {
      const pp = document.getElementById('prompt-panel');
      const pt = document.getElementById('prompt-text');
      if (pp && pt) {
        pt.textContent = text || '';
        pp.classList.remove('hidden');
        activePrompt = { text, onCancel };
      }
    }
    function hidePrompt() {
      const pp = document.getElementById('prompt-panel');
      if (pp) pp.classList.add('hidden');
      activePrompt = null;
    }
    function rotateUnit(unitMesh, dir) {
      if (isInputLocked()) return;
      const u = unitMesh.userData.unitData;
      if (!u) return;
      if (u.owner !== gameState.active) { showNotification('You can\'t rotate the other player\'s unit', 'error'); return; }
      if (u.lastRotateTurn === gameState.turn) { showNotification('The unit has already rotated in this turn', 'error'); return; }
      const tpl = CARDS[u.tplId];
      const cost = attackCost(tpl);
      if (gameState.players[gameState.active].mana < cost) { showNotification(`${cost} mana is required to rotate`, 'error'); return; }
      gameState.players[gameState.active].mana -= cost; updateUI();
      u.facing = dir === 'cw' ? turnCW[u.facing] : turnCCW[u.facing];
      u.lastRotateTurn = gameState.turn;
      updateUnits();
      hideUnitActionPanel();

       }
    
    function performUnitAttack(unitMesh) {
      if (!unitMesh) return;
      if (isInputLocked()) return;
      const r = unitMesh.userData.row; const c = unitMesh.userData.col;
      const unit = gameState.board[r][c].unit; if (!unit) return;
      const tpl = CARDS[unit.tplId];
      const cost = attackCost(tpl);
      if (tpl.attackType === 'MAGIC') {
        if (gameState.players[gameState.active].mana < cost) { showNotification(`${cost} mana is required to attack`, 'error'); return; }
        gameState.players[gameState.active].mana -= cost;
        updateUI();
        magicFrom = { r, c };
        addLog(`${tpl.name}: select a target for the magical attack.`);
         return;
      }
      const hits = computeHits(gameState, r, c);
      if (!hits.length) { showNotification('No available targets for attack', 'error');  return; }
      if (gameState.players[gameState.active].mana < cost) { showNotification(`${cost} mana is required to attack`, 'error');  return; }
      gameState.players[gameState.active].mana -= cost;
      updateUI();
      performBattleSequence(r, c, true);
       }
    
    async function performBattleSequence(r, c, markAttackTurn) {
      const staged = stagedAttack(gameState, r, c);
      if (!staged || staged.empty) return;
      // flashy заставка BATTLE (сокращённая)
      await showBattleSplash();
      // небольшая анимация выпада/толчка
      const aMesh = unitMeshes.find(m => m.userData.row === r && m.userData.col === c);
      const hitsPrev = (staged.targetsPreview || computeHits(gameState, r, c));
      const fromPos = (aMesh ? aMesh.position.clone() : tileMeshes[r][c].position.clone().add(new THREE.Vector3(0, 0.8, 0)));

      const doStep1 = () => {
        // Убраны жёлтые лучи/стрелки под картами
        // Применяем урон (этап 1) и перерисовываем юниты
        staged.step1();
        gameState = staged.n1; updateUnits();
        // Тряска и всплывающий урон — уже по актуальным мешам после обновления
        for (const h of hitsPrev) {
          const tMesh = unitMeshes.find(m => m.userData.row === h.r && m.userData.col === h.c);
          if (tMesh) { 
            shakeMesh(tMesh, 6, 0.12); 
            spawnDamageText(tMesh, `-${h.dmg}`, '#ff5555');
          }
        }
        setTimeout(async () => {
          // Сокращённая пауза перед контратакой
          await sleep(700);
          const ret = staged.step2() || { total: 0, retaliators: [] };
          const retaliation = typeof ret === 'number' ? ret : (ret.total || 0);
          let animDelayMs = 0;
          if (retaliation > 0) {
            // Выпад всех контратакующих
            const retaliators = (ret.retaliators || []);
            let maxDur = 0;
            for (const rrObj of retaliators) {
              const rMesh = unitMeshes.find(m => m.userData.row === rrObj.r && m.userData.col === rrObj.c);
              // Пересчитаем актуальный меш атакующего после обновления юнитов
              const aMeshLive = unitMeshes.find(m => m.userData.row === r && m.userData.col === c) || aMesh;
              if (rMesh && aMeshLive) {
                const dir2 = new THREE.Vector3().subVectors(aMeshLive.position, rMesh.position).normalize();
                const push2 = { x: dir2.x * 0.6, z: dir2.z * 0.6 };
                const tl2 = gsap.timeline();
                tl2.to(rMesh.position, { x: `+=${push2.x}`, z: `+=${push2.z}`, duration: 0.22, ease: 'power2.out' })
                   .to(rMesh.position, { x: `-=${push2.x}`, z: `-=${push2.z}`, duration: 0.30, ease: 'power2.inOut' });
                maxDur = Math.max(maxDur, 0.52);
              }
            }
            // После лунжей контратаки — тряска и числа урона по атакующему
            setTimeout(() => { 
              const aLive = unitMeshes.find(m => m.userData.row === r && m.userData.col === c) || aMesh; 
              if (aLive) { 
                shakeMesh(aLive, 6, 0.14); 
                spawnDamageText(aLive, `-${retaliation}`, '#ffd166');
              } 
            }, Math.max(0, maxDur * 1000 - 10));
            animDelayMs = Math.max(animDelayMs, Math.floor(maxDur * 1000) + 160);
            // Синхронизация контратаки для наблюдателя
            try {
              const shouldSend = (typeof window !== 'undefined' && window.socket && (typeof NET_ACTIVE !== 'undefined' ? NET_ACTIVE : false) && (typeof MY_SEAT !== 'undefined' ? MY_SEAT : null) === gameState.active);
              console.log('[battleRetaliation] Checking if should send:', {
                hasWindow: typeof window !== 'undefined',
                hasSocket: !!(typeof window !== 'undefined' && window.socket),
                NET_ACTIVE: typeof NET_ACTIVE !== 'undefined' ? NET_ACTIVE : 'undefined',
                MY_SEAT: typeof MY_SEAT !== 'undefined' ? MY_SEAT : 'undefined',
                gameStateActive: gameState.active,
                seatMatches: (typeof MY_SEAT !== 'undefined' ? MY_SEAT : null) === gameState.active,
                shouldSend,
                retaliation
              });
              if (shouldSend) {
                window.socket.emit('battleRetaliation', {
                  attacker: { r, c },
                  retaliators: retaliators.map(x => ({ r: x.r, c: x.c })),
                  total: retaliation,
                  bySeat: typeof window.MY_SEAT === 'number' ? window.MY_SEAT : null
                });
                console.log('[battleRetaliation] Sent battleRetaliation event', { attacker: { r, c }, retaliators: retaliators.length, total: retaliation });
              }
            } catch (e) {
              console.error('[battleRetaliation] Error sending battleRetaliation:', e);
            }
          }
          // Финализация: анимация смерти и орбы перед применением состояния
          const res = staged.finish();
          if (res.deaths && res.deaths.length) {
            for (const d of res.deaths) {
              try { gameState.players[d.owner].graveyard.push(CARDS[d.tplId]); } catch {}
              const deadMesh = unitMeshes.find(m => m.userData.row === d.r && m.userData.col === d.c);
              if (deadMesh) {
                const fromMesh = aMesh || deadMesh;
                const dirUp = new THREE.Vector3().subVectors(deadMesh.position, fromMesh.position).normalize().multiplyScalar(0.4);
                dissolveAndAsh(deadMesh, dirUp, 0.9);
              }
              // Орб маны появляется с задержкой 400мс после начала анимации смерти
              setTimeout(() => {
                const p = tileMeshes[d.r][d.c].position.clone().add(new THREE.Vector3(0, 1.6, 0));
                // Показать визуальный орб у обоих игроков; фактическое начисление маны уже в res.n1
                animateManaGainFromWorld(p, d.owner, true);
              }, 400);
            }
            setTimeout(() => { gameState = res.n1; updateUnits(); updateUI(); for (const l of res.logLines.reverse()) addLog(l); if (markAttackTurn && gameState.board[r][c]?.unit) gameState.board[r][c].unit.lastAttackTurn = gameState.turn; try { schedulePush('battle-finish'); } catch {} }, 1000);
          } else {
            // Если смертей нет — подождём, пока анимация контратаки завершится, затем применим состояние
            setTimeout(() => {
              gameState = res.n1; updateUnits(); updateUI(); for (const l of res.logLines.reverse()) addLog(l); if (markAttackTurn && gameState.board[r][c]?.unit) gameState.board[r][c].unit.lastAttackTurn = gameState.turn; try { schedulePush('battle-finish'); } catch {}
            }, Math.max(0, animDelayMs));
          }
        }, 420);
      };

      // Выпад атакующего перед применением урона
      if (aMesh && hitsPrev.length) {
        const firstTargetMesh = unitMeshes.find(m => m.userData.row === hitsPrev[0].r && m.userData.col === hitsPrev[0].c);
        if (firstTargetMesh) {
          const dir = new THREE.Vector3().subVectors(firstTargetMesh.position, aMesh.position).normalize();
          const push = { x: dir.x * 0.6, z: dir.z * 0.6 };
          const tl = gsap.timeline({ onComplete: doStep1 });
          tl.to(aMesh.position, { x: `+=${push.x}`, z: `+=${push.z}`, duration: 0.22, ease: 'power2.out' })
            .to(aMesh.position, { x: `-=${push.x}`, z: `-=${push.z}`, duration: 0.3, ease: 'power2.inOut' });
          // Онлайновая синхронизация выпадов (атакующий и цели)
          try {
            const shouldSend = (typeof window !== 'undefined' && window.socket && (typeof NET_ACTIVE !== 'undefined' ? NET_ACTIVE : false) && (typeof MY_SEAT !== 'undefined' ? MY_SEAT : null) === gameState.active);
            console.log('[battleAnim] Checking if should send:', {
              hasWindow: typeof window !== 'undefined',
              hasSocket: !!(typeof window !== 'undefined' && window.socket),
              NET_ACTIVE: typeof NET_ACTIVE !== 'undefined' ? NET_ACTIVE : 'undefined',
              MY_SEAT: typeof MY_SEAT !== 'undefined' ? MY_SEAT : 'undefined',
              gameStateActive: gameState.active,
              seatMatches: (typeof MY_SEAT !== 'undefined' ? MY_SEAT : null) === gameState.active,
              shouldSend
            });
            if (shouldSend) {
              window.socket.emit('battleAnim', {
                attacker: { r, c },
                targets: hitsPrev.map(h => ({ r: h.r, c: h.c, dmg: h.dmg })),
                bySeat: typeof window.MY_SEAT === 'number' ? window.MY_SEAT : null
              });
              console.log('[battleAnim] Sent battleAnim event', { attacker: { r, c }, targets: hitsPrev.length });
            }
          } catch (e) {
            console.error('[battleAnim] Error sending battleAnim:', e);
          }
        } else {
          gsap.to(aMesh.position, { y: aMesh.position.y + 0.25, yoyo: true, repeat: 1, duration: 0.2, onComplete: doStep1 });
        }
      } else {
        doStep1();
      }
    }

    function spawnDamageText(targetMesh, text, color = '#ff5555') {
      const canvas = document.createElement('canvas');
      canvas.width = 256; canvas.height = 128;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0,0,canvas.width, canvas.height);
      ctx.font = 'bold 64px Arial';
      ctx.fillStyle = color;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.lineWidth = 6;
      ctx.strokeText(text, canvas.width/2, canvas.height/2);
      ctx.fillText(text, canvas.width/2, canvas.height/2);
      const tex = new THREE.CanvasTexture(canvas);
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, opacity: 0, depthTest: false, depthWrite: false });
      const sprite = new THREE.Sprite(mat);
      sprite.scale.set(2.6, 1.4, 1);
      const pos = targetMesh.position.clone().add(new THREE.Vector3(0, 0.9, 0));
      sprite.position.copy(pos);
      sprite.renderOrder = 999;
      effectsGroup.add(sprite);
      const tl = gsap.timeline({ onComplete: () => { effectsGroup.remove(sprite); tex.dispose(); mat.dispose(); } });
      // 0.5с вылет, 1с стоп, 0.5с испарение
      tl.to(sprite.material, { opacity: 1, duration: 0.05 })
        .to(sprite.position, { y: sprite.position.y + 0.8, duration: 0.5, ease: 'power1.out' })
        .to({}, { duration: 1.0 })
        .to(sprite.position, { y: sprite.position.y + 1.6, duration: 0.5, ease: 'power1.in' }, 'end')
        .to(sprite.material, { opacity: 0, duration: 0.5 }, 'end');
    }

    function shakeMesh(mesh, times = 3, duration = 0.1) {
      const tl = gsap.timeline();
      const ox = mesh.position.x; const oz = mesh.position.z;
      for (let i = 0; i < times; i++) {
        const dx = (Math.random()*0.2 - 0.1);
        const dz = (Math.random()*0.2 - 0.1);
        tl.to(mesh.position, { x: ox + dx, z: oz + dz, duration: duration/2 })
          .to(mesh.position, { x: ox, z: oz, duration: duration/2 });
      }
      return tl;
    }

    // Dissolve shader for death effect (fiery burn-away)
    function createDissolveMaterial() {
      return new THREE.ShaderMaterial({
        transparent: true,
        depthTest: true,
        depthWrite: false,
        side: THREE.DoubleSide,
        uniforms: {
          uTime:       { value: 0.0 },
          uThreshold:  { value: 0.0 },
          uEdgeWidth:  { value: 0.08 },
          uEdgeColor:  { value: new THREE.Color(0.55, 0.80, 1.0) }, // магическая голубая кромка
          uBaseColor:  { value: new THREE.Color(0.90, 0.95, 1.0) }, // холодный светлый
          uNoiseScale: { value: 3.0 },
          uNoiseMove:  { value: new THREE.Vector2(0.15, -0.1) },
        },
        vertexShader: `
          varying vec2 vUv;
          varying vec3 vPos;
          void main(){
            vUv = uv;
            vec4 mv = modelViewMatrix * vec4(position, 1.0);
            vPos = (modelMatrix * vec4(position, 1.0)).xyz;
            gl_Position = projectionMatrix * mv;
          }
        `,
        fragmentShader: `
          precision highp float;
          varying vec2 vUv;
          varying vec3 vPos;
          uniform float uTime;
          uniform float uThreshold;
          uniform float uEdgeWidth;
          uniform vec3  uEdgeColor;
          uniform vec3  uBaseColor;
          uniform float uNoiseScale;
          uniform vec2  uNoiseMove;
          float hash(vec2 p){
            p = fract(p * vec2(123.34, 345.45));
            p += dot(p, p + 34.345);
            return fract(p.x * p.y);
          }
          float noise(vec2 p){
            vec2 i = floor(p);
            vec2 f = fract(p);
            float a = hash(i);
            float b = hash(i + vec2(1.0, 0.0));
            float c = hash(i + vec2(0.0, 1.0));
            float d = hash(i + vec2(1.0, 1.0));
            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
          }
          float fbm(vec2 p){
            float v = 0.0;
            float a = 0.5;
            for (int i = 0; i < 5; i++){
              v += a * noise(p);
              p *= 2.02;
              a *= 0.5;
            }
            return v;
          }
          void main(){
            float heightBias = clamp((vPos.y + 0.9) * 0.2, 0.0, 1.0);
            vec2  uv = vUv * uNoiseScale + uNoiseMove * uTime;
            float n = fbm(uv) * 0.8 + heightBias * 0.2;
            float d = n - uThreshold;
            if (d < 0.0) discard;
            float edge = smoothstep(0.0, uEdgeWidth, d) - smoothstep(uEdgeWidth, uEdgeWidth * 2.0, d);
            vec3 color = mix(uBaseColor, uEdgeColor, edge);
            gl_FragColor = vec4(color, 1.0);
          }
        `
      });
    }

    function dissolveAndAsh(mesh, awayVec, durationSec = 1.0) {
      // Клонируем визуальный объект и анимируем клон в effectsGroup, оригинал скрываем
      if (!mesh) return;
      try { mesh.updateWorldMatrix(true, true); } catch {}
      const worldPos = new THREE.Vector3();
      const worldQuat = new THREE.Quaternion();
      const worldScale = new THREE.Vector3();
      try { mesh.getWorldPosition(worldPos); mesh.getWorldQuaternion(worldQuat); mesh.getWorldScale(worldScale); } catch {}
      const ghost = mesh.clone(true);
      ghost.traverse(obj => { if (obj && obj.userData) obj.userData = { ...obj.userData }; });
      ghost.position.copy(worldPos);
      ghost.quaternion.copy(worldQuat);
      ghost.scale.copy(worldScale);
      ghost.renderOrder = (mesh.renderOrder || 1000) + 10;
      try { effectsGroup.add(ghost); } catch { (mesh.parent||scene).add(ghost); }
      try { mesh.visible = false; } catch {}

      // Подготовим материалы на клоне и соберём uniform'ы
      const dissolveTargets = [];
      ghost.traverse(obj => {
        if (obj && obj.isMesh && obj.material) {
          const materials = Array.isArray(obj.material) ? obj.material : [obj.material];
          const newMats = [];
          for (const m of materials) {
            if (!m) { newMats.push(m); continue; }
            const matClone = m.clone();
            matClone.transparent = true;
            matClone.depthWrite = false;
            matClone.onBeforeCompile = (shader) => {
              shader.uniforms.uTime = { value: 0.0 };
              shader.uniforms.uThreshold = { value: 0.0 };
              shader.uniforms.uEdgeWidth = { value: 0.12 };
              shader.uniforms.uEdgeColor = { value: new THREE.Color(0.55, 0.80, 1.0) };
              shader.uniforms.uBaseColor = { value: new THREE.Color(0.90, 0.95, 1.0) };
              shader.uniforms.uNoiseScale = { value: 3.0 };
              shader.uniforms.uNoiseMove = { value: new THREE.Vector2(0.15, -0.1) };
              shader.vertexShader = shader.vertexShader
                .replace('#include <common>', '#include <common>\n varying vec3 dWorldPos;')
                .replace('#include <project_vertex>', '#include <project_vertex>\n dWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;');
              const header = `
                varying vec3 dWorldPos;
                uniform float uTime; uniform float uThreshold; uniform float uEdgeWidth; uniform vec3 uEdgeColor; uniform float uNoiseScale; uniform vec2 uNoiseMove;
                float dhash(vec2 p){ p = fract(p * vec2(123.34, 345.45)); p += dot(p, p + 34.345); return fract(p.x * p.y); }
                float dnoise(vec2 p){ vec2 i = floor(p); vec2 f = fract(p); float a = dhash(i); float b = dhash(i+vec2(1.0,0.0)); float c = dhash(i+vec2(0.0,1.0)); float d = dhash(i+vec2(1.0,1.0)); vec2 u = f*f*(3.0-2.0*f); return mix(a,b,u.x) + (c-a)*u.y*(1.0-u.x) + (d-b)*u.x*u.y; }
                float dfbm(vec2 p){ float v=0.0; float a=0.5; for (int i=0;i<5;i++){ v+=a*dnoise(p); p*=2.02; a*=0.5; } return v; }
                vec4 applyDissolve(vec4 baseColor){
                  vec2  uv = dWorldPos.xz * uNoiseScale + uNoiseMove * uTime;
                  float heightBias = clamp((dWorldPos.y) * 0.15, 0.0, 1.0);
                  float n = dfbm(uv) * 0.8 + heightBias * 0.2;
                  float d = n - uThreshold; if (d < 0.0) discard;
                  float edge = smoothstep(0.0, uEdgeWidth, d) - smoothstep(uEdgeWidth, uEdgeWidth*2.0, d);
                  vec3 c = mix(baseColor.rgb, uEdgeColor, edge);
                  return vec4(c, baseColor.a);
                }
              `;
              shader.fragmentShader = shader.fragmentShader.replace('#include <common>', '#include <common>\n' + header);
              try { shader.fragmentShader = shader.fragmentShader.replace(/gl_FragColor\s*=\s*([^;]+);/g, 'gl_FragColor = applyDissolve($1);'); } catch(e) {}
              shader.fragmentShader = shader.fragmentShader.replace('#include <dithering_fragment>', '#include <dithering_fragment>\n gl_FragColor = applyDissolve(gl_FragColor);');
              dissolveTargets.push(shader.uniforms);
            };
            matClone.needsUpdate = true;
            newMats.push(matClone);
          }
          obj.material = Array.isArray(obj.material) ? newMats : newMats[0];
        }
      });

      const start = performance.now();
      let rafId = 0; let alive = true;
      (function tick(){
        if (!alive) return;
        const t = (performance.now() - start) / 1000;
        for (const u of dissolveTargets) { if (u && u.uTime) u.uTime.value = t; }
        rafId = requestAnimationFrame(tick);
      })();
      const tl = gsap.timeline({ onComplete: () => {
        alive = false; try { cancelAnimationFrame(rafId); } catch {}
        try { effectsGroup.remove(ghost); } catch {}
      }});
      const dy = 1.2;
      tl.to({}, { duration: 0.0 })
        .to({ th: 0.0 }, {
          th: 1.0, duration: Math.max(0.6, durationSec), ease: 'power1.inOut',
          onUpdate: function(){ const v = this.targets()[0].th; for (const u of dissolveTargets) { if (u && u.uThreshold) u.uThreshold.value = v; } },
        }, 0)
        .to(ghost.position, { y: ghost.position.y + dy, duration: Math.max(0.6, durationSec), ease: 'power1.inOut' }, 0);
    }

    function fadeOutAndFly(mesh, awayVec) {
      awayVec = awayVec || new THREE.Vector3(0, 0, 1);
      const mats = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
      mats.forEach(m => { m.transparent = true; });
      const tl = gsap.timeline();
      tl.to(mesh.rotation, { y: mesh.rotation.y + Math.PI * 0.6, x: mesh.rotation.x - Math.PI * 0.20, duration: 1.5, ease: 'power1.inOut' }, 0)
        .to(mesh.position, { x: mesh.position.x + awayVec.x, y: mesh.position.y + 2.2, z: mesh.position.z + awayVec.z, duration: 1.5, ease: 'power2.in' }, 0)
        .to(mats, { opacity: 0, duration: 1.5 }, 0);
    }
    
    // Плавная шейдерная замена материала тайла (для Fissures)
    function dissolveTileSwap(tileMesh, newMaterial, durationSec = 0.9) {
      if (!tileMesh || !newMaterial) return;
      try {
        const old = tileMesh.material;
        // Обёртка над onBeforeCompile аналогично dissolveAndAsh, но для плоского тайла
        const uniforms = {
          uTime: { value: 0.0 },
          uThreshold: { value: 0.0 },
          uEdgeWidth: { value: 0.10 },
          uEdgeColor: { value: new THREE.Color(0.95, 0.85, 0.4) },
          uNoiseScale: { value: 5.0 },
          uNoiseMove: { value: new THREE.Vector2(0.2, -0.12) }
        };
        const matClone = old.clone();
        matClone.transparent = true; matClone.depthWrite = false;
        matClone.onBeforeCompile = (shader) => {
          shader.uniforms.uTime = uniforms.uTime;
          shader.uniforms.uThreshold = uniforms.uThreshold;
          shader.uniforms.uEdgeWidth = uniforms.uEdgeWidth;
          shader.uniforms.uEdgeColor = uniforms.uEdgeColor;
          shader.uniforms.uNoiseScale = uniforms.uNoiseScale;
          shader.uniforms.uNoiseMove = uniforms.uNoiseMove;
          const header = `
            uniform float uTime; uniform float uThreshold; uniform float uEdgeWidth; uniform vec3 uEdgeColor; uniform float uNoiseScale; uniform vec2 uNoiseMove;
            float hashf(vec2 p){ p = fract(p * vec2(123.34, 345.45)); p += dot(p, p + 34.345); return fract(p.x * p.y); }
            float noisef(vec2 p){ vec2 i=floor(p); vec2 f=fract(p); float a=hashf(i); float b=hashf(i+vec2(1.,0.)); float c=hashf(i+vec2(0.,1.)); float d=hashf(i+vec2(1.,1.)); vec2 u=f*f*(3.-2.*f); return mix(a,b,u.x)+(c-a)*u.y*(1.-u.x)+(d-b)*u.x*u.y; }
            float fbmf(vec2 p){ float v=0., a=0.5; for(int i=0;i<5;i++){ v+=a*noisef(p); p*=2.02; a*=0.5; } return v; }
          `;
          shader.fragmentShader = shader.fragmentShader.replace('#include <common>', '#include <common>\n'+header);
          shader.fragmentShader = shader.fragmentShader.replace('#include <dithering_fragment>', `#include <dithering_fragment>\n{
            vec2 uv = gl_FragCoord.xy * (uNoiseScale/512.0) + uNoiseMove * uTime;
            float n = fbmf(uv);
            float d = n - uThreshold; if (d < 0.0) discard; 
            float edge = smoothstep(0.0, uEdgeWidth, d) - smoothstep(uEdgeWidth, uEdgeWidth*2.0, d);
            gl_FragColor.rgb = mix(gl_FragColor.rgb, uEdgeColor, edge);
          }`);
        };
        tileMesh.material = matClone; tileMesh.material.needsUpdate = true;
        const start = performance.now(); let rafId=0, alive=true;
        (function tick(){ if(!alive) return; const t=(performance.now()-start)/1000; uniforms.uTime.value=t; rafId=requestAnimationFrame(tick); })();
        gsap.to({ th: 0.0 }, { th: 1.0, duration: Math.max(0.5, durationSec), ease: 'power1.inOut', onUpdate: function(){ uniforms.uThreshold.value=this.targets()[0].th; }, onComplete: ()=>{
          alive=false; try{ cancelAnimationFrame(rafId);}catch{}
          // Устанавливаем новый материал после растворения старого
          try { old.dispose && old.dispose(); } catch {}
          tileMesh.material = newMaterial; tileMesh.material.needsUpdate = true;
        }});
      } catch {
        // Фоллбек: мгновенная замена
        tileMesh.material = newMaterial; tileMesh.material.needsUpdate = true;
      }
    }
    // Кроссфейд между старым и новым материалом: старая текстура плавно растворяется, новая проявляется
    function dissolveTileCrossfade(tileMesh, oldMaterial, newMaterial, durationSec = 0.9) {
      try {
        if (!tileMesh || !oldMaterial || !newMaterial) return dissolveTileSwap(tileMesh, newMaterial, durationSec);
        const geom = tileMesh.geometry;
        const group = new THREE.Group();
        group.position.copy(tileMesh.position);
        group.rotation.copy(tileMesh.rotation);
        group.scale.copy(tileMesh.scale);
        const oldMesh = new THREE.Mesh(geom.clone(), oldMaterial.clone());
        const newMesh = new THREE.Mesh(geom.clone(), newMaterial.clone());
        (boardGroup || scene).add(group);
        group.add(oldMesh); group.add(newMesh);
        // подготовка прозрачности
        oldMesh.material.transparent = true; newMesh.material.transparent = true;
        oldMesh.material.depthWrite = false; newMesh.material.depthWrite = false;
        oldMesh.material.opacity = 1.0; newMesh.material.opacity = 0.0;
        // запустить анимацию
        const tl = gsap.timeline({ onComplete: () => {
          try { tileMesh.material = newMaterial; tileMesh.material.needsUpdate = true; } catch {}
          try { (boardGroup || scene).remove(group); } catch {}
        }});
        tl.to(oldMesh.material, { opacity: 0.0, duration: Math.max(0.4, durationSec), ease: 'power1.inOut' }, 0)
          .to(newMesh.material, { opacity: 1.0, duration: Math.max(0.4, durationSec), ease: 'power1.inOut' }, 0);
      } catch {
        dissolveTileSwap(tileMesh, newMaterial, durationSec);
      }
    }

    function performMagicAttack(from, targetMesh) {
      const tr = targetMesh.userData.row; const tc = targetMesh.userData.col;
      const res = magicAttack(gameState, from.r, from.c, tr, tc);
      if (!res) { showNotification('Incorrect target', 'error'); return; }
      // Не обновляем состояние немедленно, чтобы дать пройти анимации смерти
      for (const l of res.logLines.reverse()) addLog(l);
      const aMesh = unitMeshes.find(m => m.userData.row === from.r && m.userData.col === from.c);
      if (aMesh) { gsap.fromTo(aMesh.position, { y: aMesh.position.y }, { y: aMesh.position.y + 0.3, yoyo: true, repeat: 1, duration: 0.12 }); }
      // вспышка по цели
      const tMesh = unitMeshes.find(m => m.userData.row === tr && m.userData.col === tc);
      if (tMesh) {
        const flashGeom = new THREE.SphereGeometry(0.25, 12, 12);
        const flashMat = new THREE.MeshBasicMaterial({ color: 0xff6666, transparent: true, opacity: 0.8 });
        const flash = new THREE.Mesh(flashGeom, flashMat);
        flash.position.copy(tMesh.position).add(new THREE.Vector3(0, 0.4, 0));
        effectsGroup.add(flash);
        gsap.to(flash.scale, { x: 2, y: 2, z: 2, duration: 0.3 });
        gsap.to(flash.material, { opacity: 0, duration: 0.3, onComplete: ()=> effectsGroup.remove(flash) });
        // тряска цели и всплывающий урон для магии
        shakeMesh(tMesh, 6, 0.12);
        if (typeof res.dmg === 'number' && res.dmg > 0) {
          spawnDamageText(tMesh, `-${res.dmg}`, '#ff5555');
        }
      }
      // Манасфера и кладбище для погибших от магии; откладываем перерисовку до конца дизолва
      if (res.deaths && res.deaths.length) {
        for (const d of res.deaths) {
          try { gameState.players[d.owner].graveyard.push(CARDS[d.tplId]); } catch {}
          const deadMesh = unitMeshes.find(m => m.userData.row === d.r && m.userData.col === d.c);
          if (deadMesh) { dissolveAndAsh(deadMesh, new THREE.Vector3(0, 0, 0.6), 0.9); }
          // Орб маны появляется с задержкой 400мс после начала анимации смерти
          setTimeout(() => {
            const p = tileMeshes[d.r][d.c].position.clone().add(new THREE.Vector3(0, 1.2, 0));
            // Только визуальный орб; фактическое начисление — в res.n1
            animateManaGainFromWorld(p, d.owner, true);
          }, 400);
        }
        setTimeout(() => {
          gameState = res.n1; updateUnits(); updateUI();
          const attacker = gameState.board[from.r][from.c] && gameState.board[from.r][from.c].unit; if (attacker) attacker.lastAttackTurn = gameState.turn;
          try { schedulePush('magic-battle-finish'); } catch {}
        }, 1000);
      } else {
        // Если смертей нет — применяем состояние сразу
        gameState = res.n1; updateUnits(); updateUI();
        const attacker = gameState.board[from.r][from.c] && gameState.board[from.r][from.c].unit; if (attacker) attacker.lastAttackTurn = gameState.turn;
        try { schedulePush('magic-battle-finish'); } catch {}
      }
    }
    // Вспомогательные утилиты: задержка и яркая заставка BATTLE на 3 секунды
    function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
    async function showBattleSplash() {
      splashActive = true; refreshInputLockUI();
      const bb = document.getElementById('battle-banner');
      if (!bb) { splashActive = false; refreshInputLockUI(); return; }
      bb.innerHTML = '';
      const wrap = document.createElement('div'); wrap.className = 'ts-wrap';
      const bg = document.createElement('div'); bg.className = 'ts-bg'; wrap.appendChild(bg);
      const ringOuter = document.createElement('div'); ringOuter.className = 'ts-ring thin'; wrap.appendChild(ringOuter);
      const ringInner = document.createElement('div'); ringInner.className = 'ts-ring'; wrap.appendChild(ringInner);
      const streaks = document.createElement('div'); streaks.className = 'ts-streaks'; wrap.appendChild(streaks);
      const txt = document.createElement('div'); txt.className = 'ts-title ts-title-solid text-6xl md:text-8xl'; txt.textContent = 'BATTLE'; wrap.appendChild(txt);
      const scan = document.createElement('div'); scan.className = 'ts-scan'; wrap.appendChild(scan);
      bb.appendChild(wrap);
      bb.style.display = 'flex'; bb.classList.remove('hidden'); bb.classList.add('flex');
      const tl = gsap.timeline();
      tl.set(txt, { scale: 0.65, opacity: 0 })
        .set(ringOuter, { scale: 0.8, opacity: 0 })
        .set(ringInner, { scale: 0.5, opacity: 0 })
        .fromTo(bg, { opacity: 0 }, { opacity: 0.6, duration: 0.126, ease: 'power2.out' }, 0)
        .to(ringOuter, { opacity: 1, scale: 1.0, duration: 0.196, ease: 'back.out(2.2)' }, 0.014)
        .to(ringInner, { opacity: 1, scale: 1.0, duration: 0.224, ease: 'back.out(2.2)' }, 0.042)
        .to(txt, { opacity: 1, scale: 1.08, duration: 0.252, ease: 'back.out(1.9)' }, 0.056)
        .to(txt, { scale: 1.0, duration: 0.154, ease: 'power2.out' })
        .to(scan, { yPercent: 200, duration: 0.49, ease: 'power1.inOut' }, 0.084)
        .to(streaks, { opacity: 0.25, duration: 0.35 }, 0.14)
        .to([ringOuter, ringInner], { opacity: 0.9, duration: 0.14 }, 0.315)
        .to([bg, streaks], { opacity: 0.12, duration: 0.266 }, 0.406)
        .to([txt, ringOuter, ringInner], { opacity: 0, duration: 0.196, ease: 'power2.in' }, 1.134)
        .to(bb, { opacity: 0, duration: 0.14, ease: 'power2.in' }, 1.19);
      await sleep(1330);
      bb.classList.add('hidden'); bb.classList.remove('flex'); bb.style.display = 'none';
      bb.style.opacity = '';
      bb.innerHTML = '';
      splashActive = false; refreshInputLockUI();
    }

    async function showTurnSplash(title) {
      splashActive = true; refreshInputLockUI();
      const tb = document.getElementById('turn-banner');
      if (!tb) { splashActive = false; refreshInputLockUI(); return; }
      tb.innerHTML = '';
      // Разметка нового экрана
      const wrap = document.createElement('div'); wrap.className = 'ts-wrap';
      const bg = document.createElement('div'); bg.className = 'ts-bg'; wrap.appendChild(bg);
      const ringOuter = document.createElement('div'); ringOuter.className = 'ts-ring thin'; wrap.appendChild(ringOuter);
      const ringInner = document.createElement('div'); ringInner.className = 'ts-ring'; wrap.appendChild(ringInner);
      const streaks = document.createElement('div'); streaks.className = 'ts-streaks'; wrap.appendChild(streaks);
      const txt = document.createElement('div'); txt.className = 'ts-title ts-title-solid text-4xl md:text-6xl'; txt.textContent = title; wrap.appendChild(txt);
      const scan = document.createElement('div'); scan.className = 'ts-scan'; wrap.appendChild(scan);
      tb.appendChild(wrap);
      tb.style.display = 'flex'; tb.classList.remove('hidden'); tb.classList.add('flex');
      // Анимации (ускорены на 30%)
      const tl = gsap.timeline();
      tl.set(txt, { scale: 0.65, opacity: 0 })
        .set(ringOuter, { scale: 0.8, opacity: 0 })
        .set(ringInner, { scale: 0.5, opacity: 0 })
        .fromTo(bg, { opacity: 0 }, { opacity: 0.6, duration: 0.126, ease: 'power2.out' }, 0)
        .to(ringOuter, { opacity: 1, scale: 1.0, duration: 0.196, ease: 'back.out(2.2)' }, 0.014)
        .to(ringInner, { opacity: 1, scale: 1.0, duration: 0.224, ease: 'back.out(2.2)' }, 0.042)
        .to(txt, { opacity: 1, scale: 1.08, duration: 0.252, ease: 'back.out(1.9)' }, 0.056)
        .to(txt, { scale: 1.0, duration: 0.154, ease: 'power2.out' })
        .to(scan, { yPercent: 200, duration: 0.49, ease: 'power1.inOut' }, 0.084)
        .to(streaks, { opacity: 0.25, duration: 0.35 }, 0.14)
        .to([ringOuter, ringInner], { opacity: 0.9, duration: 0.14 }, 0.315)
        .to([bg, streaks], { opacity: 0.12, duration: 0.266 }, 0.406)
        .to([txt, ringOuter, ringInner], { opacity: 0, duration: 0.196, ease: 'power2.in' }, 1.134)
        .to(tb, { opacity: 0, duration: 0.14, ease: 'power2.in' }, 1.19);
      await sleep(1330);
      tb.classList.add('hidden'); tb.classList.remove('flex'); tb.style.display = 'none';
      tb.style.opacity = '';
      tb.innerHTML = '';
      splashActive = false; refreshInputLockUI();
      try {
        lastSplashTurnShown = (gameState?.turn || lastSplashTurnShown);
      } catch {}
    }
    
    function castSpellOnUnit(cardMesh, unitMesh) {
      const idx = cardMesh.userData.handIndex;
      const pl = gameState.players[gameState.active];
      if (idx == null || idx < 0 || idx >= pl.hand.length) { resetCardSelection(); return; }
      const tpl = pl.hand[idx]; if (!tpl || tpl.type !== 'SPELL') { resetCardSelection(); return; }
      if (tpl.cost > pl.mana) { showNotification('Insufficient mana', 'error'); resetCardSelection(); return; }
      const r = unitMesh.userData.row; const c = unitMesh.userData.col; const u = gameState.board[r][c].unit;
      let delayedApply = false;
      // Новые спеллы
      if (tpl.id === 'SPELL_BEGUILING_FOG') {
        // Разрешаем поворот любой цели в любую сторону — спросим направление через панель ориентации
        pendingSpellOrientation = { spellCardMesh: cardMesh, unitMesh };
        addLog(`${tpl.name}: выберите направление для цели.`);
        // Временно покажем панель и перехватим её клики (см. обработчик ниже)
        showOrientationPanel();
        return; // завершим, остальная логика применения выполнится после выбора направления
      }
      if (tpl.id === 'SPELL_CLARE_WILS_BANNER') {
        if (!u || u.owner !== gameState.active) { showNotification('Target: friendly unit', 'error'); return; }
        // Применяем временный баф атаки до конца хода кастера
        u.tempAtkBuff = (u.tempAtkBuff || 0) + 2;
        u.tempBuffOwner = gameState.active;
        addLog(`${tpl.name}: ${CARDS[u.tplId].name} получает +2 ATK до конца хода.`);
        const tMesh = unitMeshes.find(m => m.userData.row === r && m.userData.col === c);
        if (tMesh) {
          spawnDamageText(tMesh, `+2`, '#22c55e');
          // Шейдерная вспышка вокруг цели
          try {
            const ring = new THREE.Mesh(new THREE.RingGeometry(0.5, 0.8, 48), new THREE.MeshBasicMaterial({ color: 0x22c55e, transparent: true, opacity: 0.0 }));
            ring.rotation.x = -Math.PI/2; ring.position.copy(tMesh.position).add(new THREE.Vector3(0, 0.32, 0));
            effectsGroup.add(ring);
            gsap.to(ring.material, { opacity: 0.8, duration: 0.12 })
              .then(() => gsap.to(ring.scale, { x: 2.5, y: 2.5, z: 2.5, duration: 0.4, ease: 'power2.out' }))
              .then(() => gsap.to(ring.material, { opacity: 0, duration: 0.24, onComplete: ()=> effectsGroup.remove(ring) }));
          } catch {}
        }
        pl.mana -= tpl.cost; pl.discard.push(tpl); pl.hand.splice(idx, 1);
        resetCardSelection(); updateHand(); updateUnits(); updateUI();
        return;
      }
      if (tpl.id === 'SPELL_SUMMONER_MESMERS_ERRAND') {
        // Добор двух карт с существующей анимацией
        if (tpl.cost > pl.mana) { showNotification('Insufficient mana', 'error'); resetCardSelection(); return; }
        pl.mana -= tpl.cost;
        (async () => {
          for (let i = 0; i < 2; i++) {
            const drawnTpl = drawOneNoAdd(gameState, gameState.active);
            if (drawnTpl) {
              refreshInputLockUI();
              await animateDrawnCardToHand(drawnTpl);
              try { gameState.players[gameState.active].hand.push(drawnTpl); } catch {}
              updateHand();
            }
          }
          addLog(`${tpl.name}: вы добираете 2 карты.`);
          pl.discard.push(tpl); pl.hand.splice(idx, 1); updateUI();
        })();
        resetCardSelection();
        return;
      }
      if (tpl.id === 'SPELL_GOGHLIE_ALTAR') {
        // Оба игрока получают ману = числу вражеских существ на доске
        const countUnits = (ownerIdx) => {
          let n = 0; for (let rr = 0; rr < 3; rr++) for (let cc = 0; cc < 3; cc++) {
            const un = gameState.board[rr][cc].unit; if (un && un.owner !== ownerIdx) n++;
          } return n;
        };
        const g0 = countUnits(0), g1 = countUnits(1);
        gameState.players[0].mana = capMana(gameState.players[0].mana + g0);
        gameState.players[1].mana = capMana(gameState.players[1].mana + g1);
        // Визуальный эффект: вспышки энергии от всех вражеских юнитов к панели маны получателя
        for (let rr = 0; rr < 3; rr++) for (let cc = 0; cc < 3; cc++) {
          const un = gameState.board[rr][cc].unit; if (!un) continue;
          const pos = tileMeshes[rr][cc].position.clone().add(new THREE.Vector3(0, 1.2, 0));
          animateManaGainFromWorld(pos, (un.owner === 0 ? 1 : 0));
        }
        addLog(`${tpl.name}: оба игрока получают ману от вражеских существ (P1 +${g0}, P2 +${g1}).`);
        pl.mana -= tpl.cost; pl.discard.push(tpl); pl.hand.splice(idx, 1);
        resetCardSelection(); updateHand(); updateUI();
        return;
      }
      if (tpl.id === 'SPELL_PARMTETIC_HOLY_FEAST') {
        // Ритуал: требуется сбросить существо из руки -> применить анимацию dissolve для выбранной карты из руки
        const handCreatures = pl.hand.filter(x => x && x.type === 'UNIT');
        if (handCreatures.length === 0) { showNotification('No units available', 'error'); return; }
        console.log('[HF:setup] Setting up pendingDiscardSelection for Holy Feast (castSpellOnUnit)');
        pendingDiscardSelection = {
          requiredType: 'UNIT',
          onPicked: (handIdx) => {
            console.log('[HF:onPicked] Called onPicked (castSpellOnUnit)', { handIdx, NET_ACTIVE: typeof NET_ACTIVE !== 'undefined' ? NET_ACTIVE : 'undefined' });
            const toDiscardTpl = pl.hand[handIdx]; if (!toDiscardTpl) return;
            const localSpellIdx = pl.hand.indexOf(tpl);
            // В онлайне не мутируем руку локально — только визуально скрываем выбранные карты и шлём команду с индексами ДО удаления
            try { if (typeof NET_ACTIVE !== 'undefined' ? NET_ACTIVE : false) { PENDING_HIDE_HAND_CARDS = Array.from(new Set([handIdx, localSpellIdx])).filter(i=>i>=0); } } catch {}
            // Поднимем 3D-карту из руки и прожжём её через dissolve (визуально)
            const handMesh = handCardMeshes.find(m => m.userData?.handIndex === handIdx);
            if (handMesh) { try { handMesh.userData.isInHand = false; } catch {} dissolveAndAsh(handMesh, new THREE.Vector3(0, 0.6, 0), 0.9); }
            if (typeof NET_ACTIVE !== 'undefined' ? NET_ACTIVE : false) {
              try { if (typeof window !== 'undefined' && window.socket) window.socket.emit('holyFeast', { seat: gameState.active, spellIdx: localSpellIdx, creatureIdx: handIdx }); } catch {}
              // Закрываем prompt и очищаем выбор, чтобы не зависала панель
              hidePrompt(); pendingDiscardSelection = null;
              resetCardSelection(); updateHand(); updateUI();
            } else {
              // Оффлайн: применяем сразу локально
              try { pl.graveyard.push(toDiscardTpl); } catch {}
              pl.hand.splice(handIdx, 1);
              updateHand();
              pl.mana = capMana(pl.mana + 2); updateUI();
              addLog(`${tpl.name}: сбрасываете существо из руки и получаете +2 маны (\`${toDiscardTpl.name}\`).`);
              pl.mana = capMana(pl.mana - (tpl.cost || 0));
              const spellIdx2 = pl.hand.indexOf(tpl); if (spellIdx2 >= 0) { pl.hand.splice(spellIdx2, 1); }
              pl.discard.push(tpl);
              resetCardSelection(); updateHand(); updateUI();
              schedulePush('spell-holy-feast', { force: true });
            }
          }
        };
        addLog(`${tpl.name}: выберите существо в руке для ритуального сброса.`);
        // Подсветить руку не будем — выбор по клику на карте из руки (см. перехват в onMouseDown)
        return;
      }
      if (tpl.id === 'WIND_SHIFT') { if (u) u.facing = turnCW[u.facing]; addLog(`${tpl.name}: ${CARDS[u.tplId].name} повёрнут.`); }
      if (tpl.id === 'FREEZE_STREAM') {
        if (u) {
          const before = u.currentHP; u.currentHP = Math.max(0, u.currentHP - 1);
          addLog(`${tpl.name}: ${CARDS[u.tplId].name} получает 1 урона (HP ${before}→${u.currentHP})`);
          try { const tMesh = unitMeshes.find(m => m.userData.row === r && m.userData.col === c); if (tMesh) spawnDamageText(tMesh, `-1`, '#ef4444'); } catch {}
          if (u.currentHP <= 0) {
            delayedApply = true;
            const owner = u.owner;
            try { gameState.players[owner].graveyard.push(CARDS[u.tplId]); } catch {}
            const pos = tileMeshes[r][c].position.clone().add(new THREE.Vector3(0,1.2,0));
            animateManaGainFromWorld(pos, owner);
            // Запускаем дизолв на текущем меше цели
            if (unitMesh) { dissolveAndAsh(unitMesh, new THREE.Vector3(0,0,0.6), 0.9); }
            // Отложим удаление из доски до завершения анимации
            setTimeout(() => { gameState.board[r][c].unit = null; updateUnits(); updateUI(); }, 1000);
          }
        }
      }
      if (tpl.id === 'RAISE_STONE') {
        if (!u) { showNotification('Need to drag this card to a unit', 'error'); return; }
        if (u.owner !== gameState.active) { showNotification('Only friendly unit', 'error'); return; }
        const before = u.currentHP; u.currentHP += 2; addLog(`${tpl.name}: ${CARDS[u.tplId].name} получает +2 HP (HP ${before}→${u.currentHP})`);
        try { const tMesh = unitMeshes.find(m => m.userData.row === r && m.userData.col === c); if (tMesh) spawnDamageText(tMesh, `+2`, '#22c55e'); } catch {}
      }
      pl.mana -= tpl.cost; pl.discard.push(tpl); pl.hand.splice(idx, 1);
      resetCardSelection(); updateHand();
      if (!delayedApply) { updateUnits(); updateUI(); }
    }

    // Новый универсальный обработчик каста спелла при перетаскивании
    function castSpellByDrag(cardMesh, unitMesh, tileMesh) {
      const idx = cardMesh.userData.handIndex;
      const pl = gameState.players[gameState.active];
      if (idx == null || idx < 0 || idx >= pl.hand.length) { return; }
      const tpl = pl.hand[idx]; if (!tpl || tpl.type !== 'SPELL') { return; }
      if (tpl.cost > pl.mana) { showNotification('Insufficient mana', 'error'); return; }
      // Для спеллов без цели — позволяем дроп на любую клетку поля
      const id = tpl.id;
      const requiresUnitTarget = (/*'FREEZE_STREAM' removed*/ id === 'RAISE_STONE' || /*'WIND_SHIFT' removed*/ id === 'SPELL_BEGUILING_FOG' || id === 'SPELL_CLARE_WILS_BANNER');
      if (requiresUnitTarget) {
        if (!unitMesh) { showNotification('Drag this card on a unit', 'error'); return; }
        // Спецэффект баффа/дебаффа перед применением
        try {
          const glow = new THREE.Mesh(new THREE.RingGeometry(0.4, 0.6, 32), new THREE.MeshBasicMaterial({ color: 0x22c55e, transparent: true, opacity: 0.0 }));
          glow.rotation.x = -Math.PI/2; glow.position.copy(unitMesh.position).add(new THREE.Vector3(0, 0.3, 0));
          effectsGroup.add(glow);
          gsap.to(glow.material, { opacity: 0.8, duration: 0.12 })
            .then(() => gsap.to(glow.scale, { x: 2.2, y: 2.2, z: 2.2, duration: 0.35, ease: 'power1.out' }))
            .then(() => gsap.to(glow.material, { opacity: 0, duration: 0.28, onComplete: ()=> effectsGroup.remove(glow) }));
        } catch {}
        return castSpellOnUnit(cardMesh, unitMesh);
      }
      // Спеллы без цели
      if (id === 'SPELL_SUMMONER_MESMERS_ERRAND') {
        // Добор двух карт
        if (tpl.cost > pl.mana) { showNotification('Insuffcient mana', 'error'); return; }
        pl.mana -= tpl.cost;
        // Немедленно «сожжём» карту спелла на месте броска и пометим, что карту не надо возвращать в руку
        try {
          const big = createCard3D(tpl, false);
          const p = tileMesh ? tileMesh.position.clone().add(new THREE.Vector3(0, 1.0, 0)) : new THREE.Vector3(0, 1.0, 0);
          big.position.copy(p);
          (boardGroup || scene).add(big);
          dissolveAndAsh(big, new THREE.Vector3(0, 0.6, 0), 0.9);
          spellDragHandled = true;
          // Скрыть перетягиваемую карту, чтобы не мигала
          try { cardMesh.visible = false; } catch {}
        } catch {}
        // Удалить из руки и положить в сброс сразу, затем анимировать добор 2 карт
        pl.hand.splice(idx, 1); pl.discard.push(tpl); updateHand(); updateUI();
        (async () => {
          for (let i = 0; i < 2; i++) {
            const drawnTpl = drawOneNoAdd(gameState, gameState.active);
            if (drawnTpl) {
              refreshInputLockUI();
              await animateDrawnCardToHand(drawnTpl);
              try { gameState.players[gameState.active].hand.push(drawnTpl); } catch {}
              updateHand();
            }
          }
          addLog(`${tpl.name}: вы добираете 2 карты.`);
        })();
        return;
      }
      if (id === 'SPELL_GOGHLIE_ALTAR') {
        const countUnits = (ownerIdx) => { let n = 0; for (let rr = 0; rr < 3; rr++) for (let cc = 0; cc < 3; cc++) { const un = gameState.board[rr][cc].unit; if (un && un.owner !== ownerIdx) n++; } return n; };
        const g0 = countUnits(0), g1 = countUnits(1);
        gameState.players[0].mana = capMana(gameState.players[0].mana + g0);
        gameState.players[1].mana = capMana(gameState.players[1].mana + g1);
        for (let rr = 0; rr < 3; rr++) for (let cc = 0; cc < 3; cc++) { const un = gameState.board[rr][cc].unit; if (!un) continue; const pos = tileMeshes[rr][cc].position.clone().add(new THREE.Vector3(0, 1.2, 0)); animateManaGainFromWorld(pos, (un.owner === 0 ? 1 : 0)); }
        addLog(`${tpl.name}: оба игрока получают ману от вражеских существ (P1 +${g0}, P2 +${g1}).`);
        // Визуально сожжём карту спелла в точке дропа
        try {
          const big = createCard3D(tpl, false);
          const p = tileMesh ? tileMesh.position.clone().add(new THREE.Vector3(0, 1.0, 0)) : new THREE.Vector3(0, 1.0, 0);
          big.position.copy(p);
          (boardGroup || scene).add(big);
          dissolveAndAsh(big, new THREE.Vector3(0, 0.6, 0), 0.9);
          spellDragHandled = true;
        } catch {}
        pl.mana -= tpl.cost; pl.discard.push(tpl); pl.hand.splice(idx, 1);
        updateHand(); updateUI();
        return;
      }
      if (id === 'SPELL_FISSURES_OF_GOGHLIE') {
        if (!tileMesh) { showNotification('Drag this card to a board cell', 'error'); return; }
        const r = tileMesh.userData.row, c = tileMesh.userData.col;
        const cell = gameState.board[r][c];
        if (!cell) return;
        if (cell.element === 'MECH') { showNotification('This cell can\'t be changed', 'error'); return; }
        const oppMap = { FIRE:'WATER', WATER:'FIRE', EARTH:'FOREST', FOREST:'EARTH' };
        const prevEl = cell.element; const nextEl = oppMap[prevEl] || prevEl;
        cell.element = nextEl;
        // Визуальный «fieldquake»: шейдерное сгорание старого тайла и замена материала на противоположный
        try {
          const tile = tileMeshes[r][c];
          const mat = getTileMaterial(nextEl);
          dissolveTileCrossfade(tile, getTileMaterial(prevEl), mat, 0.9);
          // Онлайновая синхронизация эффекта
          try { if (NET_ON() && MY_SEAT === gameState.active && typeof window !== 'undefined' && window.socket) window.socket.emit('tileCrossfade', { r, c, prev: prevEl, next: nextEl }); } catch {}
        } catch {}
        // Юнит на клетке может изменить HP из-за смены элемента
        const u = gameState.board[r][c].unit;
        if (u) {
          const tpl = CARDS[u.tplId];
          const prevBuff = computeCellBuff(prevEl, tpl.element);
          const nextBuff = computeCellBuff(nextEl, tpl.element);
          const deltaHp = (nextBuff.hp || 0) - (prevBuff.hp || 0);
          if (deltaHp !== 0) {
            const before = u.currentHP; u.currentHP = Math.max(0, before + deltaHp);
            const tMesh = unitMeshes.find(m => m.userData.row === r && m.userData.col === c);
            if (tMesh) spawnDamageText(tMesh, `${deltaHp > 0 ? '+' : ''}${deltaHp}`, deltaHp > 0 ? '#22c55e' : '#ef4444');
            if (u.currentHP <= 0) {
              try { gameState.players[u.owner].graveyard.push(CARDS[u.tplId]); } catch {}
              const deadMesh = unitMeshes.find(m => m.userData.row === r && m.userData.col === c);
              if (deadMesh) { dissolveAndAsh(deadMesh, new THREE.Vector3(0,0,0.6), 0.9); setTimeout(()=>{ gameState.board[r][c].unit = null; updateUnits(); updateUI(); }, 1000); }
            }
          }
        }
        // Визуально «сжечь» карту спелла в точке дропа и убрать из руки
        try {
          const big = createCard3D(tpl, false);
          const p = tileMesh.position.clone().add(new THREE.Vector3(0, 1.0, 0));
          big.position.copy(p); (boardGroup || scene).add(big); dissolveAndAsh(big, new THREE.Vector3(0,0.6,0), 0.9);
          spellDragHandled = true;
        } catch {}
        pl.mana -= tpl.cost; pl.discard.push(tpl); pl.hand.splice(idx, 1);
        updateHand(); updateUnits(); updateUI();
        return;
      }
      if (id === 'SPELL_PARMTETIC_HOLY_FEAST') {
        const handCreatures = pl.hand.filter(x => x && x.type === 'UNIT');
        if (handCreatures.length === 0) { showNotification('No unit in hand for this action', 'error'); return; }
        // Визуально «оставим» карту на поле: создаём временный меш спелла и не возвращаем перетянутую карту
        try {
          const big = createCard3D(tpl, false);
          const p = tileMesh ? tileMesh.position.clone().add(new THREE.Vector3(0, 1.0, 0)) : new THREE.Vector3(0, 1.0, 0);
          big.position.copy(p);
          (boardGroup || scene).add(big);
          pendingRitualBoardMesh = big;
          spellDragHandled = true;
          // Спрячем перетягиваемую карту на время ритуала, чтобы не дублировалась в руке
          try { cardMesh.visible = false; } catch {}
          // Запомним индекс текущего спелла в руке
          pendingRitualSpellHandIndex = idx;
          pendingRitualSpellCard = tpl;
        } catch {}
        console.log('[HF:drag] Showing prompt for Holy Feast drag to field');
        showPrompt('Select a unit for this action', () => {
          // Отмена ритуала — убрать временный меш и показать карту-спелл, без возврата в руку
          console.log('[HF:drag] Canceling Holy Feast ritual');
          try { if (pendingRitualBoardMesh && pendingRitualBoardMesh.parent) pendingRitualBoardMesh.parent.remove(pendingRitualBoardMesh); } catch {}
          pendingRitualBoardMesh = null;
          try { cardMesh.visible = true; } catch {}
          pendingRitualSpellHandIndex = null; pendingRitualSpellCard = null; updateHand();
          pendingDiscardSelection = null;
        });
        // Если карт несколько — ждём клика по карте в руке
        if (handCreatures.length > 1) {
          console.log('[HF:setup] Setting up pendingDiscardSelection for Holy Feast (handleSpellDrop)');
          pendingDiscardSelection = { requiredType: 'UNIT', onPicked: (handIdx) => {
            console.log('[HF:onPicked] Called onPicked (handleSpellDrop)', { handIdx, NET_ACTIVE });
            const toDiscardTpl = pl.hand[handIdx]; if (!toDiscardTpl) return;
            const localSpellIdx = (pendingRitualSpellHandIndex != null) ? pendingRitualSpellHandIndex : pl.hand.indexOf(tpl);
            try { if (typeof NET_ACTIVE !== 'undefined' ? NET_ACTIVE : false) { PENDING_HIDE_HAND_CARDS = Array.from(new Set([handIdx, localSpellIdx])).filter(i=>i>=0); } } catch {}
            const handMesh = handCardMeshes.find(m => m.userData?.handIndex === handIdx);
            if (handMesh) { try { handMesh.userData.isInHand = false; } catch {} dissolveAndAsh(handMesh, new THREE.Vector3(0, 0.6, 0), 0.9); }
            if (typeof NET_ACTIVE !== 'undefined' ? NET_ACTIVE : false) {
              try { if (typeof window !== 'undefined') window.__HF_ACK = false; } catch {}
              try { if (typeof window !== 'undefined' && window.socket) window.socket.emit('debugLog', { tag:'HF:onPicked', phase:'emit', localSpellIdx, handIdx, active: gameState.active }); } catch {}
              try { if (pendingRitualBoardMesh) { dissolveAndAsh(pendingRitualBoardMesh, new THREE.Vector3(0,0.6,0), 0.9); setTimeout(()=>{ try { pendingRitualBoardMesh.parent.remove(pendingRitualBoardMesh); } catch {} pendingRitualBoardMesh = null; }, 950); } } catch {}
              try { if (typeof window !== 'undefined' && window.socket) window.socket.emit('holyFeast', { seat: gameState.active, spellIdx: localSpellIdx, creatureIdx: handIdx }); } catch {}
              // Повторная отправка через 350мс, если сервер не ответил
              setTimeout(()=>{ try { if (typeof window !== 'undefined' && !window.__HF_ACK && window.socket) window.socket.emit('holyFeast', { seat: gameState.active, spellIdx: localSpellIdx, creatureIdx: handIdx }); } catch {} }, 350);
              pendingRitualSpellHandIndex = null; pendingRitualSpellCard = null;
              // Закроем prompt немедленно, чтобы не зависал UI
              console.log('[HF:onPicked] Hiding prompt and clearing selection (online)');
              hidePrompt(); pendingDiscardSelection = null;
              updateHand(); updateUI();
            } else {
              console.log('[HF:onPicked] Processing offline (handleSpellDrop)');
              try { pl.graveyard.push(toDiscardTpl); } catch {}
              pl.hand.splice(handIdx, 1); updateHand();
              pl.mana = capMana(pl.mana + 2); addLog(`${tpl.name}: ритуал — +2 маны.`);
              try { if (pendingRitualBoardMesh) { dissolveAndAsh(pendingRitualBoardMesh, new THREE.Vector3(0,0.6,0), 0.9); setTimeout(()=>{ try { pendingRitualBoardMesh.parent.remove(pendingRitualBoardMesh); } catch {} pendingRitualBoardMesh = null; }, 950); } } catch {}
              let spellIdx = localSpellIdx; if (spellIdx >= 0) { pl.hand.splice(spellIdx, 1); }
              pendingRitualSpellHandIndex = null; pendingRitualSpellCard = null;
              console.log('[HF:onPicked] Hiding prompt and clearing selection (offline)');
              pendingDiscardSelection = null;
              hidePrompt();
              pl.discard.push(tpl); updateHand(); updateUI();
              schedulePush('spell-holy-feast', { force: true });
            }
          } }; addLog(`${tpl.name}: выберите существо в руке для ритуального сброса.`);
          // Доп. страховка: если по какой-то причине ритуал не завершился за 3 секунды — сбросить выбор
          setTimeout(()=>{ try { if (pendingDiscardSelection) { hidePrompt(); pendingDiscardSelection = null; updateHand(); updateUI(); } } catch {} }, 3000);
          return;
        }
        // Если ровно одна карта-сущность — сбрасываем её сразу
        const singleIdx = pl.hand.findIndex(x => x && x.type === 'UNIT');
        if (singleIdx >= 0) {
          const toDiscardTpl = pl.hand[singleIdx];
          const handMesh = handCardMeshes.find(m => m.userData?.handIndex === singleIdx);
          const localSpellIdx = (pendingRitualSpellHandIndex != null) ? pendingRitualSpellHandIndex : pl.hand.indexOf(tpl);
          try { if (NET_ON()) { PENDING_HIDE_HAND_CARDS = Array.from(new Set([singleIdx, localSpellIdx])).filter(i=>i>=0); } } catch {}
          if (handMesh) { try { handMesh.userData.isInHand = false; } catch {} dissolveAndAsh(handMesh, new THREE.Vector3(0, 0.6, 0), 0.9); }
          if (NET_ON()) {
            try { if (typeof window !== 'undefined') window.__HF_ACK = false; } catch {}
            try { if (typeof window !== 'undefined' && window.socket) window.socket.emit('debugLog', { tag:'HF:single', phase:'emit', localSpellIdx, singleIdx, active: gameState.active }); } catch {}
            try { if (pendingRitualBoardMesh) { dissolveAndAsh(pendingRitualBoardMesh, new THREE.Vector3(0,0.6,0), 0.9); setTimeout(()=>{ try { pendingRitualBoardMesh.parent.remove(pendingRitualBoardMesh); } catch {} pendingRitualBoardMesh = null; }, 950); } } catch {}
            try { if (typeof window !== 'undefined' && window.socket) window.socket.emit('ritualResolve', { kind:'HOLY_FEAST', by: gameState.active, card: tpl.id, consumed: toDiscardTpl.id }); } catch {}
            try { if (typeof window !== 'undefined' && window.socket) window.socket.emit('holyFeast', { seat: gameState.active, spellIdx: localSpellIdx, creatureIdx: singleIdx }); } catch {}
            setTimeout(()=>{ try { if (typeof window !== 'undefined' && !window.__HF_ACK && window.socket) window.socket.emit('holyFeast', { seat: gameState.active, spellIdx: localSpellIdx, creatureIdx: singleIdx }); } catch {} }, 350);
            pendingRitualSpellHandIndex = null; pendingRitualSpellCard = null;
            hidePrompt();
            updateHand(); updateUI();
          } else {
            try { pl.graveyard.push(toDiscardTpl); } catch {}
            pl.hand.splice(singleIdx, 1); updateHand();
            pl.mana = capMana(pl.mana + 2); addLog(`${tpl.name}: ритуал — +2 маны.`);
            try { if (pendingRitualBoardMesh) { dissolveAndAsh(pendingRitualBoardMesh, new THREE.Vector3(0,0.6,0), 0.9); setTimeout(()=>{ try { pendingRitualBoardMesh.parent.remove(pendingRitualBoardMesh); } catch {} pendingRitualBoardMesh = null; }, 950); } } catch {}
            let spellIdx = localSpellIdx; if (spellIdx >= 0) { pl.hand.splice(spellIdx, 1); }
                          pendingRitualSpellHandIndex = null; pendingRitualSpellCard = null;
              pendingDiscardSelection = null;
              pl.discard.push(tpl); updateHand(); updateUI(); hidePrompt();
              schedulePush('spell-holy-feast', { force: true });
          }
        }
        return;
      }
      // Если сюда попали — нераспознанная цель/спелл
      showNotification('Incorrect target', 'error');
    }

    // (убраны несуществующие обработчики magic-btn и draw-btn)
  </script>
<!-- серверный патч -->
<!-- === Multiplayer patch v2: sync + queue + countdown + lock input + indicator === --> 
<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
<script> 
(() => {
  // ===== 0) Config =====
  const SERVER_URL = (location.hostname === "localhost")
    ? "http://localhost:3001"
    : "https://eog-mp-server-production.up.railway.app"; // ← домен сервера

  // ===== 1) Styles =====
  const css = `
  .mp-modal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.5);z-index:9999}
  .mp-card{min-width:280px;padding:18px 20px;border-radius:12px;background:#0f172a;color:#e5e7eb;border:1px solid #334155;box-shadow:0 10px 30px rgba(0,0,0,.35);text-align:center}
  .mp-btn{display:inline-flex;gap:8px;align-items:center;justify-content:center;padding:6px 10px;border-radius:6px;cursor:pointer;background:#475569;color:#e5e7eb;border:1px solid rgba(255,255,255,0.1);font-size:12px}
  .mp-btn:hover{background:#64748b}
  .mp-subtle{color:#94a3b8;font-size:12px;margin-top:6px}
  .mp-spinner{width:16px;height:16px;border:2px solid #64748b;border-top-color:transparent;border-radius:50%;animation:mp-spin .8s linear infinite}
  @keyframes mp-spin{to{transform:rotate(360deg)}}
  .mp-count{font-weight:800;font-size:64px;letter-spacing:.03em;margin:8px 0 10px}
  .mp-seat{font-size:14px;color:#cbd5e1}
  .mp-floater{position:fixed;right:12px;bottom:12px;z-index:9998;display:flex;gap:8px}
  .mp-ind{position:fixed;left:12px;bottom:12px;z-index:9998;display:flex;align-items:center;gap:8px;background:rgba(15,23,42,.85);color:#e5e7eb;border:1px solid #334155;padding:6px 10px;border-radius:999px;font:12px/1.2 system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
  .mp-dot{width:8px;height:8px;border-radius:50%;background:#64748b;box-shadow:0 0 0 2px rgba(0,0,0,.3) inset}
  .mp-dot.on{background:#16a34a}
  .mp-tag{padding:2px 6px;border-radius:999px;background:#1f2937;border:1px solid #334155}
  .mp-lock{position:fixed;inset:0;z-index:9997;display:none;align-items:center;justify-content:center;pointer-events:auto;background:rgba(2,6,23,.35)}
  .mp-lock.on{display:flex}
  .mp-lock .mp-card{background:#0b1224cc}
  `;
  const st = document.createElement('style'); st.textContent = css; document.head.appendChild(st);

  // ===== 2) Кнопка «Онлайн-игра» — как стандартные overlay-кнопки рядом с остальными =====
  function mountOnlineButton() {
    if (document.getElementById('find-match-btn')) return;
    const btn = document.createElement('button');
    btn.id = 'find-match-btn';
    btn.className = 'overlay-panel px-3 py-1.5 text-xs bg-slate-600 hover:bg-slate-700 transition-colors';
    btn.textContent = 'Play Online';
    // Place inside the right-side control panel, next to other buttons
    const host = document.querySelector('#corner-right .flex') || document.getElementById('corner-right');
    if (host) {
      host.appendChild(btn);
    } else {
      // Fallback: if panel not yet mounted, use floater
      const wrap = document.getElementById('mp-floater') || (() => {
        const d = document.createElement('div'); d.id='mp-floater'; d.className='mp-floater'; document.body.appendChild(d); return d;
      })();
      wrap.appendChild(btn);
    }
    btn.addEventListener('click', onFindMatchClick);
  }
  mountOnlineButton();
  const mo = new MutationObserver(() => mountOnlineButton());
  mo.observe(document.body, { childList:true, subtree:true });

  // ===== 3) Queue modal + countdown =====
  let queueModal=null, startModal=null;
  function showQueueModal(){
    hideQueueModal();
    queueModal = document.createElement('div');
    queueModal.className='mp-modal';
    queueModal.innerHTML = `<div class="mp-card">
      <div style="display:flex;gap:10px;justify-content:center;align-items:center">
        <div class="mp-spinner"></div><div>Поиск матча…</div>
      </div><div class="mp-subtle">Ждём второго игрока</div></div>`;
    document.body.appendChild(queueModal);
  }
  function hideQueueModal(){ queueModal?.remove(); queueModal=null; }
  function showStartCountdown(seat, secs=3){
    hideStartCountdown();
    startModal = document.createElement('div');
    startModal.className='mp-modal';
    startModal.innerHTML = `<div class="mp-card">
      <div>Матч найден!</div>
      <div class="mp-seat">You play as: <b>${seat===0?'Player 1':'Player 2'}</b></div>
      <div class="mp-count" id="mp-count">${secs}</div>
      <div class="mp-subtle">Game is starting soon...</div></div>`;
    document.body.appendChild(startModal);
    let t=secs; const el=startModal.querySelector('#mp-count');
    const timer=setInterval(()=>{ t--; if(t<=0){ clearInterval(timer); hideStartCountdown(); onCountdownFinished(seat); } else el.textContent=t; },1000);
  }
  function hideStartCountdown(){ startModal?.remove(); startModal=null; }

  // ===== 4) Socket + sync =====
  const socket = io(SERVER_URL, { 
    transports: ['websocket', 'polling'],
    upgrade: true,
    rememberUpgrade: true,
    timeout: 20000,
    forceNew: true
  });
  try { window.socket = socket; } catch {}
  // NET_ACTIVE, MY_SEAT, APPLYING уже объявлены выше в глобальной области

  // --- SENDING: «обёртки» + DIGEST-пуллер ---
  const TO_WRAP = [
    // партия/ход
    'initGame','startGame','newGame','resetGame','endTurn','resign','setWinner',
    // колоды/руки
    'shuffleDeck','drawOne','drawCard','drawCards','dealCard','dealCards','discardCard','discardSelectedCard',
    // выбор/перетаскивание/цели
    'selectCard','deselectCard','resetCardSelection','onCardDropped','setTargetCell','setTargetUnit',
    // установка/направление
    'placeUnit','placeUnitWithDirection','rotateUnit','setFacing','setDirection',
    // бой/урон/смерть
    'performBattleSequence','stagedAttack','applyDamage','killUnit','removeUnit','reviveUnit',
    // контроль/победа
    'captureCell','changeOwner','checkWinCondition',
    // эффекты/ресурсы
    'castSpell','playSpell','applySpell','resolveSpell','applyEffect','removeEffect','spendMana','gainMana','updateMana',
    // UI триггеры
    'updateUI','updateUnits','updateHand','createBoard','createMetaObjects','addLog'
  ];
  const GATED = [
    'endTurn','placeUnit','placeUnitWithDirection','rotateUnit','performBattleSequence','stagedAttack',
    'applyDamage','killUnit','onCardDropped','castSpell','playSpell','resolveSpell','setTargetCell','setTargetUnit','setFacing','setDirection'
  ];
  function wrap(name){
    const fn = window[name];
    if (typeof fn !== 'function') return;
    window[name] = function(...args){
      // Блокируем ключевые действия, если сейчас не наш ход
      try {
        if (NET_ON() && GATED.includes(name)) {
          const myTurn = (typeof gameState?.active === 'number') && (gameState.active === MY_SEAT);
          if (!myTurn) { try { typeof showNotification==='function' && showNotification('Opponent\'s turn', 'error'); } catch {} return; }
        }
      } catch {}
      const r = fn.apply(this,args);
      // Если функция возвращает промис (async) — шлём после завершения
      if (r && typeof r.then === 'function') {
        return r.then((val)=>{
          // Ключевые события требуют обязательного пуша по завершении
          if (name === 'endTurn' || name === 'initGame' || name === 'startGame') {
            schedulePush(name, { force: true });
          } else {
            schedulePush(name);
          }
          return val;
        });
      }
      if (name === 'endTurn' || name === 'initGame' || name === 'startGame') {
        schedulePush(name, { force: true });
      } else {
        schedulePush(name);
      }
      return r;
    };
  }
  TO_WRAP.forEach(wrap);

  // digest: быстрый снимок значимых полей
  function digest(state){
    try {
      if (!state) return '';
      const compact = {
        active: state.active,
        turn: state.turn,
        winner: state.winner ?? null,
        players: (state.players||[]).map(p => ({
          mana: p.mana, max: p.maxMana,
          hand: (p.hand||[]).map(c=>c.id),
          deckN: (p.deck||[]).length,
          discardN: (p.discard||[]).length
        })),
        board: (state.board||[]).map(row => row.map(cell => {
          const u = cell?.unit;
          return u ? {o:u.owner,h:u.hp,a:u.atk,f:u.facing,t:u.tplId} : null;
        }))
      };
      return JSON.stringify(compact);
    } catch { return '';}
  }

  let lastDigest = '';
  let pending = false;
  function schedulePush(reason='auto', {force=false}={}){
    if (!NET_ON() || !gameState) return;
    if (APPLYING && !force) return;              // не эхоим полученный снапшот
    // Не пушим во время анимаций, если не forced
    if (!force && (manaGainActive || drawAnimationActive || splashActive)) return;
    const myTurn = (typeof gameState.active === 'number') && (gameState.active === MY_SEAT);
    if (!force && !myTurn) return;               // только активный игрок пушит
    if (force) {
      // немедленная отправка, игнорируя pending
      try {
        // Версионируем состояние: защитимся от устаревших снапшотов, приходящих чуть позже
        gameState.__ver = (Number(gameState.__ver) || 0) + 1;
        try { window.__LAST_SENT_VER = gameState.__ver; } catch {}
        socket.emit('pushState', { state: gameState, reason });
      } catch{}
      lastDigest = digest(gameState);
      pending = false;
      return;
    }
    if (pending) return;
    pending = true;
    requestAnimationFrame(()=>{
      pending = false;
      try {
        gameState.__ver = (Number(gameState.__ver) || 0) + 1;
        try { window.__LAST_SENT_VER = gameState.__ver; } catch {}
        socket.emit('pushState', { state: gameState, reason });
      } catch{}
      lastDigest = digest(gameState);
    });
  }
  // Экспортируем наружу, чтобы ранние функции (например, endTurn) могли вызвать schedulePush
  try { window.schedulePush = schedulePush; } catch {}

  // Периодическая отправка при любом изменении (подстраховка, если обёртка не сработала)
  setInterval(()=>{
    if (!NET_ON() || !gameState) return;
    // пушит только тот, у кого сейчас ХОД (чтобы оба могли делать свои ходы)
    const myTurn = (typeof gameState.active === 'number') && (gameState.active === MY_SEAT);
    if (!myTurn) return;
    const d = digest(gameState);
    if (d && d !== lastDigest) schedulePush('digest');
  }, 250);

  // --- RECEIVING: применяем снапшот и перерисовываем ---
  socket.on('state', async (state)=>{
    if (!state) return;
    const prev = APPLYING ? null : (gameState ? JSON.parse(JSON.stringify(gameState)) : null);
    // Robust previous snapshot even if prev is null due to concurrent APPLYING
    let __lastTurnSeen = 0;
    try { __lastTurnSeen = (typeof window !== 'undefined' && typeof window.__lastTurnSeen === 'number') ? window.__lastTurnSeen : (gameState?.turn || 0); } catch {}
    const __hadNewTurn = (typeof state.turn === 'number') && (state.turn > (__lastTurnSeen || 0));
    let __lastManaSeen = (typeof window !== 'undefined' && window.__lastManaSeen && Array.isArray(window.__lastManaSeen)) ? window.__lastManaSeen.slice() : [0,0];
    try {
      if (!__lastManaSeen || __lastManaSeen.length < 2) __lastManaSeen = [0,0];
      if (gameState && gameState.players) {
        __lastManaSeen[0] = Number(gameState.players[0]?.mana || __lastManaSeen[0] || 0);
        __lastManaSeen[1] = Number(gameState.players[1]?.mana || __lastManaSeen[1] || 0);
      }
    } catch {}
    // Защита от поздних устаревших снапшотов: принимаем только если версия не меньше текущей
    try {
      const incomingVer = Number(state.__ver) || 0;
      const currentVer = Number(gameState && gameState.__ver) || 0;
      if (incomingVer <= currentVer && !((Number(state?.turn||0)) > (Number(gameState?.turn||0)))) {
        // проигнорируем устаревший снапшот
        return;
      }
    } catch {}
    
    // WebSocket анимации отключены, флаги не используются
    
    APPLYING = true;
    try {
      gameState = state;
      try { window.gameState = state; } catch {}
      lastDigest = digest(state);
      // Immediately reflect active seat and mana bars before any animations
        const leftSide = document.getElementById('left-side');
        const rightSide = document.getElementById('right-side');
        const t0 = document.getElementById('player-title-0');
        const t1 = document.getElementById('player-title-1');
        if (leftSide && rightSide && t0 && t1 && typeof gameState.active === 'number') {
          leftSide.querySelectorAll('.overlay-panel').forEach(el => el.classList.remove('active-player-panel'));
          rightSide.querySelectorAll('.overlay-panel').forEach(el => el.classList.remove('active-player-panel'));
          t0.classList.remove('title-pulse');
          t1.classList.remove('title-pulse');
          if (gameState.active === 0) {
            leftSide.querySelectorAll('.overlay-panel').forEach(el => el.classList.add('active-player-panel'));
            t0.classList.add('title-pulse');
          } else {
            rightSide.querySelectorAll('.overlay-panel').forEach(el => el.classList.add('active-player-panel'));
            t1.classList.add('title-pulse');
          }
        }
      try { updateIndicator(); } catch {}
      try { updateInputLock(); } catch {}
      // Сначала переcоберём доску/мета-объекты, затем юниты и UI (исправляет мерцание рамок)
      try{ createBoard && createBoard(); }catch{}
      try{ createMetaObjects && createMetaObjects(); }catch{}
      // Defer unit rebuild during remote lunge animation to avoid canceling the push
      try {
        const now = Date.now();
        const until = (typeof window !== 'undefined' && typeof window.__REMOTE_BATTLE_ANIM_UNTIL === 'number') ? window.__REMOTE_BATTLE_ANIM_UNTIL : __REMOTE_BATTLE_ANIM_UNTIL;
        if (until && now < until) {
          const delay = Math.min(900, Math.max(30, until - now + 20));
          if (window.__deferredUnitsTimer) { try { clearTimeout(window.__deferredUnitsTimer); } catch {} }
          window.__deferredUnitsTimer = setTimeout(()=>{ try { updateUnits(); } catch {} }, delay);
        } else {
          updateUnits();
        }
      } catch { updateUnits(); }
      // Обрабатываем отложенные WebSocket анимации
      try { flushPendingBattleQueues && flushPendingBattleQueues(); } catch {}
      try { if (prev) playDeltaAnimations(prev, state); } catch {}
      // Периодически пробуем воспроизвести отложенные анимации
      try {
        if (typeof window !== 'undefined') {
          if (window.__pendingBattleFlushTimer) clearInterval(window.__pendingBattleFlushTimer);
          window.__pendingBattleFlushTimer = setInterval(()=>{
            try { flushPendingBattleQueues && flushPendingBattleQueues(); } catch {}
          }, 120);
          setTimeout(()=>{ try { if (window.__pendingBattleFlushTimer) clearInterval(window.__pendingBattleFlushTimer); } catch {} }, 2500);
        }
      } catch {}
      // Если пришёл новый ход, заранее блокируем отображение новых орбов маны,
      // чтобы первая перерисовка UI не показывала их до вспышки
      try {
        const isNewTurnEarly = !!(prev && typeof prev.turn === 'number' && typeof state.turn === 'number' && state.turn > prev.turn);
        if (isNewTurnEarly) {
          const ownerEarly = (typeof state.active === 'number') ? state.active : (gameState?.active ?? 0);
          const beforeMEarly = (prev?.players?.[ownerEarly]?.mana ?? 0);
          const afterMEarly = (state?.players?.[ownerEarly]?.mana ?? 0);
          // Только устанавливаем PENDING_MANA_ANIM если нет текущей анимации маны
          if (!PENDING_MANA_ANIM && !manaGainActive) {
            PENDING_MANA_ANIM = window.PENDING_MANA_ANIM = { ownerIndex: ownerEarly, startIdx: Math.max(0, Math.min(9, beforeMEarly)), endIdx: Math.max(-1, Math.min(9, afterMEarly - 1)) };
            try { if (typeof window !== 'undefined' && window.gameState && window.gameState.players && window.gameState.players[ownerEarly]) { window.gameState.players[ownerEarly]._beforeMana = beforeMEarly; } } catch {}
          }
        }
      } catch {}
      // Guard: ensure start-of-turn +2 does not render before animation
      try {
        const __hadNewTurn = !!(typeof state.turn === 'number' && state.turn > (__lastTurnSeen || 0));
        if (__hadNewTurn && !PENDING_MANA_ANIM && !manaGainActive) {
          const __owner = (typeof state.active === 'number') ? state.active : (gameState?.active ?? 0);
          const __beforeM = Math.max(0, Number((__lastManaSeen && __lastManaSeen[__owner]) ?? 0));
          const __afterM = Math.max(0, Number(state?.players?.[__owner]?.mana ?? __beforeM));
          if (__afterM > __beforeM) {
            PENDING_MANA_ANIM = window.PENDING_MANA_ANIM = {
              ownerIndex: __owner,
              startIdx: Math.max(0, Math.min(9, __beforeM)),
              endIdx: Math.max(-1, Math.min(9, __afterM - 1))
            };
          }
        }
      } catch {}
      try { updateUI(); }catch{}
      // Если начался новый ход — синхронизируем порядок анимаций как в офлайне:
      // 1) Заставка хода с корректным заголовком, 2) Анимация маны, 3) Добор
      // Упрощенная и надежная система обработки нового хода
      try {
        const isNewTurn = (typeof state.turn === 'number') && (state.turn > ((prev && typeof prev.turn === 'number') ? prev.turn : (__lastTurnSeen || 0)));
        if (isNewTurn) {
          console.log(`[NETWORK] Processing new turn ${state.turn} (prev: ${prev?.turn || 'none'})`);
          
          // 1. Показываем заставку хода (если еще не показывали этот ход)
          if (lastSplashTurnShown < state.turn) {
            console.log(`[NETWORK] Showing turn splash for turn ${state.turn}`);
            try {
              if (window.__ui && window.__ui.banner) {
                const b = window.__ui.banner;
                if (typeof b.ensureTurnSplashVisible === 'function') {
                  await b.ensureTurnSplashVisible(3, state.turn);
                } else if (typeof b.forceTurnSplashWithRetry === 'function') {
                  await b.forceTurnSplashWithRetry(3, state.turn);
                }
              }
              lastSplashTurnShown = state.turn;
            } catch (e) {
              console.error('[NETWORK] Turn splash failed:', e);
            }
          }
          
          // 2. Анимация маны активного игрока
          const owner = (typeof state.active === 'number') ? state.active : 0;
          const beforeM = Math.max(0, (prev?.players?.[owner]?.mana ?? 0));
          const afterM = Math.max(0, (state?.players?.[owner]?.mana ?? 0));
          
          // Expose _beforeMana for UI clamping until animation completes
          try { if (typeof window !== 'undefined' && window.gameState && window.gameState.players && window.gameState.players[owner]) { window.gameState.players[owner]._beforeMana = beforeM; } } catch {}

          if (afterM > beforeM) {
            console.log(`[NETWORK] Animating mana for player ${owner}: ${beforeM} -> ${afterM}`);
            try {
              if (window.__ui && window.__ui.mana && typeof window.__ui.mana.animateTurnManaGain === 'function') {
                await window.__ui.mana.animateTurnManaGain(owner, beforeM, afterM, 1500);
              }
            } catch (e) {
              console.error('[NETWORK] Mana animation failed:', e);
            }
          }
        }
      } catch (e) {
        console.error('[NETWORK] Error processing new turn:', e);
      }
      // Анимация добора у приёмника (только для своей руки)
      try {
        const mySeat = (typeof window !== 'undefined' && typeof window.MY_SEAT === 'number') ? window.MY_SEAT : null;
        if (mySeat !== null && prev && prev.players && state.players) {
          const prevHand = (prev.players[mySeat]?.hand) || [];
          const nextHand = (state.players[mySeat]?.hand) || [];
          const delta = Math.max(0, nextHand.length - prevHand.length);
          if (delta > 0) {
            // Спрячем последние delta карт на время анимации
            pendingDrawCount = delta; updateHand();
            // Определим какие именно шаблоны анимировать — возьмём последние delta карт
            const newCards = nextHand.slice(-delta);
            for (let i = 0; i < newCards.length; i++) {
              const tpl = newCards[i];
              await animateDrawnCardToHand(tpl);
              // По одной открываем карту в руке
              pendingDrawCount = Math.max(0, pendingDrawCount - 1);
              updateHand();
            }
          } else {
            updateHand();
          }
        } else {
          updateHand();
        }
      } catch { updateHand(); }
    try { __endTurnInProgress = false; } catch {}
    updateIndicator();
    updateInputLock();
      // Persist last seen turn/mana for robust next-frame animations
      try {
        if (typeof window !== 'undefined') {
          window.__lastTurnSeen = Number(state.turn || 0);
          if (!window.__lastManaSeen) window.__lastManaSeen = [0,0];
          try { window.__lastManaSeen[0] = Number(state.players?.[0]?.mana || 0); } catch {}
          try { window.__lastManaSeen[1] = Number(state.players?.[1]?.mana || 0); } catch {}
        }
      } catch {}
    } finally {
      APPLYING=false;
      try { __endTurnInProgress = false; refreshInputLockUI(); } catch {}
    }
  });

  // Явный сигнал о смене хода (ускоряет разблокировку у оппонента в заанимированных кейсах)
  socket.on('turnSwitched', ({ activeSeat })=>{
    try {
      if (typeof activeSeat === 'number') {
        if (!gameState) gameState = {};
        gameState.active = activeSeat;
      }
    } catch {}
    try {
      const leftSide = document.getElementById('left-side');
      const rightSide = document.getElementById('right-side');
      const t0 = document.getElementById('player-title-0');
      const t1 = document.getElementById('player-title-1');
      if (leftSide && rightSide && t0 && t1 && typeof gameState.active === 'number') {
        leftSide.querySelectorAll('.overlay-panel').forEach(el => el.classList.remove('active-player-panel'));
        rightSide.querySelectorAll('.overlay-panel').forEach(el => el.classList.remove('active-player-panel'));
        t0.classList.remove('title-pulse');
        t1.classList.remove('title-pulse');
        if (gameState.active === 0) {
          leftSide.querySelectorAll('.overlay-panel').forEach(el => el.classList.add('active-player-panel'));
          t0.classList.add('title-pulse');
        } else {
          rightSide.querySelectorAll('.overlay-panel').forEach(el => el.classList.add('active-player-panel'));
          t1.classList.add('title-pulse');
        }
      }
    } catch {}
    updateIndicator();
    updateInputLock();
    // Show splash reliably; state event will drive full UI/mana sync
    try {
      if (typeof forceTurnSplashWithRetry === 'function') forceTurnSplashWithRetry(2);
    } catch {}
  });

  // ===== 9) Battle animation sync =====
  // Small guard to delay unit rebuild during remote lunge
  let __REMOTE_BATTLE_ANIM_UNTIL = 0; try { window.__REMOTE_BATTLE_ANIM_UNTIL = __REMOTE_BATTLE_ANIM_UNTIL; } catch {}

  function tryPlayBattleAnim(attacker, targets){
    try {
      if (!attacker || !Array.isArray(targets) || targets.length===0) return false;
      const aMesh = unitMeshes.find(m => m.userData.row === attacker.r && m.userData.col === attacker.c);
      const first = targets[0];
      if (!aMesh || !tileMeshes?.[first.r]?.[first.c]) return false;
      const targetPos = tileMeshes[first.r][first.c].position;
      const dir = new THREE.Vector3().subVectors(targetPos, aMesh.position).normalize();
      const push = { x: dir.x * 0.6, z: dir.z * 0.6 };
      // Wrap target mesh into a transient group to ensure movement is visible
      const parent = aMesh.parent; if (!parent) return false;
      const fromPos = aMesh.position.clone();
      const fromRot = aMesh.rotation.clone();
      const wrapper = new THREE.Group();
      wrapper.position.copy(fromPos); wrapper.rotation.copy(fromRot);
      try { parent.add(wrapper); parent.remove(aMesh); aMesh.position.set(0,0,0); aMesh.rotation.set(0,0,0); wrapper.add(aMesh); } catch {}
      const toPos = wrapper.position.clone(); toPos.x += push.x; toPos.z += push.z;
      const tl = gsap.timeline({ onComplete: () => {
        try { parent.add(aMesh); parent.remove(wrapper); aMesh.position.copy(fromPos); aMesh.rotation.copy(fromRot); } catch {}
      }});
      tl.to(wrapper.position, { x: toPos.x, z: toPos.z, duration: 0.22, ease: 'power2.out' })
        .to(wrapper.position, { x: fromPos.x, z: fromPos.z, duration: 0.30, ease: 'power2.inOut' });
      __REMOTE_BATTLE_ANIM_UNTIL = Date.now() + 720; try { window.__REMOTE_BATTLE_ANIM_UNTIL = __REMOTE_BATTLE_ANIM_UNTIL; } catch {}
      
      // Тряска цели и синхронный урон для неинициатора
      setTimeout(() => {
        try {
          for (const target of targets) {
            const tMesh = unitMeshes.find(m => m.userData.row === target.r && m.userData.col === target.c);
            if (tMesh && typeof target.dmg === 'number' && target.dmg > 0) {
              shakeMesh(tMesh, 6, 0.12);
              try { cancelPendingHpPopup(`${target.r},${target.c}`, -target.dmg); } catch {}
              try { spawnDamageText(tMesh, `-${target.dmg}`, '#ff5555'); } catch {}
              try {
                const key = `${target.r},${target.c}`;
                RECENT_REMOTE_DAMAGE.set(key, { delta: -target.dmg, ts: Date.now() });
              } catch {}
            }
          }
        } catch {}
      }, 420);
      
      return true;
    } catch { return false; }
  }
  socket.on('battleAnim', ({ attacker, targets, __id, bySeat }) => {
    console.log('[battleAnim] Received battle animation', { MY_SEAT, bySeat, attacker, targets: targets?.length });
    
    // Показываем анимацию всем игрокам КРОМЕ инициатора
    if (typeof MY_SEAT === 'number' && typeof bySeat === 'number' && MY_SEAT === bySeat) {
      console.log('[battleAnim] Skipping animation for initiator');
      return;
    }
    
    // Defer during state apply to avoid losing animation due to re-render
    if (typeof APPLYING !== 'undefined' && APPLYING) {
      try { PENDING_BATTLE_ANIMS.push({ attacker, targets, ts: Date.now(), id: __id }); } catch {}
      return;
    }
    
    const success = tryPlayBattleAnim(attacker, targets);
    console.log('[battleAnim] Animation result:', success);
    if (!success) {
      // Отложим анимацию
      PENDING_BATTLE_ANIMS.push({ attacker, targets, ts: Date.now(), id: __id });
    }
  });
  // Визуальная поддержка: если пришло событие ритуала у оппонента — мягко отобразим +2 маны у него
  socket.on('ritualResolve', ({ kind, by, card, consumed, consumedIdx, spellIdx, consumedCard, spellCard }) => {
    try {
      if (kind === 'HOLY_FEAST' && typeof by === 'number') {
        try { if (typeof window !== 'undefined') window.__HF_ACK = true; } catch {}
        // Полностью сбрасываем все состояния Holy Feast
        try { hidePrompt(); } catch {}
        try { pendingDiscardSelection = null; } catch {}
        try { pendingRitualSpellHandIndex = null; } catch {}
        try { pendingRitualSpellCard = null; } catch {}
        try { PENDING_HIDE_HAND_CARDS = []; } catch {}
        try { resetCardSelection(); } catch {}
        // Убираем карту-спелл с поля если она там есть
        try { 
          if (pendingRitualBoardMesh) { 
            dissolveAndAsh(pendingRitualBoardMesh, new THREE.Vector3(0,0.6,0), 0.9); 
            setTimeout(()=>{ 
              try { pendingRitualBoardMesh.parent.remove(pendingRitualBoardMesh); } catch {} 
              pendingRitualBoardMesh = null; 
            }, 950); 
          } 
        } catch {}
        // Показать вспышку +2 маны у панели by (только визуально; фактическое значение придёт со снапшотом)
        const barEl = document.getElementById(`mana-display-${by}`);
        if (barEl) {
          const rect = barEl.getBoundingClientRect();
          const center = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
          // Две искры в панель — символически
          animateManaGainFromWorld(new THREE.Vector3(0,0,0), by, true);
          setTimeout(()=> animateManaGainFromWorld(new THREE.Vector3(0,0,0), by, true), 120);
        }
        // Принудительно обновляем UI для полного сброса состояний
        try { updateHand(); } catch {}
        try { updateUI(); } catch {}
      }
    } catch {}
  });

  // Доп. синхронизация: контратака (выпады контратакующих и удар по атакующему)
  function tryPlayRetaliation(attacker, retaliators, total){
    try {
      if (!attacker || !Array.isArray(retaliators)) return false;
      const aMesh = unitMeshes.find(m => m.userData.row === attacker.r && m.userData.col === attacker.c);
      if (!aMesh) return false;
      let maxDur = 0;
      for (const rrObj of retaliators) {
        const rMesh = unitMeshes.find(m => m.userData.row === rrObj.r && m.userData.col === rrObj.c);
        if (!rMesh) continue;
        const dir2 = new THREE.Vector3().subVectors(aMesh.position, rMesh.position).normalize();
        const push2 = { x: dir2.x * 0.6, z: dir2.z * 0.6 };
        const tl2 = gsap.timeline();
        tl2.to(rMesh.position, { x: `+=${push2.x}`, z: `+=${push2.z}`, duration: 0.22, ease: 'power2.out' })
           .to(rMesh.position, { x: `-=${push2.x}`, z: `-=${push2.z}`, duration: 0.30, ease: 'power2.inOut' });
        maxDur = Math.max(maxDur, 0.52);
      }
      if (typeof total === 'number' && total > 0) {
        setTimeout(() => {
          const aLive = unitMeshes.find(m => m.userData.row === attacker.r && m.userData.col === attacker.c) || aMesh;
          if (aLive) {
            shakeMesh(aLive, 6, 0.14);
            try { cancelPendingHpPopup(`${attacker.r},${attacker.c}`, -total); } catch {}
            try { spawnDamageText(aLive, `-${total}`, '#ffd166'); } catch {}
            try {
              const key = `${attacker.r},${attacker.c}`;
              RECENT_REMOTE_DAMAGE.set(key, { delta: -total, ts: Date.now() });
            } catch {}
          }
        }, Math.max(0, maxDur * 1000 - 10));
      }
      return true;
    } catch { return false; }
  }
  socket.on('battleRetaliation', ({ attacker, retaliators, total, __id, bySeat }) => {
    console.log('[battleRetaliation] Received retaliation animation', { MY_SEAT, bySeat, attacker, retaliators: retaliators?.length, total });
    
    // Показываем анимацию всем игрокам КРОМЕ инициатора
    if (typeof MY_SEAT === 'number' && typeof bySeat === 'number' && MY_SEAT === bySeat) {
      console.log('[battleRetaliation] Skipping animation for initiator');
      return;
    }
    
    const success = tryPlayRetaliation(attacker, retaliators, total);
    console.log('[battleRetaliation] Animation result:', success);
    if (!success) {
      PENDING_RETALIATIONS.push({ attacker, retaliators, total, ts: Date.now(), id: __id });
    }
  });

  function flushPendingBattleQueues(){
    try {
      if (PENDING_BATTLE_ANIMS.length) {
        PENDING_BATTLE_ANIMS = PENDING_BATTLE_ANIMS.filter(ev => !tryPlayBattleAnim(ev.attacker, ev.targets));
      }
      if (PENDING_RETALIATIONS.length) {
        PENDING_RETALIATIONS = PENDING_RETALIATIONS.filter(ev => !tryPlayRetaliation(ev.attacker, ev.retaliators, ev.total));
      }
    } catch {}
  }

  // ===== 10) Tile crossfade sync =====
  socket.on('tileCrossfade', ({ r, c, prev, next }) => {
    try {
      const tile = tileMeshes?.[r]?.[c]; if (!tile) return;
      dissolveTileCrossfade(tile, getTileMaterial(prev), getTileMaterial(next), 0.9);
    } catch {}
  });

  // ===== 5) Queue / start =====
  function onFindMatchClick(){ 
    console.log('[QUEUE] Attempting to join queue, socket connected:', socket.connected);
    showQueueModal(); 
    try { 
      (window.socket || socket).emit('joinQueue'); 
      (window.socket || socket).emit('debugLog', { event: 'joinQueue_sent', connected: socket.connected });
    } catch(err) {
      console.error('[QUEUE] Error joining queue:', err);
    }
  }
  socket.on('matchFound', ({ matchId, seat })=>{
    hideQueueModal();
    console.log('[MATCH] Match found, setting MY_SEAT to:', seat, 'matchId:', matchId);
    // Логирование для отладки
    try { (window.socket || socket).emit('debugLog', { event: 'matchFound_received', seat, matchId }); } catch {}
    
    // Полный сброс локального состояния предыдущего матча перед стартом нового
    try { if (window.__pendingBattleFlushTimer) { clearInterval(window.__pendingBattleFlushTimer); window.__pendingBattleFlushTimer = null; } } catch {}
    try { PENDING_BATTLE_ANIMS = []; PENDING_RETALIATIONS = []; } catch {}
    try { PENDING_MANA_ANIM = window.PENDING_MANA_ANIM = null; PENDING_MANA_BLOCK = [0,0]; } catch {}
    try { pendingDrawCount = 0; pendingRitualSpellHandIndex = null; pendingRitualSpellCard = null; } catch {}
    try { lastDigest = ''; } catch {}
    APPLYING = false;
    gameState = null;
    MY_SEAT = seat; NET_ACTIVE = true;
    try { window.MY_SEAT = seat; } catch {}
    console.log('[MATCH] MY_SEAT set to:', MY_SEAT, 'NET_ACTIVE:', NET_ACTIVE);
    updateIndicator(); updateInputLock();
    showStartCountdown(seat, 3);
  });

  async function onCountdownFinished(seat){
    if (seat===0){
      try{ typeof initGame==='function' && await initGame(); }catch{}
      schedulePush('init-snapshot', {force:true}); // гарантированный первый снапшот
    } else {
      try { (window.socket || socket).emit('requestState'); } catch {}
    }
  }

  socket.on('opponentLeft', ()=>{
    console.log('[MATCH] Opponent left, MY_SEAT:', MY_SEAT);
    NET_ACTIVE=false; updateIndicator(); updateInputLock();
    // Показываем победу оставшемуся в игре игроку
    showVictoryModal({ reason: 'opponentLeft', winnerSeat: MY_SEAT });
    try { if (queueModal) hideQueueModal(); } catch {}
    try { hideStartCountdown(); } catch {}
  });

  // ===== 6) Online indicator + whose turn =====
  const ind = document.createElement('div');
  ind.className='mp-ind';
  ind.innerHTML = `<span class="mp-dot" id="mp-dot"></span>
                   <span id="mp-net">offline</span>
                   <span class="mp-tag" id="mp-seat">—</span>
                   <span class="mp-turn" id="mp-turn"></span>`;
  document.body.appendChild(ind);

  // ===== 6.1) Debug log UI =====
  (function mountDebugLog(){
    try {
      if (document.getElementById('debug-log-btn')) return;
      // Размещаем отдельно слева над индикатором, чтобы не перекрывать «Сдаться»
      let host = document.getElementById('mp-debug');
      if (!host) { host = document.createElement('div'); host.id='mp-debug'; host.style.position='fixed'; host.style.left='12px'; host.style.bottom='52px'; host.style.zIndex='9998'; document.body.appendChild(host); }
      const btn = document.createElement('button'); btn.id='debug-log-btn'; btn.className='mp-btn'; btn.textContent='Download log';
      btn.addEventListener('click', async ()=>{
        try {
          const res = await fetch(`${SERVER_URL}/debug-log?n=2000`);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json();
          const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a'); a.href=url; a.download = `eog-log-${Date.now()}.json`; a.click();
          setTimeout(()=>URL.revokeObjectURL(url), 2000);
        } catch(err){
          console.error('Download log error', err);
          showNotification('Could not download log', 'error');
        }
      });
      host.appendChild(btn);
    } catch {}
  })();

  // Получение версии билда (в приоритете — коммит клиентского репозитория из GitHub API)
  (async function fetchBuildVersion(){
    const el = document.getElementById('build-version');
    if (!el) return;
    // 1) Пробуем GitHub API по window.CLIENT_REPO = { owner, repo, ref? }
    try {
      let cfg = (typeof window !== 'undefined' && window.CLIENT_REPO) ? window.CLIENT_REPO : null;
      // Пробуем прочитать из <meta name="client-repo" content="owner/repo@ref">, либо из localStorage
      if (!cfg) {
        try {
          const meta = document.querySelector('meta[name="client-repo"]');
          const val = (meta && meta.getAttribute('content')) || (localStorage.getItem('CLIENT_REPO') || '');
          if (val) {
            // Форматы: owner/repo@ref | owner/repo
            const [full, ref] = String(val).split('@');
            const [owner, repo] = full.split('/');
            if (owner && repo) cfg = { owner, repo, ref };
          }
        } catch {}
      }
      if (cfg && cfg.owner && cfg.repo) {
        const ref = encodeURIComponent(cfg.ref || 'main');
        const headers = {};
        // Необязательный токен GitHub для повышенного лимита (например, положить в localStorage.GH_TOKEN)
        try { const t = localStorage.getItem('GH_TOKEN'); if (t) headers['Authorization'] = `Bearer ${t}`; } catch {}
        const gh = await fetch(`https://api.github.com/repos/${cfg.owner}/${cfg.repo}/commits/${ref}`, { headers });
        if (gh.ok) {
          const data = await gh.json();
          const shaShort = (data.sha || '').slice(0, 7);
          let msg = (data.commit && data.commit.message) ? String(data.commit.message).trim() : '';
          if (msg) { const parts = msg.split(/\s+/).slice(0, 7); msg = parts.join(' '); }
          el.textContent = shaShort ? `${shaShort}${msg ? ' — ' + msg : ''}` : (msg || '');
          return;
        }
      }
    } catch {}
    // 2) Фолбэк: серверный /build (покажет версию именно серверного репозитория)
    try {
      const res = await fetch('/build');
      if (!res.ok) return;
      const d = await res.json();
      const shaShort = (d.sha || '').slice(0, 7);
      let msg = (d.message || '').trim();
      if (msg) { const parts = msg.split(/\s+/).slice(0, 7); msg = parts.join(' '); }
      el.textContent = shaShort ? `${shaShort}${msg ? ' — ' + msg : ''}` : (msg || '');
    } catch {}
  })();

  function updateIndicator(){
    const dot=document.getElementById('mp-dot');
    const net=document.getElementById('mp-net');
    const seat=document.getElementById('mp-seat');
    const turn=document.getElementById('mp-turn');

    const online = socket.connected && NET_ON();
    dot.classList.toggle('on', online);
    net.textContent = online ? 'online' : 'offline';
    seat.textContent = (MY_SEAT===0)?'Player 1':(MY_SEAT===1)?'Player 2':'—';

    if (gameState && (MY_SEAT===0 || MY_SEAT===1)){
      turn.textContent = (gameState.active===MY_SEAT) ? 'your turn' : 'opponent\'s turn';
    } else turn.textContent='';
  }
  socket.on('connect', () => {
    console.log('[SOCKET] Connected to server');
    updateIndicator();
  });
  socket.on('disconnect', (reason) => {
    console.log('[SOCKET] Disconnected from server:', reason);
    updateIndicator();
  });
  socket.on('connect_error', (error) => {
    console.error('[SOCKET] Connection error:', error);
  });
  socket.on('matchFound', updateIndicator);
  setInterval(updateIndicator, 500);
  updateIndicator();

  // ===== 7) Input lock: когда не твой ход — блокируем клики по сцене =====
  const lock = document.createElement('div');
  lock.className = 'mp-lock';
  lock.innerHTML = `<div class="mp-card">Ход соперника…</div>`;
  document.body.appendChild(lock);

  function updateInputLock(){
    // Lock only when seat is known; otherwise do not block input
    const myKnown = (typeof MY_SEAT === 'number');
    const shouldLock = NET_ON() && gameState && myKnown && (gameState.active !== MY_SEAT);
    lock.classList.toggle('on', !!shouldLock);
  }

  // Серверный таймер хода: только отображение и локальная анимация кнопки
  socket.on('turnTimer', ({ seconds, activeSeat })=>{
    try { window.__turnTimerSeconds = seconds; } catch {}
    try { if (gameState && typeof activeSeat === 'number') gameState.active = activeSeat; } catch {}
    try {
      if (window.__ui && window.__ui.turnTimer) {
        const tt = window.__ui.turnTimer.attach('end-turn-btn');
        tt.stop();
        tt.set(Math.max(0, Math.min(100, Number(seconds)||0)));
      }
    } catch {}

    try { updateIndicator(); } catch {}
    try { updateInputLock(); } catch {}
  });

  // ===== 8) Победа/поражение и меню после матча =====
  function showVictoryModal({ reason, winnerSeat }={}){
    console.log('[VICTORY] Showing victory modal', { reason, winnerSeat, MY_SEAT });
    hideQueueModal(); hideStartCountdown();
    const m = document.createElement('div');
    m.className = 'mp-modal';
    
    let title;
    if (reason === 'opponentLeft') {
      title = (winnerSeat === MY_SEAT) ? 'Victory! Opponent resigned' : 'Defeat! You disconnected';
    } else if (reason === 'resign') {
      title = (winnerSeat === MY_SEAT) ? 'Victory! Opponent resigned' : 'Defeat! You resigned';
    } else {
      title = (winnerSeat === MY_SEAT) ? 'Victory!' : 'Defeat';
    }
    m.innerHTML = `<div class="mp-card" style="min-width:320px">
      <div style="font-size:18px;margin-bottom:6px">${title}</div>
      <div class="mp-subtle" style="margin-bottom:12px">Match ended</div>
      <div style="display:flex;gap:8px;justify-content:center">
        <button id="mp-offline" class="mp-btn">Offline game</button>
        <button id="mp-online" class="mp-btn">New online match</button>
      </div>
    </div>`;
    document.body.appendChild(m);
    m.querySelector('#mp-offline').addEventListener('click', ()=>{ try{ location.reload(); }catch{} });
    m.querySelector('#mp-online').addEventListener('click', ()=>{
      try{ m.remove(); }catch{}
      NET_ACTIVE=false; updateIndicator(); updateInputLock();
      onFindMatchClick();
    });
  }

  // Кнопка «Сдаться» рядом с остальными
  function mountResignButton(){
    if (document.getElementById('resign-btn')) return;
    const host = document.querySelector('#corner-right .flex') || document.getElementById('corner-right');
    if (!host) return;
    const btn = document.createElement('button');
    btn.id = 'resign-btn';
    btn.className = 'overlay-panel px-3 py-1.5 text-xs bg-red-600 hover:bg-red-700 transition-colors';
    btn.textContent = 'Surrender';
    host.appendChild(btn);
    btn.addEventListener('click', ()=>{
      const confirmModal = document.createElement('div');
      confirmModal.className = 'mp-modal';
      confirmModal.innerHTML = `<div class="mp-card">
        <div>Вы уверены, что хотите сдаться?</div>
        <div style="display:flex;gap:8px;justify-content:center;margin-top:10px">
          <button id="r-yes" class="mp-btn">Да</button>
          <button id="r-no" class="mp-btn">Нет</button>
        </div>
      </div>`;
      document.body.appendChild(confirmModal);
      confirmModal.querySelector('#r-no').addEventListener('click', ()=> confirmModal.remove());
      confirmModal.querySelector('#r-yes').addEventListener('click', ()=>{
        try { (window.socket || socket).emit('resign'); } catch {}
        try { confirmModal.remove(); } catch {}
      });
    });
  }
  mountResignButton();
  setInterval(mountResignButton, 1000);

  socket.on('matchEnded', ({ winnerSeat, reason })=>{
    // Полный сброс клиентского онлайнового состояния и комнаты перед показом модалки
    try { (window.socket || socket).emit('requestState'); } catch {}
    // ВАЖНО: сначала показываем модалку, используя актуальный MY_SEAT,
    // затем уже сбрасываем локальные флаги. Иначе у обоих будет "Поражение".
    showVictoryModal({ winnerSeat, reason: reason || 'resign' });
    NET_ACTIVE=false; APPLYING=false;
    // Сбрасываем seat после показа модалки
    MY_SEAT=null; try { window.MY_SEAT = null; } catch {}
    updateIndicator(); updateInputLock();
  });

  // Close MP bootstrap IIFE
})();

</script>
  <!-- Minimal always-on status chip (safe even if above scripts fail) -->
  <script>
  (function(){
    function mount(){
      if (document.getElementById('mod-status')) return;
      var el = document.createElement('div'); el.id='mod-status';
      el.style.cssText='position:fixed;left:8px;top:8px;z-index:9999;font:12px/1.2 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;color:#cbd5e1;background:rgba(15,23,42,.85);border:1px solid #334155;border-radius:8px;padding:6px 8px;pointer-events:none;';
      el.textContent='status…'; document.body.appendChild(el);
      function ok(b){ return '<span style="color:'+(b?'#22c55e':'#ef4444')+'">●</span>'; }
      function upd(){
        var cardsOk = !!(window.CARDS && Object.keys(window.CARDS||{}).length);
        var starterLen = (window.STARTER_FIRESET && window.STARTER_FIRESET.length) || 0;
        var rulesOk = ['dirsForPattern','effectiveStats','computeHits','stagedAttack','magicAttack'].every(function(k){return typeof window[k]==='function';});
        var stateOk = ['startGame','drawOne','drawOneNoAdd','shuffle','countControlled'].every(function(k){return typeof window[k]==='function';});
        var threeOk = !!(window.renderer && window.scene && window.camera);
        var boardOk = !!(window.tileMeshes && window.tileMeshes.length && window.tileMeshes[0] && window.tileMeshes[0].length);
        var gsOk = !!(window.gameState && Array.isArray(window.gameState.board));
        var net = (typeof window.NET_ACTIVE!=='undefined' && window.NET_ACTIVE) ? 'online' : 'offline';
        el.innerHTML = ok(cardsOk)+' cards ('+starterLen+') · '+ok(rulesOk)+' rules · '+ok(stateOk)+' state · '+ok(threeOk)+' three · '+ok(boardOk)+' board · '+ok(gsOk)+' gState · '+ok(net==='online')+' net:'+net;
      }
      upd(); setInterval(upd, 1000);
      // Try to kick init if earlier script failed to hook DOMContentLoaded
      function kick(){
        try {
          if (!(window.renderer && window.scene && window.camera)) {
            if (typeof window.init === 'function') { window.init(); return; }
            if (typeof window.initThreeJS === 'function') {
              try { window.initThreeJS(); } catch(e){}
              if (typeof window.animate === 'function') try { window.requestAnimationFrame(window.animate); } catch(e){}
            }
            if (typeof window.initGame === 'function') { try { window.initGame(); } catch(e){} }
          }
        } catch(e){}
      }
      setTimeout(kick, 200);
      setTimeout(kick, 1200);
      setTimeout(kick, 3000);
    }
    if (document.readyState==='loading') document.addEventListener('DOMContentLoaded', mount); else mount();
  })();
  </script>

</body>
</html>


























