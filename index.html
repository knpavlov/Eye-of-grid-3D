<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="client-repo" content="knpavlov/Eye-of-grid-3D@alt">
  <title>Eye of Grid ‚Äî Complete 3D</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #0f172a; color: #e2e8f0; font-family: system-ui, sans-serif; }
    #ui { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
    .ui-panel { pointer-events: auto; }
    #three-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }
    
    /* –ú–∞–Ω–∞ –æ—Ä–±—ã */
    .mana-bar { display: flex; gap: 6px; align-items: center; }
    .mana-orb { 
      width: 18px; height: 18px; border-radius: 50%; 
      background: radial-gradient(circle at 30% 30%, #fff, #8bd5ff 30%, #1ea0ff 70%, #0a67b7); 
      box-shadow: 0 0 10px rgba(30,160,255,0.8); 
    }
    .mana-slot { 
      width: 18px; height: 18px; border-radius: 50%; 
      border: 1px solid rgba(255,255,255,0.25); 
      background: rgba(255,255,255,0.06); 
      box-shadow: inset 0 2px 6px rgba(0,0,0,0.5); 
    }
    /* –ö–Ω–æ–ø–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ö–æ–¥–∞ —Å –∫—Ä—É–≥–æ–≤—ã–º —Ç–∞–π–º–µ—Ä–æ–º */
    .end-turn-btn { 
      position: relative; width: 84px; height: 84px; border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, rgba(30,41,59,0.9), rgba(30,41,59,0.85) 45%, rgba(15,23,42,0.95));
      box-shadow: inset 0 2px 10px rgba(0,0,0,0.45), 0 0 0 2px rgba(100,116,139,0.6), 0 8px 24px rgba(15,23,42,0.35);
      border: none; cursor: pointer; color: #0f172a; overflow: hidden; pointer-events: auto;
    }
    .end-turn-btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .end-turn-btn .time-fill { 
      position: absolute; left: 0; right: 0; top: 0; bottom: 0; z-index: 0;
      background: linear-gradient(to bottom, rgba(250,204,21,0.9), rgba(234,179,8,0.85));
      transition: top 220ms ease;
    }
    .end-turn-btn .label-text { 
      position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; z-index: 1;
      font-weight: 800; font-size: 13px; color: #f8fafc; text-shadow: 0 1px 0 rgba(0,0,0,0.4);
    }
    .end-turn-btn .sec-text { 
      position: absolute; left: 0; right: 0; bottom: 6px; text-align: center; z-index: 1;
      font-weight: 700; font-size: 12px; color: #ffffff; opacity: 0.95; text-shadow: 0 1px 2px rgba(0,0,0,0.6);
    }
    /* –ü—É–ª—å—Å–∞—Ü–∏—è —Ä–∞–º–∫–∏ –≤ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 10 —Å–µ–∫—É–Ω–¥ */
    @keyframes urgentPulse {
      0%   { box-shadow: inset 0 2px 10px rgba(0,0,0,0.45), 0 0 0 2px rgba(239,68,68,0.95), 0 0 16px rgba(239,68,68,0.55), 0 0 0 4px rgba(239,68,68,0.22); }
      100% { box-shadow: inset 0 2px 10px rgba(0,0,0,0.45), 0 0 0 2px rgba(239,68,68,1.0), 0 0 22px rgba(239,68,68,0.75), 0 0 0 6px rgba(239,68,68,0.28); }
    }
    .end-turn-btn.urgent { animation: urgentPulse 0.8s ease-in-out infinite alternate; }
    /* –í—ã–¥–µ–ª–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞ */
    .active-player-panel { 
      box-shadow: 0 0 0 2px rgba(34,197,94,0.9), 0 0 16px rgba(34,197,94,0.45);
      border-radius: 18px;
    }
    @keyframes titlePulse {
      0%   { transform: scale(1); }
      100% { transform: scale(1.08); }
    }
    .title-pulse {
      display: inline-block;
      color: #bbf7d0; /* —Å–≤–µ—Ç–ª–æ-–∑–µ–ª—ë–Ω—ã–π */
      text-shadow: 0 0 10px rgba(34,197,94,0.45);
      animation: titlePulse 1.1s ease-in-out infinite alternate;
      will-change: transform;
    }
    
    /* –ü–∞–Ω–µ–ª–∏ */
    .overlay-panel { background: rgba(30, 41, 59, 0.95); backdrop-filter: blur(10px); border: 1px solid rgba(148, 163, 184, 0.3); border-radius: 16px; }
    /* Prompt: –∫–ª–∏–∫–∞–±–µ–ª—å–Ω–∞ —Ç–æ–ª—å–∫–æ –ø–∞–Ω–µ–ª—å, –æ—Å—Ç–∞–ª—å–Ω–æ–µ –∫–ª–∏–∫–∞–µ—Ç—Å—è —Å–∫–≤–æ–∑—å */
    #prompt-panel { pointer-events: none; }
    #prompt-panel .overlay-panel { pointer-events: auto; }
    /* –û–≤–µ—Ä–ª–µ–∏ –±–∞–Ω–Ω–µ—Ä–æ–≤ */
    .banner { pointer-events:none; }
    /* Turn Splash ‚Äî –Ω–æ–≤—ã–π –≤–∞—É-—ç–∫—Ä–∞–Ω */
    .ts-wrap { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; pointer-events: none; }
    .ts-bg { position: absolute; inset: 0; background: radial-gradient(80% 60% at 50% 50%, rgba(37,99,235,0.22), rgba(2,6,23,0.9)); mix-blend-mode: screen; }
    .ts-title { position: relative; font-weight: 900; letter-spacing: 0.06em; line-height: 1; }
    .ts-title-solid { color: #ffffff; -webkit-text-stroke: 1px rgba(10,15,25,0.55); paint-order: stroke fill; }
    .ts-title-glow { text-shadow: none; }
    .ts-ring { position: absolute; width: 40vmin; height: 40vmin; border-radius: 50%; border: 2px solid rgba(255,255,255,.7); }
    .ts-ring.thin { width: 55vmin; height: 55vmin; opacity: .45; border-color: rgba(255,255,255,.45); }
    .ts-streaks { position: absolute; inset: -20% -20%; transform: rotate(-18deg); background: repeating-linear-gradient(90deg, rgba(255,255,255,0) 0, rgba(255,255,255,0) 16px, rgba(255,255,255,.12) 16px, rgba(255,255,255,.12) 24px); mix-blend-mode: screen; opacity: .35; }
    .ts-scan { position: absolute; inset: 0; background: linear-gradient(to bottom, transparent 0, rgba(255,255,255,.12) 40%, transparent 80%); transform: translateY(-100%); }
    .battlePop { animation: pop 1100ms ease both; }
    @keyframes pop { 0%{ transform:scale(.6); opacity:0 } 40%{ transform:scale(1.06); opacity:1 } 100%{ transform:scale(1); opacity:.96 } }
    /* Flashy BATTLE splash */
    .battle-flash-wrap { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; pointer-events: none; }
    .battle-flash-bg { position: absolute; inset: 0; background: radial-gradient(80% 60% at 50% 50%, rgba(255,255,255,0.08), rgba(0,0,0,0.8)); mix-blend-mode: screen; }
    .battle-flash-text { position: relative; font-weight: 900; letter-spacing: 0.08em; text-shadow: 0 0 20px rgba(255, 236, 153, .9), 0 0 40px rgba(255, 98, 0, .7); }
    .battle-flash-scan { position:absolute; inset:0; background: linear-gradient( to bottom, transparent 0%, rgba(255,255,255,0.08) 50%, transparent 100% ); transform: translateY(-100%); }
    /* Tooltip –¥–ª—è 3D-–∫–æ–ª–æ–¥/–∫–ª–∞–¥–±–∏—â */
    #hover-tooltip { position: fixed; pointer-events: none; z-index: 50; }
  </style>
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
</head>
<body>
  <canvas id="three-canvas"></canvas>
  
  <div id="ui">
    <!-- –ë–æ–∫–æ–≤—ã–µ –ø–∞–Ω–µ–ª–∏: —Å–ª–µ–≤–∞ ‚Äî –∏–≥—Ä–æ–∫ A, —Å–ø—Ä–∞–≤–∞ ‚Äî –∏–≥—Ä–æ–∫ B -->
    <div id="left-side" class="ui-panel fixed left-4 top-1/2 -translate-y-1/2 space-y-3 z-20 flex flex-col items-center">
      <div id="player-title-0" class="text-2xl md:text-3xl font-semibold text-center w-full">–ò–≥—Ä–æ–∫ 1</div>
      <div class="overlay-panel px-4 py-2">
        <div class="text-sm mb-1">–ú–∞–Ω–∞</div>
        <div class="mana-bar" id="mana-display-0"></div>
      </div>
      <div class="overlay-panel px-4 py-2 text-sm" id="control-info-0">–ö–æ–Ω—Ç—Ä–æ–ª—å: 0</div>
    </div>

    <div id="right-side" class="ui-panel fixed right-4 top-1/2 -translate-y-1/2 space-y-3 z-20 flex flex-col items-center">
      <div id="player-title-1" class="text-2xl md:text-3xl font-semibold text-center w-full">–ò–≥—Ä–æ–∫ 2</div>
      <div class="overlay-panel px-4 py-2">
        <div class="text-sm mb-1">–ú–∞–Ω–∞</div>
        <div class="mana-bar" id="mana-display-1"></div>
      </div>
      <div class="overlay-panel px-4 py-2 text-sm" id="control-info-1">–ö–æ–Ω—Ç—Ä–æ–ª—å: 0</div>
    </div>

    <!-- –í–µ—Ä—Ö–Ω–∏–π —Ü–µ–Ω—Ç—Ä: –Ω–æ–º–µ—Ä —Ö–æ–¥–∞ –∏ –∫—Ä—É–≥–ª–∞—è –∫–Ω–æ–ø–∫–∞ —Å —Ç–∞–π–º–µ—Ä–æ–º -->
    <div id="top-center" class="ui-panel fixed top-3 left-1/2 -translate-x-1/2 z-20">
      <div class="overlay-panel px-4 py-3 flex flex-col items-center gap-2">
        <div id="turn-info" class="text-sm tracking-wide">–•–æ–¥: 1</div>
        <button id="end-turn-btn" class="end-turn-btn" aria-label="–ó–∞–≤–µ—Ä—à–∏—Ç—å —Ö–æ–¥">
          <span class="time-fill"></span>
          <span class="label-text">–ö–æ–Ω–µ—Ü —Ö–æ–¥–∞</span>
          <span class="sec-text">100</span>
        </button>
      </div>
    </div>

    <!-- –ü—Ä–∞–≤—ã–π –Ω–∏–∂–Ω–∏–π —É–≥–æ–ª: —Å–µ—Ä–≤–∏—Å–Ω—ã–µ –∫–Ω–æ–ø–∫–∏ -->
    <div id="corner-right" class="ui-panel fixed right-4 bottom-4 z-20">
      <div class="flex gap-2 opacity-90">
        <button id="log-btn" class="overlay-panel px-3 py-1.5 text-xs bg-slate-600 hover:bg-slate-700 transition-colors">–õ–æ–≥</button>
        <button id="help-btn" class="overlay-panel px-3 py-1.5 text-xs bg-slate-600 hover:bg-slate-700 transition-colors">–ü–æ–º–æ—â—å</button>
        <button id="new-game-btn" class="overlay-panel px-3 py-1.5 text-xs bg-slate-600 hover:bg-slate-700 transition-colors">–û—Ñ—Ñ–ª–∞–π–Ω-–∏–≥—Ä–∞</button>
      </div>
    </div>
    
    <!-- –ü–∞–Ω–µ–ª—å –ª–æ–≥–æ–≤ -->
    <div id="log-panel" class="ui-panel fixed right-4 bottom-20 w-96 h-80 overlay-panel p-4 hidden z-30">
      <div class="flex justify-between items-center mb-3">
        <h3 class="text-lg font-semibold">–ñ—É—Ä–Ω–∞–ª —Å–æ–±—ã—Ç–∏–π</h3>
        <button id="close-log-btn" class="text-xl">&times;</button>
      </div>
      <div id="log-content" class="h-full overflow-y-auto text-sm space-y-1"></div>
    </div>
    
    <!-- –ü–∞–Ω–µ–ª—å –ø–æ–º–æ—â–∏ -->
    <div id="help-panel" class="ui-panel fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden z-40">
      <div class="overlay-panel p-6 max-w-lg">
        <div class="flex justify-between items-center mb-4">
          <h3 class="text-xl font-semibold">–ö–∞–∫ –∏–≥—Ä–∞—Ç—å</h3>
          <button id="close-help-btn" class="text-xl">&times;</button>
        </div>
        <div class="space-y-3 text-sm">
          <p>‚Ä¢ –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–π—Ç–µ –∫–∞—Ä—Ç—ã —Å—É—â–µ—Å—Ç–≤ –Ω–∞ –∏–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ</p>
          <p>‚Ä¢ –í—ã–±–∏—Ä–∞–π—Ç–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ—Å–ª–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è</p>
          <p>‚Ä¢ –ö–ª–∏–∫–∞–π—Ç–µ –ø–æ —Å–≤–æ–∏–º —Å—É—â–µ—Å—Ç–≤–∞–º –¥–ª—è –∞—Ç–∞–∫–∏ –∏–ª–∏ –ø–æ–≤–æ—Ä–æ—Ç–∞</p>
          <p>‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∑–∞–∫–ª–∏–Ω–∞–Ω–∏—è, –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞—è –∏—Ö –Ω–∞ —Ü–µ–ª—å –∏–ª–∏ –Ω–∞ –ø–æ–ª–µ</p>
          <p>‚Ä¢ –ü–æ–±–µ–¥–∞: –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–π—Ç–µ 5+ –∫–ª–µ—Ç–æ–∫ –≤ –∫–æ–Ω—Ü–µ —Ö–æ–¥–∞</p>
        </div>
      </div>
    </div>
    
    <!-- –ü–∞–Ω–µ–ª—å –≤—ã–±–æ—Ä–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è -->
    <div id="orientation-panel" class="ui-panel fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden z-40">
      <div class="overlay-panel p-6">
        <div class="text-center mb-4">–í—ã–±–µ—Ä–∏—Ç–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</div>
        <div class="grid grid-cols-3 gap-2 w-48 mx-auto">
          <div></div>
          <button data-dir="N" class="overlay-panel px-4 py-2 hover:bg-slate-700">‚Üë</button>
          <div></div>
          <button data-dir="W" class="overlay-panel px-4 py-2 hover:bg-slate-700">‚Üê</button>
          <div class="overlay-panel px-4 py-2 text-center">‚Ä¢</div>
          <button data-dir="E" class="overlay-panel px-4 py-2 hover:bg-slate-700">‚Üí</button>
          <div></div>
          <button data-dir="S" class="overlay-panel px-4 py-2 hover:bg-slate-700">‚Üì</button>
          <div></div>
        </div>
        <div class="text-center mt-4">
          <button id="cancel-orient-btn" class="overlay-panel px-4 py-2 bg-red-600 hover:bg-red-700">–û—Ç–º–µ–Ω–∞</button>
        </div>
      </div>
    </div>
    
    <!-- –ü–∞–Ω–µ–ª—å –¥–µ–π—Å—Ç–≤–∏–π —Å —Å—É—â–µ—Å—Ç–≤–æ–º -->
    <div id="unit-action-panel" class="ui-panel fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden z-40">
      <div class="overlay-panel p-6 space-y-3">
        <div id="unit-info" class="text-center mb-4"></div>
        <button id="attack-btn" class="w-full overlay-panel px-4 py-2 bg-red-600 hover:bg-red-700">–ê—Ç–∞–∫–æ–≤–∞—Ç—å</button>
        <div class="grid grid-cols-2 gap-2">
          <button id="rotate-cw-btn" class="overlay-panel px-4 py-2 hover:bg-slate-700">–ü–æ–≤–µ—Ä–Ω—É—Ç—å ‚Üª</button>
          <button id="rotate-ccw-btn" class="overlay-panel px-4 py-2 hover:bg-slate-700">–ü–æ–≤–µ—Ä–Ω—É—Ç—å ‚Ü∫</button>
        </div>
        <button id="cancel-action-btn" class="w-full overlay-panel px-4 py-2 bg-gray-600 hover:bg-gray-700">–û—Ç–º–µ–Ω–∞</button>
      </div>
    </div>

    <!-- –ü–æ—Å—Ç–æ—è–Ω–Ω–∞—è –ø–∞–Ω–µ–ª—å –ø–æ–¥—Å–∫–∞–∑–æ–∫/–ø—Ä–æ–º–ø—Ç–æ–≤ -->
    <div id="prompt-panel" class="ui-panel fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden z-40">
      <div class="overlay-panel p-6 space-y-4">
        <div id="prompt-text" class="text-center"></div>
        <div class="text-center">
          <button id="cancel-prompt-btn" class="overlay-panel px-4 py-2 bg-gray-600 hover:bg-gray-700">–û—Ç–º–µ–Ω–∞</button>
        </div>
      </div>
    </div>
    
    <!-- –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è -->
    <div id="notifications" class="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-50 pointer-events-none"></div>

    <!-- –ë–∞–Ω–Ω–µ—Ä—ã: Turn –∏ Battle -->
    <div id="turn-banner" class="banner fixed inset-0 hidden items-center justify-center z-40"></div>
    <div id="battle-banner" class="banner fixed inset-0 hidden items-center justify-center z-40">
      <div class="battlePop text-5xl font-extrabold bg-gradient-to-br from-red-600/80 to-yellow-500/80 px-10 py-5 rounded-3xl shadow-2xl ring-4 ring-yellow-400/40">BATTLE</div>
    </div>
    <!-- Tooltip -->
    <div id="hover-tooltip" class="hidden overlay-panel px-2 py-1 text-xs"></div>
  </div>

  <!-- –í–µ—Ä—Å–∏—è –±–∏–ª–¥–∞ (—Å–≤–µ—Ä—Ö—É —Å–ª–µ–≤–∞) -->
  <div id="build-version" class="fixed left-0 top-0 z-20 text-xs text-slate-300 opacity-80 p-1.5"></div>

  <script>
    // ====== –ò–ì–†–û–í–ê–Ø –õ–û–ì–ò–ö–ê (–ø–æ–ª–Ω–∞—è –≤–µ—Ä—Å–∏—è –∏–∑ 2D) ======
    
    const DIR_VECTORS = { N: [-1, 0], E: [0, 1], S: [1, 0], W: [0, -1] };
    const OPPOSITE_ELEMENT = { FIRE: 'WATER', WATER: 'FIRE', EARTH: 'FOREST', FOREST: 'EARTH' };
    const elementEmoji = { FIRE: 'üî•', WATER: 'üíß', EARTH: 'ü™®', FOREST: 'üå≤', MECH: '‚öôÔ∏è' };
    const turnCW = { N: 'E', E: 'S', S: 'W', W: 'N' };
    const turnCCW = { N: 'W', W: 'S', S: 'E', E: 'N' };
    // –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è–µ–º –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏: N –¥–æ–ª–∂–µ–Ω —Å–º–æ—Ç—Ä–µ—Ç—å –∫ –≤–µ—Ä—Ö–Ω–µ–º—É –∫—Ä–∞—é (‚àíZ), S ‚Äî –∫ –Ω–∏–∂–Ω–µ–º—É (+Z)
    // –í three.js ¬´–≤–ø–µ—Ä—ë–¥¬ª –º–µ—à–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —ç—Ç–æ +Z (0¬∞), –ø–æ—ç—Ç–æ–º—É:
    // S: 0¬∞, E: -90¬∞, W: 90¬∞, N: 180¬∞
    // –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: N (—Å—Ç—Ä–µ–ª–∫–∞ –≤–≤–µ—Ä—Ö) = 0¬∞, S (—Å—Ç—Ä–µ–ª–∫–∞ –≤–Ω–∏–∑) = 180¬∞; E/W –æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –µ—Å—Ç—å
    const facingDeg = { N: 0, E: -90, S: 180, W: 90 };
    
    const uid = () => Math.random().toString(36).slice(2, 9);
    const inBounds = (r, c) => r >= 0 && r < 3 && c >= 0 && c < 3;
    const capMana = (m) => Math.min(10, m);
    const attackCost = (tpl) => (tpl.activation != null ? tpl.activation : Math.max(0, (tpl.cost || 0) - 1));
    
    // –ö–∞—Ä—Ç—ã
    const CARDS = {
      // Fire Set (—é–Ω–∏—Ç—ã)
      FIRE_FLAME_MAGUS: { id:'FIRE_FLAME_MAGUS', name:'Flame Magus', type:'UNIT', cost:1, activation:1, element:'FIRE', atk:1, hp:1, pattern:'FRONT', range:3, attackType:'MAGIC', blindspots:['N','E','S','W'], desc:'Magic Attack: target any creature; no retaliation.' },
      FIRE_HELLFIRE_SPITTER: { id:'FIRE_HELLFIRE_SPITTER', name:'Hellfire Spitter', type:'UNIT', cost:1, activation:1, element:'FIRE', atk:1, hp:1, pattern:'ALL', range:1, firstStrike:true, blindspots:[], desc:'Quickness: always strikes first.' },
      FIRE_FREEDONIAN: { id:'FIRE_FREEDONIAN', name:'Freedonian Wanderer', type:'UNIT', cost:2, activation:1, element:'FIRE', atk:1, hp:2, pattern:'FRONT', range:1, blindspots:['S'], auraGainManaOnSummon:true, desc:'While not on Fire tile, you gain 1 mana on allied summon.' },
      FIRE_FLAME_LIZARD: { id:'FIRE_FLAME_LIZARD', name:'Partmole Flame Lizard', type:'UNIT', cost:2, activation:1, element:'FIRE', atk:2, hp:2, pattern:'FRONT', range:1, blindspots:['S'], firstStrike:true, desc:'Quickness.' },
      FIRE_GREAT_MINOS: { id:'FIRE_GREAT_MINOS', name:'Great Minos of Sciondar', type:'UNIT', cost:3, activation:2, element:'FIRE', atk:2, hp:1, pattern:'FRONT', range:2, blindspots:['S'], dodge50:true, diesOffElement:'FIRE', desc:'Dodge 50% (non-magic). Destroy if not on Fire tile.' },
      FIRE_FLAME_ASCETIC: { id:'FIRE_FLAME_ASCETIC', name:'Flame Ascetic', type:'UNIT', cost:3, activation:2, element:'FIRE', atk:2, hp:3, pattern:'FRONT', range:1, blindspots:['S'], randomPlus2:true, desc:'Attack +2 half the time.' },
      FIRE_TRICEPTAUR: { id:'FIRE_TRICEPTAUR', name:'Triceptaur Behemoth', type:'UNIT', cost:5, activation:4, element:'FIRE', atk:5, hp:4, pattern:'FRONT_SIDES', range:1, blindspots:['S'], penaltyByTargets:true, desc:'If attacks 2 creatures, -2 ATK; if 3 creatures, -4 ATK.' },
      FIRE_PURSUER: { id:'FIRE_PURSUER', name:'Pursuer of Saint Dhees', type:'UNIT', cost:6, activation:3, element:'FIRE', atk:5, hp:4, pattern:'FRONT', range:1, blindspots:['S'], dynamicAtk:'OTHERS_ON_BOARD', desc:'ATK = 5 + number of other creatures on board.' },
      // –°–ø–µ–ª–ª—ã –∏–∑ –¥—Ä—É–≥–∏—Ö –Ω–∞–±–æ—Ä–æ–≤ (–∏–∑ 2D)
      // FREEZE_STREAM —É–¥–∞–ª—ë–Ω
      RAISE_STONE: { id:'RAISE_STONE', name:'–ü–æ–¥—ä—ë–º –ø–æ—Ä–æ–¥—ã', type:'SPELL', cost:2, element:'EARTH', text:'+2 HP –¥—Ä—É–∂–µ—Å—Ç–≤–µ–Ω–Ω–æ–º—É —é–Ω–∏—Ç—É.' },
      // WIND_SHIFT —É–¥–∞–ª—ë–Ω,
      SPELL_FISSURES_OF_GOGHLIE: {
        id: 'SPELL_FISSURES_OF_GOGHLIE', name: 'Fissures of Goghlie', type: 'SPELL',
        element: 'NEUTRAL', spellType: 'CONJURATION', cost: 2,
        text: 'Fieldquake any one field.'
      },
      // –ù–æ–≤—ã–µ —Å–ø–µ–ª–ª—ã
      SPELL_PARMTETIC_HOLY_FEAST: {
        id: 'SPELL_PARMTETIC_HOLY_FEAST', name: 'Parmetic Holy Feast', type: 'SPELL',
        element: 'NEUTRAL', spellType: 'RITUAL', cost: 0, ritualCost: 'discard 1 creature',
        text: 'Discard a creature from hand and gain 2 mana.'
      },
      SPELL_GOGHLIE_ALTAR: {
        id: 'SPELL_GOGHLIE_ALTAR', name: 'Goghlie Altar', type: 'SPELL',
        element: 'NEUTRAL', spellType: 'RITUAL', cost: 0, ritualCost: 'none',
        text: 'Both players gain mana equal to the number of enemy creatures on the board.'
      },
      SPELL_BEGUILING_FOG: {
        id: 'SPELL_BEGUILING_FOG', name: 'Beguiling Fog', type: 'SPELL',
        element: 'NEUTRAL', spellType: 'CONJURATION', cost: 0,
        text: 'Rotate any one creature in any direction.'
      },
      SPELL_CLARE_WILS_BANNER: {
        id: 'SPELL_CLARE_WILS_BANNER', name: "Clare Wil's Banner", type: 'SPELL',
        element: 'NEUTRAL', spellType: 'CONJURATION', cost: 1,
        text: "Targeted allied creature gains +2 Attack until the end of the spellcaster's turn."
      },
      SPELL_SUMMONER_MESMERS_ERRAND: {
        id: 'SPELL_SUMMONER_MESMERS_ERRAND', name: "Summoner Mesmer's Errand", type: 'SPELL',
        element: 'NEUTRAL', spellType: 'CONJURATION', cost: 1,
        text: 'Draw two cards.'
      }
    };
    
    // –°—Ç–∞—Ä—Ç–µ—Ä: —Ç–æ–ª—å–∫–æ Fire Set + –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–ø–µ–ª–ª–æ–≤
    const STARTER_FIRESET = [
      CARDS.FIRE_FLAME_MAGUS,
      CARDS.FIRE_HELLFIRE_SPITTER,
      CARDS.FIRE_FREEDONIAN,
      CARDS.FIRE_FLAME_LIZARD,
      CARDS.FIRE_GREAT_MINOS,
      CARDS.FIRE_FLAME_ASCETIC,
      CARDS.FIRE_TRICEPTAUR,
      CARDS.FIRE_PURSUER,
      CARDS.FIRE_FLAME_MAGUS,
      CARDS.FIRE_HELLFIRE_SPITTER,
      CARDS.FIRE_FLAME_LIZARD,
      CARDS.FIRE_FREEDONIAN,
      CARDS.RAISE_STONE,
      // –î–æ–±–∞–≤–∏–º –Ω–æ–≤—ã–µ —Å–ø–µ–ª–ª—ã –≤ —Å—Ç–∞—Ä—Ç–æ–≤—É—é –∫–æ–ª–æ–¥—É –¥–ª—è —Ç–µ—Å—Ç–∞
      CARDS.SPELL_PARMTETIC_HOLY_FEAST,
      CARDS.SPELL_GOGHLIE_ALTAR,
      CARDS.SPELL_BEGUILING_FOG,
      CARDS.SPELL_CLARE_WILS_BANNER,
      CARDS.SPELL_SUMMONER_MESMERS_ERRAND,
      CARDS.SPELL_FISSURES_OF_GOGHLIE
    ];
    
    // –§—É–Ω–∫—Ü–∏–∏ –∏–≥—Ä–æ–≤–æ–π –ª–æ–≥–∏–∫–∏
    const dirsForPattern = (facing, pattern) => {
      const f = facing, l = turnCCW[f], r = turnCW[f];
      if (pattern === 'FRONT') return [f];
      if (pattern === 'SIDES') return [l, r];
      if (pattern === 'ALL') return ['N', 'E', 'S', 'W'];
      return [f, l, r];
    };
    
    const computeCellBuff = (cellElement, unitElement) => {
      if (cellElement === unitElement) return { atk: 0, hp: 2 };
      if (cellElement === 'MECH') return { atk: 0, hp: 0 };
      const opp = OPPOSITE_ELEMENT[unitElement];
      if (cellElement === opp) return { atk: 0, hp: -2 };
      return { atk: 0, hp: 0 };
    };
    
    const effectiveStats = (cell, unit) => {
      const tpl = CARDS[unit.tplId];
      const buff = computeCellBuff(cell.element, tpl.element);
      // –í—Ä–µ–º–µ–Ω–Ω—ã–π –±–∞—Ñ –∞—Ç–∞–∫–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –æ—Ç Clare Wil's Banner)
      const tempAtk = (typeof unit.tempAtkBuff === 'number') ? unit.tempAtkBuff : 0;
      return { 
        atk: (tpl.atk || 0) + buff.atk + tempAtk, 
        hp: (tpl.hp || 0) + buff.hp 
      };
    };
    
    const randomBoard = () => {
      // 5 —ç–ª–µ–º–µ–Ω—Ç–æ–≤: FIRE, WATER, EARTH, FOREST, MECH
      // –¶–µ–Ω—Ç—Ä (1,1) = MECH. –û—Å—Ç–∞–ª—å–Ω—ã–µ 8 –∫–ª–µ—Ç–æ–∫: –∏–∑ FIRE/WATER/EARTH/FOREST –ø–æ 2 —à—Ç—É–∫–∏ –∫–∞–∂–¥–æ–≥–æ
      const picks = ['FIRE','FIRE','WATER','WATER','EARTH','EARTH','FOREST','FOREST'];
      // –ü–µ—Ä–µ–º–µ—à–∞–µ–º –∏ —Ä–∞–∑–ª–æ–∂–∏–º –ø–æ –∫–ª–µ—Ç–∫–∞–º, –ø—Ä–æ–ø—É—Å–∫–∞—è —Ü–µ–Ω—Ç—Ä
      for (let i = picks.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [picks[i], picks[j]] = [picks[j], picks[i]]; }
      let k = 0;
      const board = Array.from({ length: 3 }, () => Array.from({ length: 3 }, () => ({ element: 'FIRE' })));
      for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 3; c++) {
          if (r === 1 && c === 1) { board[r][c].element = 'MECH'; continue; }
          board[r][c].element = picks[k++];
        }
      }
      return board;
    };
    
    const shuffle = (array) => {
      const result = [...array];
      for (let i = result.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [result[i], result[j]] = [result[j], result[i]];
      }
      return result;
    };
    
    const drawOne = (gameState, player) => {
      if (!gameState.players[player].deck.length) return null;
      const card = gameState.players[player].deck.shift();
      if (card) gameState.players[player].hand.push(card);
      return card || null;
    };

    // –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è: –≤—ã–Ω—É—Ç—å –≤–µ—Ä—Ö–Ω—é—é –∫–∞—Ä—Ç—É, –Ω–æ –ù–ï –∫–ª–∞—Å—Ç—å –≤ —Ä—É–∫—É (–¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–Ω–æ–π –∞–Ω–∏–º–∞—Ü–∏–∏)
    const drawOneNoAdd = (gameState, player) => {
      if (!gameState.players[player].deck.length) return null;
      const card = gameState.players[player].deck.shift();
      return card || null;
    };
    
    const countControlled = (gameState, player) => {
      let count = 0;
      for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 3; c++) {
          if (gameState.board[r][c].unit?.owner === player) count++;
        }
      }
      return count;
    };
    
    const startGame = (deck0, deck1) => {
      const gameState = {
        board: randomBoard(),
        players: [
          { 
            name: '–ò–≥—Ä–æ–∫ 1', 
            deck: shuffle(deck0.filter(Boolean)), 
            hand: [], 
            discard: [], 
            graveyard: [],
            mana: 2 
          },
          { 
            name: '–ò–≥—Ä–æ–∫ 2', 
            deck: shuffle(deck1.filter(Boolean)), 
            hand: [], 
            discard: [], 
            graveyard: [],
            mana: 0 
          }
        ],
        active: 0,
        turn: 1,
        selectedCard: null,
        pending: null,
        winner: null
      };
      
      for (let i = 0; i < 5; i++) {
        drawOne(gameState, 0);
        drawOne(gameState, 1);
      }
      
      return gameState;
    };
    
    // ====== –ë–û–ï–í–ê–Ø –°–ò–°–¢–ï–ú–ê (–ø–æ—Ä—Ç –∏–∑ 2D) ======
    function hasAdjacentGuard(state, r, c) {
      const target = state.board[r][c].unit;
      if (!target) return false;
      for (const [dr, dc] of Object.values(DIR_VECTORS)) {
        const nr = r + dr, nc = c + dc;
        if (!inBounds(nr, nc)) continue;
        const u = state.board[nr][nc].unit;
        if (u && u.owner === target.owner && (CARDS[u.tplId].keywords || []).includes('GUARD')) return true;
      }
      return false;
    }
    
    function computeHits(state, r, c) {
      const attacker = state.board[r][c].unit;
      if (!attacker) return [];
      const tplA = CARDS[attacker.tplId];
      const dirs = dirsForPattern(attacker.facing, tplA.pattern || 'FRONT');
      const { atk } = effectiveStats(state.board[r][c], attacker);
      const hits = [];
      for (const d of dirs) {
        const [dr, dc] = DIR_VECTORS[d];
        const maxRange = Math.max(1, tplA.range || 1);
        for (let step = 1; step <= maxRange; step++) {
          const nr = r + dr * step, nc = c + dc * step;
          if (!inBounds(nr, nc)) break;
          const B = state.board[nr][nc].unit;
          if (!B) continue;
          if (B.owner === attacker.owner) break;
          const aFlying = (tplA.keywords || []).includes('FLYING');
          if (!aFlying && hasAdjacentGuard(state, nr, nc) && !(CARDS[B.tplId].keywords || []).includes('GUARD')) {
            break;
          }
          const backDir = turnCW[turnCW[B.facing]];
          const [bdr, bdc] = DIR_VECTORS[backDir];
          const isBack = (nr + bdr === r && nc + bdc === c);
          // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞ –∞—Ç–∞–∫—É—é—â–µ–≥–æ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –ü–û–í–û–†–û–¢–ê —Ü–µ–ª–∏
          const dirAbs = (() => {
            if (r === nr - 1 && c === nc) return 'N';
            if (r === nr + 1 && c === nc) return 'S';
            if (r === nr && c === nc - 1) return 'W';
            return 'E';
          })();
          const ORDER = ['N','E','S','W'];
          const absIdx = ORDER.indexOf(dirAbs);
          const faceIdx = ORDER.indexOf(B.facing);
          const relIdx = (absIdx - faceIdx + 4) % 4;
          const dirRel = ORDER[relIdx];
          const blind = CARDS[B.tplId].blindspots || ['S'];
          const inBlind = blind.includes(dirRel);
          // –ò—Å–∫–ª—é—á–∞–µ–º –¥–≤–æ–π–Ω–æ–µ –Ω–∞—á–∏—Å–ª–µ–Ω–∏–µ –∑–∞ —Å–ø–∏–Ω—É: –º–∞–∫—Å–∏–º—É–º +1
          const extraTotal = isBack ? 1 : (inBlind ? 1 : 0);
          const dmg = Math.max(0, atk + extraTotal);
          hits.push({ r: nr, c: nc, dmg, backstab: isBack });
          break; // –ø–µ—Ä–≤–∞—è —Ü–µ–ª—å –ø–æ –ª—É—á—É
        }
      }
      return hits;
    }
    
    function stagedAttack(state, r, c) {
      const n1 = structuredClone(state);
      const attacker = n1.board[r][c].unit;
      if (!attacker) return null;
      const tplA = CARDS[attacker.tplId];
      const hits = computeHits(n1, r, c);
      if (!hits.length) return { empty: true };
      const logLines = [];
      const deaths = [];
      const applyDeaths = () => {
        for (let rr = 0; rr < 3; rr++) for (let cc = 0; cc < 3; cc++) {
          const u = n1.board[rr][cc].unit;
          if (u && u.currentHP <= 0) { deaths.push({ r: rr, c: cc, owner: u.owner, tplId: u.tplId }); n1.board[rr][cc].unit = null; }
        }
      };
      const step1 = () => {
        for (const h of hits) {
          const B = n1.board[h.r][h.c].unit; if (!B) continue;
          const before = B.currentHP;
          const attackerTpl = CARDS[attacker.tplId];
          const isMagic = attackerTpl.attackType === 'MAGIC';
          const dodge = CARDS[B.tplId].dodge50 && !isMagic && Math.random() < 0.5;
          const dealt = dodge ? 0 : h.dmg;
          B.currentHP = Math.max(0, B.currentHP - dealt);
          const afterHP = B.currentHP;
          logLines.push(`${CARDS[attacker.tplId].name} ‚Üí ${CARDS[B.tplId].name}: ${dealt} —É—Ä–æ–Ω–∞${h.backstab ? ' (+1 –≤ —Å–ø–∏–Ω—É)' : ''}${dodge ? ' (—É–∫–ª–æ–Ω–µ–Ω–∏–µ)' : ''} (HP ${before}‚Üí${afterHP})`);
        }
      };
      const step2 = () => {
        const still = hits.map(h => ({ h, B: n1.board[h.r][h.c].unit })).filter(x => x.B && x.B.currentHP > 0);
        if (!still.length) return 0;
        let totalRetaliation = 0;
        const retaliators = [];
        for (const { h, B } of still) {
          const tplB = CARDS[B.tplId];
          const dirsB = dirsForPattern(B.facing, tplB.pattern || 'FRONT');
          let retaliates = false;
          for (const d of dirsB) {
            const [dr, dc] = DIR_VECTORS[d];
            if (h.r + dr === r && h.c + dc === c) { retaliates = true; break; }
          }
          if (retaliates) {
            const { atk: batk } = effectiveStats(n1.board[h.r][h.c], B);
            totalRetaliation += Math.max(0, batk);
            retaliators.push({ r: h.r, c: h.c });
          }
        }
        const attackerTpl = CARDS[attacker.tplId];
        const preventRetaliation = attackerTpl.attackType === 'MAGIC';
        if (!preventRetaliation && totalRetaliation > 0 && n1.board[r][c].unit) {
          const A = n1.board[r][c].unit;
          const before = A.currentHP;
          A.currentHP = Math.max(0, A.currentHP - totalRetaliation);
          const afterHP = A.currentHP;
          logLines.push(`–û—Ç–≤–µ—Ç–Ω—ã–π —É—Ä–æ–Ω –ø–æ ${CARDS[A.tplId].name}: ${totalRetaliation} (HP ${before}‚Üí${afterHP})`);
        }
        return { total: totalRetaliation, retaliators };
      };
      const finish = () => {
        applyDeaths();
        // –í–æ–∑–≤—Ä–∞—Ç 1 –º–∞–Ω—ã –≤–ª–∞–¥–µ–ª—å—Ü–∞–º –ø–æ–≥–∏–±—à–∏—Ö —Å—É—â–µ—Å—Ç–≤
        try {
          for (const d of deaths) {
            if (n1 && n1.players && n1.players[d.owner]) {
              n1.players[d.owner].mana = capMana((n1.players[d.owner].mana || 0) + 1);
            }
          }
        } catch {}
        return { n1, logLines, targets: hits.map(h => ({ r: h.r, c: h.c, dmg: h.dmg })), deaths };
      };
      return { step1, step2, finish, n1 };
    }
    
    function magicAttack(state, fr, fc, tr, tc) {
      const n1 = structuredClone(state);
      const attacker = n1.board[fr][fc].unit; const target = n1.board[tr][tc].unit;
      if (!attacker || !target || target.owner === attacker.owner) return null;
      const atkStats = effectiveStats(n1.board[fr][fc], attacker, n1);
      const tplA = CARDS[attacker.tplId];
      const dmg = Math.max(0, (atkStats.atk || 0) + (tplA.randomPlus2 && Math.random() < 0.5 ? 2 : 0));
      const before = target.currentHP;
      target.currentHP = Math.max(0, target.currentHP - dmg);
      const afterHP = target.currentHP;
      const logLines = [`${CARDS[attacker.tplId].name} (Magic) ‚Üí ${CARDS[target.tplId].name}: ${dmg} dmg (HP ${before}‚Üí${afterHP})`];
      // cleanup + —Å–±–æ—Ä —Å–º–µ—Ä—Ç–µ–π
      const deaths = [];
      for (let rr = 0; rr < 3; rr++) for (let cc = 0; cc < 3; cc++) {
        const u = n1.board[rr][cc].unit; if (u && u.currentHP <= 0) { deaths.push({ r: rr, c: cc, owner: u.owner, tplId: u.tplId }); n1.board[rr][cc].unit = null; }
      }
      // –í–æ–∑–≤—Ä–∞—Ç 1 –º–∞–Ω—ã –≤–ª–∞–¥–µ–ª—å—Ü–∞–º –ø–æ–≥–∏–±—à–∏—Ö —Å—É—â–µ—Å—Ç–≤
      try {
        for (const d of deaths) {
          if (n1 && n1.players && n1.players[d.owner]) {
            n1.players[d.owner].mana = capMana((n1.players[d.owner].mana || 0) + 1);
          }
        }
      } catch {}
      return { n1, logLines, dmg, deaths };
    }
    
    // ====== THREE.JS –°–¶–ï–ù–ê ======
    
    let scene, camera, renderer, raycaster, mouse;
    let boardGroup, cardGroup, effectsGroup, metaGroup;
    let tileMeshes = [];
    let tileFrames = [];
    let unitMeshes = [];
    let handCardMeshes = [];
    let gameState = null;
    let logEntries = [];
    let TILE_TEXTURES = {};
    let PROC_TILE_TEXTURES = {};
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–∫–∞–∑–∞ –±–æ–ª—å—à–æ–π –∫–∞—Ä—Ç—ã –ø—Ä–∏ –¥–æ–±–æ—Ä–µ ‚Äî –º–æ–∂–Ω–æ –ø—Ä–∞–≤–∏—Ç—å –∏–∑ –∫–æ–Ω—Å–æ–ª–∏
    window.DRAW_CARD_TUNE = {
      posY: 8.5,   // –≤—ã—Å–æ—Ç–∞
      posZ: 2.4,    // –¥–∏—Å—Ç–∞–Ω—Ü–∏—è –∫ –∫–∞–º–µ—Ä–µ (—á–µ–º –º–µ–Ω—å—à–µ, —Ç–µ–º –±–ª–∏–∂–µ)
      scale: 1.7,   // –º–∞—Å—à—Ç–∞–±
      // –†—É—á–Ω–∞—è –¥–æ–≤—Ä–∞—â–∞–ª–∫–∞ (–≤ –≥—Ä–∞–¥—É—Å–∞—Ö):
      pitchDeg: 45,  // –Ω–∞–∫–ª–æ–Ω –≤–ø–µ—Ä—ë–¥/–Ω–∞–∑–∞–¥ (–æ—Å—å X)
      yawDeg: 0,    // –ø–æ–≤–æ—Ä–æ—Ç –≤–ª–µ–≤–æ/–≤–ø—Ä–∞–≤–æ (–æ—Å—å Y)
      rollDeg: 0    // –∫—Ä–µ–Ω (–æ—Å—å Z)
    };
    let CARD_IMAGES = {};
    let CARD_PENDING = {};
    // –û—á–µ—Ä–µ–¥–∏ –¥–æ–≥–æ–Ω—è—é—â–∏—Ö –∞–Ω–∏–º–∞—Ü–∏–π –±–æ—è –¥–ª—è –Ω–∞–±–ª—é–¥–∞—Ç–µ–ª—è
    let PENDING_BATTLE_ANIMS = [];
    let PENDING_RETALIATIONS = [];
    // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∞–Ω–∏–º–∞—Ü–∏—è–º–∏ –∑–∞—Å—Ç–∞–≤–∫–∏ —Ö–æ–¥–∞ –∏ –¥–æ–±–æ—Ä–∞ –∫–∞—Ä—Ç—ã
    let lastTurnSplashPromise = Promise.resolve();
    let lastSplashTurnRequested = 0;
    let lastSplashTurnShown = 0;
    let turnSplashTurnQueued = 0;
    function queueTurnSplash(title) {
      try {
        lastTurnSplashPromise = lastTurnSplashPromise.then(() => showTurnSplash(title));
      } catch {}
      return lastTurnSplashPromise;
    }
    // –†–µ–∑–µ—Ä–≤: –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ –ø–æ–∫–∞–∑–∞—Ç—å –∑–∞—Å—Ç–∞–≤–∫—É —Å –ø–æ–≤—Ç–æ—Ä–æ–º, –µ—Å–ª–∏ –≤–¥—Ä—É–≥ –Ω–µ –æ—Ç—Ä–∏—Å–æ–≤–∞–ª–∞—Å—å
    async function forceTurnSplashWithRetry(maxRetries = 2) {
      let tries = 0;
      let shown = false;
      while (tries <= maxRetries && !shown) {
        tries += 1;
        await requestTurnSplash();
        // –∂–¥–µ–º 2 –∫–∞–¥—Ä–∞, —á—Ç–æ–±—ã DOM —É—Å–ø–µ–ª –ø—Ä–∏–º–µ–Ω–∏—Ç—å display:flex
        await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
        try {
          const tb = document.getElementById('turn-banner');
          shown = !!tb && (tb.classList.contains('flex') || tb.style.display === 'flex');
        } catch {}
      }
      // –°—Ç—Ä–∞—Ö–æ–≤–∫–∞ –æ—Ç –∑–∞–≤–∏—Å–∞–Ω–∏—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –≤–≤–æ–¥–∞
      setTimeout(() => { splashActive = false; refreshInputLockUI(); }, 2200);
    }
    async function requestTurnSplash() {
      if (!gameState) return;
      const currentTurn = gameState.turn;
      // –µ—Å–ª–∏ —É–∂–µ –ø–æ–∫–∞–∑–∞–ª–∏ –≤ —ç—Ç–æ–º —Ö–æ–¥—É ‚Äî –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º
      if (lastSplashTurnShown >= currentTurn) return lastTurnSplashPromise;
      // –µ—Å–ª–∏ —É–∂–µ —Å—Ç–æ–∏—Ç –≤ –æ—á–µ—Ä–µ–¥–∏ –Ω–∞ —ç—Ç–æ—Ç —Ö–æ–¥ ‚Äî –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –ø—Ä–æ–º–∏—Å
      if (turnSplashTurnQueued === currentTurn) return lastTurnSplashPromise;
      lastSplashTurnRequested = currentTurn;
      turnSplashTurnQueued = currentTurn;
      const title = `–•–æ–¥ ${currentTurn} - –ò–≥—Ä–æ–∫ ${gameState.active + 1}`;
      // –û–±–æ—Ä–∞—á–∏–≤–∞–µ–º –≤ –ø—Ä–æ–º–∏—Å, –∫–æ—Ç–æ—Ä—ã–π –ø–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ –æ—Ç–º–µ—á–∞–µ—Ç —Ö–æ–¥ –ø–æ–∫–∞–∑–∞–Ω–Ω—ã–º
      lastTurnSplashPromise = queueTurnSplash(title).then(() => {
        try { lastSplashTurnShown = currentTurn; } catch {}
        if (turnSplashTurnQueued === currentTurn) turnSplashTurnQueued = 0;
      });
      return lastTurnSplashPromise;
    }
    let __endTurnInProgress = false;
    let drawAnimationActive = false;
    let splashActive = false;
    let manaGainActive = false;
    // –û–∂–∏–¥–∞–µ–º–∞—è –∞–Ω–∏–º–∞—Ü–∏—è –º–∞–Ω—ã: –¥–∏–∞–ø–∞–∑–æ–Ω –Ω–æ–≤—ã—Ö –æ—Ä–±–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –¥–æ–ª–∂–Ω—ã –ø–æ—è–≤–∏—Ç—å—Å—è —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ —Å–æ –≤—Å–ø—ã—à–∫–æ–π
    let PENDING_MANA_ANIM = null; // { ownerIndex, startIdx, endIdx }
    // –ü—Ä—è—á–µ—Ç –æ–¥–∏–Ω —ç–∫–∑–µ–º–ø–ª—è—Ä —Ä–∏—Ç—É–∞–ª—å–Ω–æ–≥–æ —Å–ø–µ–ª–ª–∞ –≤ —Ä—É–∫–µ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞, –ø–æ–∫–∞ –∂–¥—ë–º –≤—ã–±–æ—Ä–∞ –∂–µ—Ä—Ç–≤—ã
    let pendingRitualSpellHandIndex = null;
    // –°–∫–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –¥–æ–±—Ä–∞–Ω–Ω—ã—Ö –∫–∞—Ä—Ç –≤—Ä–µ–º–µ–Ω–Ω–æ —Å–∫—Ä—ã–≤–∞—Ç—å –∏–∑ –º–æ–µ–π —Ä—É–∫–∏ (–¥–ª—è –∫—Ä–∞—Å–∏–≤–æ–π –∞–Ω–∏–º–∞—Ü–∏–∏ –≤–ª—ë—Ç–∞)
    let pendingDrawCount = 0;
    function isInputLocked() {
      return __endTurnInProgress || drawAnimationActive || splashActive || manaGainActive;
    }
    function refreshInputLockUI() {
      try {
        const endBtn = document.getElementById('end-turn-btn');
        if (endBtn) endBtn.disabled = isInputLocked();
      } catch {}
    }
    // –û—Ç—Å—Ç—É–ø —Ä—É–∫–∏ –ø–æ –æ—Å–∏ Z (–ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ ‚Äî –¥–∞–ª—å—à–µ –æ—Ç –∫–∞–º–µ—Ä—ã)
    const HAND_Z_OFFSET = 1.0;
    // –°–º–µ—â–µ–Ω–∏–µ –∫–æ–ª–æ–¥/–∫–ª–∞–¥–±–∏—â –æ—Ç –∫–∞–º–µ—Ä—ã –≤–¥–æ–ª—å –æ—Å–∏ Z (–ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ ‚Äî –¥–∞–ª—å—à–µ –æ—Ç –∫–∞–º–µ—Ä—ã)
    const META_Z_AWAY = 1.5;
    // 3D –æ–±—ä–µ–∫—Ç—ã —Å–ø—Ä–∞–≤–∞ (–∫–æ–ª–æ–¥—ã/–∫–ª–∞–¥–±–∏—â–∞)
    let deckMeshes = [];
    let graveyardMeshes = [];
    let hoveredMeta = null; // { metaType: 'deck'|'grave', player: 0|1 }
    
    // –°–æ—Å—Ç–æ—è–Ω–∏–µ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è
    let draggedCard = null;
    let hoveredTile = null;
    let hoveredHandCard = null;
    let selectedCard = null;
    let pendingPlacement = null;
    let selectedUnit = null;
    let magicFrom = null; // { r, c }
    // –ü–∞—É–∑—ã/—Å–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è –Ω–æ–≤—ã—Ö –º–µ—Ö–∞–Ω–∏–∫
    let pendingSpellOrientation = null; // { spellCardMesh, unitMesh }
    let pendingDiscardSelection = null; // { requiredType: 'UNIT', onPicked: function }
    let activePrompt = null; // { text: string, onCancel: function }
    let pendingRitualBoardMesh = null; // –≤—Ä–µ–º–µ–Ω–Ω—ã–π –º–µ—à —Å–ø–µ–ª–ª–∞ –Ω–∞ –ø–æ–ª–µ
    let spellDragHandled = false; // —Ñ–ª–∞–≥, —á—Ç–æ –≤–æ–∑–≤—Ä–∞—Ç –∫–∞—Ä—Ç—ã –≤ —Ä—É–∫—É —É–∂–µ –Ω–µ –Ω—É–∂–µ–Ω
    
    function initThreeJS() {
      const canvas = document.getElementById('three-canvas');
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.setClearColor(0x0b1220);
      // –¶–≤–µ—Ç–æ–≤–æ–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –∏ —ç–∫—Å–ø–æ–∑–∏—Ü–∏—è ‚Äî –ø–æ–≤—ã—Å–∏–º —á–∏—Ç–∞–µ–º–æ—Å—Ç—å —Ç–µ–∫—Å—Ç—É—Ä
      if (THREE.SRGBColorSpace) {
        renderer.outputColorSpace = THREE.SRGBColorSpace;
      }
      renderer.toneMappingExposure = 1.08;
      
      scene = new THREE.Scene();
      // –°–¥–µ–ª–∞–µ–º –¥–∞–ª—å –º–µ–Ω–µ–µ —Ç—ë–º–Ω–æ–π: —É–±–∏—Ä–∞–µ–º —Ç—É–º–∞–Ω
      scene.fog = null;
      
      camera = new THREE.PerspectiveCamera(54, window.innerWidth / window.innerHeight, 0.1, 120);
      camera.position.set(0, 22, 13);
      camera.lookAt(0, 1.2, 0);
      
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();
      
      boardGroup = new THREE.Group();
      cardGroup = new THREE.Group();
      effectsGroup = new THREE.Group();
      metaGroup = new THREE.Group();
      scene.add(boardGroup);
      scene.add(cardGroup);
      scene.add(effectsGroup);
      scene.add(metaGroup);
      
      // –û—Å–≤–µ—â–µ–Ω–∏–µ
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
      directionalLight.position.set(10, 20, 10);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.set(2048, 2048);
      directionalLight.shadow.camera.near = 1;
      directionalLight.shadow.camera.far = 50;
      directionalLight.shadow.camera.left = -15;
      directionalLight.shadow.camera.right = 15;
      directionalLight.shadow.camera.top = 15;
      directionalLight.shadow.camera.bottom = -15;
      scene.add(directionalLight);
      // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –ø–æ–ª—É—à–∞—Ä–Ω–æ–π —Å–≤–µ—Ç, —á—Ç–æ–±—ã –≤–¥–∞–ª–∏ –±—ã–ª–æ —Å–≤–µ—Ç–ª–µ–µ
      const hemi = new THREE.HemisphereLight(0xcadfff, 0x1a2a3a, 0.6);
      scene.add(hemi);
      
      // –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞
      const platformGeometry = new THREE.CylinderGeometry(32, 32, 0.7, 48);
      const platformMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x1a2332, 
        metalness: 0.7, 
        roughness: 0.3 
      });
      const platform = new THREE.Mesh(platformGeometry, platformMaterial);
      platform.position.y = -0.35;
      platform.receiveShadow = true;
      scene.add(platform);
      // –ó–∞–≥—Ä—É–∑–∫–∞ —Ç–µ–∫—Å—Ç—É—Ä —Ç–∞–π–ª–æ–≤ –ø–æ–ª—è –∏–∑ –ø–∞–ø–∫–∏ textures/
      const loader = new THREE.TextureLoader();
      const ASSET_VERSION = '2';
      const baseMap = { FIRE: './textures/tile_fire.png', WATER: './textures/tile_water.png', EARTH: './textures/tile_earth.png', FOREST: './textures/tile_forest.png', MECH: './textures/tile_mech.png' };
      for (const k in baseMap) {
        const path = `${baseMap[k]}?v=${ASSET_VERSION}`;
        loader.load(
          path,
          (tex) => {
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(1, 1);
            tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
            if (THREE.SRGBColorSpace) tex.colorSpace = THREE.SRGBColorSpace;
            TILE_TEXTURES[k] = tex;
            tex.needsUpdate = true;
            // –ï—Å–ª–∏ –ø–æ–ª–µ —É–∂–µ —Å–æ–∑–¥–∞–Ω–æ ‚Äî –æ–±–Ω–æ–≤–∏–º –º–∞—Ç–µ—Ä–∏–∞–ª—ã —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏—Ö —Ç–∞–π–ª–æ–≤
            try { updateTileMaterialsFor(k); } catch {}
          },
          undefined,
          () => {
            // –µ—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å ‚Äî –æ—Å—Ç–∞–≤–∏–º –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—É—é —Ç–µ–∫—Å—Ç—É—Ä—É –∫–∞–∫ —Ñ–æ–ª–±—ç–∫
            try { console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ç–µ–∫—Å—Ç—É—Ä—É —Ç–∞–π–ª–∞', k, path); } catch {}
          }
        );
      }
    }

    function worldToScreen(vec3) {
      const v = vec3.clone().project(camera);
      const x = (v.x + 1) / 2 * renderer.domElement.clientWidth;
      const y = (1 - v.y) / 2 * renderer.domElement.clientHeight;
      return { x, y };
    }

    function animateManaGainFromWorld(pos, ownerIndex, visualOnly = true) {
      try {
        const start = worldToScreen(pos);
        const barEl = document.getElementById(`mana-display-${ownerIndex}`);
        if (!barEl) return;
        // –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ü–µ–ª–µ–≤—É—é —è—á–µ–π–∫—É: —Ç–µ–∫—É—â–∞—è –º–∞–Ω–∞ = –∏–Ω–¥–µ–∫—Å —Å–ª–æ—Ç–∞ –¥–ª—è –≤–ª—ë—Ç–∞
        const currentMana = (gameState && gameState.players && gameState.players[ownerIndex]) ? (gameState.players[ownerIndex].mana || 0) : 0;
        const targetIdx = Math.min(9, currentMana);
        const child = barEl.children && barEl.children[targetIdx];
        let tx, ty;
        if (child) {
          const srect = child.getBoundingClientRect();
          tx = srect.left + srect.width / 2;
          ty = srect.top + srect.height / 2;
        } else {
          const rect = barEl.getBoundingClientRect();
          tx = rect.left + rect.width / 2;
          ty = rect.top + rect.height / 2;
        }
        const orb = document.createElement('div');
        orb.className = 'mana-orb';
        orb.style.position = 'fixed';
        orb.style.left = start.x + 'px';
        orb.style.top = start.y + 'px';
        orb.style.transform = 'translate(-50%, -50%) scale(0.3)';
        orb.style.opacity = '0';
        orb.style.zIndex = '60';
        document.body.appendChild(orb);
        const tl = gsap.timeline({ onComplete: () => {
          if (orb && orb.parentNode) orb.parentNode.removeChild(orb);
          // –í–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç –∑–∞–≤–µ—Ä—à—ë–Ω. –ò–∑–º–µ–Ω–µ–Ω–∏–µ –º–∞–Ω—ã —Ç–µ–ø–µ—Ä—å –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –≤ –ª–æ–≥–∏–∫–µ –±–æ—è/—Å–ø–µ–ª–ª–æ–≤, –∞ –Ω–µ –∑–¥–µ—Å—å
        }});
        // 0.5—Å –ø–æ—è–≤–ª–µ–Ω–∏–µ, –∑–∞—Ç–µ–º 2.0—Å –ø–æ–ª—ë—Ç –∫ –ø–∞–Ω–µ–ª–∏
        tl.to(orb, { duration: 0.5, ease: 'back.out(1.4)', opacity: 1, transform: 'translate(-50%, -50%) scale(1)' })
          .to(orb, { duration: 2.0, ease: 'power2.inOut', left: tx, top: ty }, '>-0.1');
      } catch {}
    }

    // –≠—Ñ—Ñ–µ–∫—Ç–Ω–∞—è –∞–Ω–∏–º–∞—Ü–∏—è –ø—Ä–∏—Ä–æ—Å—Ç–∞ –º–∞–Ω—ã –≤ –Ω–∞—á–∞–ª–µ —Ö–æ–¥–∞ ‚Äî –≤—Å–ø—ã—à–∫–∞ –æ—Ä–±–æ–≤ –∏ –∏—Å–∫—Ä—ã
    function animateTurnManaGain(ownerIndex, beforeMana, afterMana, durationMs = 1500) {
      manaGainActive = true; refreshInputLockUI();
      // –ì–æ—Ç–æ–≤–∏–º –ø–∞–Ω–µ–ª—å: –±–ª–æ–∫–∏—Ä—É–µ–º —Ä–∞–Ω–Ω–µ–µ –ø–æ—è–≤–ª–µ–Ω–∏–µ –Ω–æ–≤—ã—Ö –æ—Ä–±–æ–≤ –∏ –ø–µ—Ä–µ—Å–æ–±–∏—Ä–∞–µ–º UI
      try {
        const startIdx = Math.max(0, Math.min(9, beforeMana));
        const endIdx = Math.max(-1, Math.min(9, afterMana - 1));
        PENDING_MANA_ANIM = { ownerIndex, startIdx, endIdx };
        updateUI();
      } catch {}
      const bar = document.getElementById(`mana-display-${ownerIndex}`);
      if (!bar) { manaGainActive = false; refreshInputLockUI(); return Promise.resolve(); }
      const startIdx = Math.max(0, Math.min(9, beforeMana));
      const endIdx = Math.max(-1, Math.min(9, afterMana - 1));
      const indices = [];
      for (let i = startIdx; i <= endIdx; i++) indices.push(i);
      const sparks = [];
      const cleanup = () => {
        for (const s of sparks) { try { if (s.parentNode) s.parentNode.removeChild(s); } catch {} }
        manaGainActive = false; refreshInputLockUI();
        // –†–∞–∑–±–ª–æ–∫–∏—Ä—É–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–∞–Ω–µ–ª–∏ –º–∞–Ω—ã –∏ —Ñ–∏–Ω–∞–ª—å–Ω–æ –¥–æ—Ä–∏—Å—É–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        try { PENDING_MANA_ANIM = null; updateUI(); } catch {}
      };
      if (indices.length === 0) {
        const tl = gsap.timeline({ onComplete: cleanup });
        tl.to(bar, { filter: 'brightness(2.1) drop-shadow(0 0 16px rgba(96,165,250,0.95))', duration: 0.154, ease: 'power2.out' })
          .to(bar, { filter: 'none', duration: 0.42, ease: 'power2.inOut' })
          .to({}, { duration: Math.max(0, (durationMs/1000) - 0.574) });
        return new Promise(resolve => tl.eventCallback('onComplete', () => { cleanup(); resolve(); }));
      }
      const tl = gsap.timeline({ onComplete: cleanup });
      for (const idx of indices) {
        const el = bar.children[idx]; if (!el) continue;
        el.style.willChange = 'transform, box-shadow, filter, opacity';
        el.style.transformOrigin = '50% 50%';
        // –ù–∞ —Å—Ç–∞—Ä—Ç–µ –≤—Å—Ç–∞–≤–ª—è–µ–º –ø—É—Å—Ç—É—é —è—á–µ–π–∫—É –∏ —Ä–æ–≤–Ω–æ –≤ —ç—Ç–æ—Ç –∂–µ —Ç–∏–∫ –ø—Ä–µ–≤—Ä–∞—â–∞–µ–º –µ—ë –≤ –æ—Ä–± + –≤—Å–ø—ã—à–∫–∞
        tl.call(() => { try { el.className = 'mana-orb'; el.style.opacity = '1'; } catch {} }, null, 0)
          .to(el, { duration: 0.196, ease: 'back.out(2.2)', onStart: () => { el.style.boxShadow = '0 0 22px rgba(96,165,250,0.95), 0 0 44px rgba(56,189,248,0.85)'; }, onComplete: () => { el.style.boxShadow = '0 0 12px rgba(30,160,255,0.85)'; } }, 0)
          .to(el, { scale: 2.5, duration: 0.196, ease: 'back.out(2.2)' }, 0)
          .to(el, { scale: 1.0, duration: 0.42, ease: 'power2.inOut' }, 0.196);
        const rect = el.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const count = 16;
        for (let i = 0; i < count; i++) {
          const sp = document.createElement('div');
          sp.style.position = 'fixed';
          sp.style.left = `${centerX}px`;
          sp.style.top = `${centerY}px`;
          sp.style.width = '4px'; sp.style.height = '4px';
          sp.style.borderRadius = '50%';
          sp.style.pointerEvents = 'none';
          sp.style.background = 'radial-gradient(circle, rgba(255,255,255,1) 0%, rgba(125,211,252,1) 60%, rgba(14,165,233,0.8) 100%)';
          sp.style.boxShadow = '0 0 10px rgba(59,130,246,0.95)';
          sp.style.opacity = '0';
          sp.style.zIndex = '70';
          document.body.appendChild(sp);
          sparks.push(sp);
          const angle = (Math.PI * 2) * (i / count) + Math.random() * 0.8;
          const dist = 40 + Math.random() * 40;
          const dx = Math.cos(angle) * dist;
          const dy = Math.sin(angle) * dist;
          const t0 = (idx - startIdx) * 0.056;
          tl.fromTo(sp, { x: 0, y: 0, opacity: 0, scale: 0.6 }, { x: dx, y: dy, opacity: 1, scale: 1.2, duration: 0.154, ease: 'power2.out' }, t0)
            .to(sp, { opacity: 0, scale: 0.3, duration: 0.35, ease: 'power1.in', delay: 0.105 }, `>-0.1`);
        }
      }
      tl.to({}, { duration: Math.max(0, (durationMs/1000) - tl.duration()) });
      return new Promise(resolve => tl.eventCallback('onComplete', () => { cleanup(); resolve(); }));
    }

    function preloadCardImages() {
      const exts = ['png'];
      const basenameCandidates = (tpl) => {
        const safe = (s) => s
          .toLowerCase()
          .replace(/[^a-z0-9\s_-]/g, '')
          .replace(/\s+/g, '_');
        return [tpl.id, tpl.id.toLowerCase(), safe(tpl.name), safe(tpl.name).replace(/_/g,'-')];
      };
      const scheduleUpdate = (() => {
        let t = null; return () => { clearTimeout(t); t = setTimeout(()=>{ updateHand(); updateUnits(); }, 10); };
      })();
      for (const tpl of Object.values(CARDS)) {
        if (!tpl || tpl.type !== 'UNIT') continue;
        const bases = basenameCandidates(tpl);
        (function tryNextBase(iBase) {
          if (iBase >= bases.length) return;
          (function tryExt(iExt) {
            if (iExt >= exts.length) { tryNextBase(iBase + 1); return; }
            const key = bases[iBase];
            const url = `card images/${bases[iBase]}.${exts[iExt]}`;
            const img = new Image();
            img.onload = () => { CARD_IMAGES[tpl.id] = img; CARD_IMAGES[bases[iBase]] = img; scheduleUpdate(); };
            img.onerror = () => tryExt(iExt + 1);
            img.src = encodeURI(url);
          })(0);
        })(0);
      }
    }

    function requestCardsRedraw() {
      clearTimeout(window.__cardsRedrawT);
      window.__cardsRedrawT = setTimeout(() => { updateUnits(); updateHand(); }, 10);
    }

    function createProceduralTileTexture(element) {
      if (PROC_TILE_TEXTURES[element]) return PROC_TILE_TEXTURES[element];
      const c = document.createElement('canvas');
      c.width = 256; c.height = 256; const ctx = c.getContext('2d');
      // —Ñ–æ–Ω
      const base = {
        FIRE: '#3b0d0d', WATER: '#0d243b', EARTH: '#2f2b24', FOREST: '#0f2b1a', MECH: '#1f2937'
      }[element] || '#2a2a2a';
      ctx.fillStyle = base; ctx.fillRect(0,0,256,256);
      ctx.globalAlpha = 0.5;
      if (element === 'FIRE') {
        for (let i= -64; i<256; i+=24) {
          ctx.fillStyle = i % 48 === 0 ? '#b91c1c' : '#ef4444';
          ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i+64,0); ctx.lineTo(i+256,256); ctx.lineTo(i+192,256); ctx.closePath(); ctx.fill();
        }
      } else if (element === 'WATER') {
        ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 3; ctx.globalAlpha = 0.7;
        for (let y=20; y<256; y+=24) {
          ctx.beginPath(); for (let x=0; x<=256; x+=8) { ctx.lineTo(x, y + Math.sin((x+y)/20)*6); } ctx.stroke();
        }
      } else if (element === 'EARTH') {
        for (let y=0; y<256; y+=16) {
          for (let x=0; x<256; x+=16) {
            const v = 40 + Math.floor(Math.random()*30);
            ctx.fillStyle = `rgb(${v+60},${v+40},${v})`; ctx.fillRect(x,y,16,16);
          }
        }
      } else if (element === 'FOREST') {
        ctx.fillStyle = '#16a34a';
        for (let i=0; i<180; i++) {
          const x = Math.random()*256; const y = Math.random()*256; const r = Math.random()*3+1;
          ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
        }
        ctx.strokeStyle = '#22c55e'; ctx.globalAlpha = 0.35;
        for (let i=0; i<40; i++) { ctx.beginPath(); ctx.moveTo(Math.random()*256, Math.random()*256); ctx.lineTo(Math.random()*256, Math.random()*256); ctx.stroke(); }
      } else if (element === 'MECH') {
        // –ø—Ä–æ—Å—Ç–∞—è —Ç–µ—Ö–Ω–æ-—Å–µ—Ç–∫–∞
        ctx.globalAlpha = 0.6; ctx.strokeStyle = '#9ca3af'; ctx.lineWidth = 1.5;
        for (let y=16; y<256; y+=16) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(256,y); ctx.stroke(); }
        for (let x=16; x<256; x+=16) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,256); ctx.stroke(); }
        ctx.globalAlpha = 0.9; ctx.fillStyle = '#94a3b8';
        for (let i=0; i<40; i++) { const x= Math.floor(Math.random()*16)*16+2; const y=Math.floor(Math.random()*16)*16+2; ctx.fillRect(x,y,2,2); }
      }
      const tex = new THREE.CanvasTexture(c); tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
      tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping; tex.repeat.set(1,1);
      PROC_TILE_TEXTURES[element] = tex; return tex;
    }
    
    // –ë–∞–∑–æ–≤—ã–µ —Ü–≤–µ—Ç–∞ –¥–ª—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ (—Ñ–æ–ª–±—ç–∫, –µ—Å–ª–∏ —Ç–µ–∫—Å—Ç—É—Ä—ã –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª–∏—Å—å)
    const ELEMENT_BASE_COLORS = {
      FIRE: 0xdc2626,
      WATER: 0x0369a1,
      EARTH: 0x525252,
      FOREST: 0x166534,
      MECH: 0x334155
    };

    function getTileMaterial(element) {
      let tex = TILE_TEXTURES[element];
      // –ï—Å–ª–∏ —Ç–µ–∫—Å—Ç—É—Ä–∞ –µ—â—ë –Ω–µ –≥–æ—Ç–æ–≤–∞, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—É—é
      if (!tex || !tex.image || !tex.image.width) tex = createProceduralTileTexture(element);
      if (tex) return new THREE.MeshBasicMaterial({ map: tex });
      return new THREE.MeshStandardMaterial({
        color: ELEMENT_BASE_COLORS[element] || 0x64748b,
        metalness: 0.12,
        roughness: 0.6,
        emissive: 0x1a1a1a,
        emissiveIntensity: 0.18
      });
    }

    // –û–±–Ω–æ–≤–∏—Ç—å –º–∞—Ç–µ—Ä–∏–∞–ª—ã —É–∂–µ —Å–æ–∑–¥–∞–Ω–Ω—ã—Ö —Ç–∞–π–ª–æ–≤ –ø—Ä–∏ –ø–æ–¥–≥—Ä—É–∑–∫–µ —Ç–µ–∫—Å—Ç—É—Ä—ã
    function updateTileMaterialsFor(elementKey) {
      if (!tileMeshes || !tileMeshes.length) return;
      const tex = TILE_TEXTURES[elementKey];
      if (!tex) return;
      for (let r = 0; r < tileMeshes.length; r++) {
        const row = tileMeshes[r]; if (!row) continue;
        for (let c = 0; c < row.length; c++) {
          const tile = row[c]; if (!tile) continue;
          const cell = (gameState && gameState.board && gameState.board[r] && gameState.board[r][c]) ? gameState.board[r][c] : null;
          if (cell && cell.element === elementKey) {
            // –æ—Å–≤–æ–±–æ–∂–¥–∞–µ–º —Å—Ç–∞—Ä—ã–π –º–∞—Ç–µ—Ä–∏–∞–ª –∏ –Ω–∞–∑–Ω–∞—á–∞–µ–º –Ω–æ–≤—ã–π —Å —Ç–µ–∫—Å—Ç—É—Ä–æ–π
            try { tile.material.dispose && tile.material.dispose(); } catch {}
            const mat = new THREE.MeshBasicMaterial({ map: tex });
            tile.material = mat;
            tile.material.needsUpdate = true;
          }
        }
      }
      // –ü–µ—Ä–µ—Ä–∏—Å—É–µ–º –∫–∞–¥—Ä
      try { renderer && renderer.render(scene, camera); } catch {}
    }
    
    function createBoard() {
      tileMeshes.forEach(row => row.forEach(tile => {
        if (tile) boardGroup.remove(tile);
      }));
      tileFrames.forEach(row => row.forEach(f => { if (f) boardGroup.remove(f); }));
      tileMeshes = [];
      tileFrames = [];
      
      if (!gameState) return;
      
      const tileSize = 6.2; // —É–≤–µ–ª–∏—á–µ–Ω–æ
      const tileHeight = 0.35;
      const spacing = 0.2;
      const boardYOffset = 0.0; // –æ–ø—É—â–µ–Ω–æ –±–ª–∏–∂–µ –∫ –ø–ª–∞—Ç—Ñ–æ—Ä–º–µ. –í–∞–∂–Ω–æ
      const boardZShift = -3.5; // –æ—Ç–æ–¥–≤–∏–Ω—É—Ç—å –ø–æ–ª–µ –¥–∞–ª—å—à–µ –æ—Ç –∫–∞–º–µ—Ä—ã/—Ä—É–∫–∏. –í–∞–∂–Ω–æ
      
      for (let r = 0; r < 3; r++) {
        const row = [];
        const frameRow = [];
        for (let c = 0; c < 3; c++) {
          const cell = gameState.board[r][c];
          
          const geometry = new THREE.BoxGeometry(tileSize, tileHeight, tileSize);
          const material = getTileMaterial(cell.element);
          const tile = new THREE.Mesh(geometry, material);
          
          const x = (c - 1) * (tileSize + spacing);
          const z = (r - 1) * (tileSize + spacing) + boardZShift;
          tile.position.set(x, tileHeight / 2 + boardYOffset, z);
          tile.castShadow = false;
          tile.receiveShadow = true;
          
          tile.userData = { type: 'tile', row: r, col: c, element: cell.element };
          
          boardGroup.add(tile);
          row.push(tile);

          // –†–∞–º–∫–∞ –≤–ª–∞–¥–µ–Ω–∏—è (—Ç–æ–ª—Å—Ç–∞—è, –∏–∑ 4 —Å–µ–≥–º–µ–Ω—Ç–æ–≤)
          const frame = new THREE.Group();
          const borderT = 0.18; // —Ç–æ–ª—â–∏–Ω–∞ —Ä–∞–º–∫–∏ (—É–≤–µ–ª–∏—á–µ–Ω–æ)
          const h = 0.018; // –≤—ã—Å–æ—Ç–∞ —Ä–∞–º–∫–∏ –Ω–∞–¥ —Ç–∞–π–ª–æ–º
          const frameMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, depthTest: true, depthWrite: false, opacity: 0.0 });
          const top    = new THREE.Mesh(new THREE.BoxGeometry(tileSize + 0.04, h, borderT), frameMat.clone());
          const bottom = new THREE.Mesh(new THREE.BoxGeometry(tileSize + 0.04, h, borderT), frameMat.clone());
          const left   = new THREE.Mesh(new THREE.BoxGeometry(borderT, h, tileSize + 0.04), frameMat.clone());
          const right  = new THREE.Mesh(new THREE.BoxGeometry(borderT, h, tileSize + 0.04), frameMat.clone());
          top.position.set(x, tileHeight + boardYOffset + h/2 + 0.002, z - (tileSize/2 - borderT/2));
          bottom.position.set(x, tileHeight + boardYOffset + h/2 + 0.002, z + (tileSize/2 - borderT/2));
          left.position.set(x - (tileSize/2 - borderT/2), tileHeight + boardYOffset + h/2 + 0.002, z);
          right.position.set(x + (tileSize/2 - borderT/2), tileHeight + boardYOffset + h/2 + 0.002, z);
          for (const seg of [top, bottom, left, right]) { seg.renderOrder = 600; frame.add(seg); }
          frame.renderOrder = 800; // –Ω–∏–∂–µ –∫–∞—Ä—Ç –≤ —Ä—É–∫–µ, –Ω–æ –≤—ã—à–µ —Ç–∞–π–ª–∞
          boardGroup.add(frame);
          frameRow.push(frame);
        }
        tileMeshes.push(row);
        tileFrames.push(frameRow);
      }
    }
    
    function createCard3D(cardData, isInHand = false, hpOverride = null, atkOverride = null) {
      const cardWidth = 4.8;  // —É–≤–µ–ª–∏—á–µ–Ω–æ ~–≤ 2-3 —Ä–∞–∑–∞
      const cardHeight = 5.6; // –ø–æ—á—Ç–∏ –≤—Å—è —è—á–µ–π–∫–∞
      const cardThickness = 0.12;
      
      const geometry = new THREE.BoxGeometry(cardWidth, cardThickness, cardHeight);
      
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 356;
      const ctx = canvas.getContext('2d');
      
      drawCardFace(ctx, cardData, canvas.width, canvas.height, hpOverride, atkOverride);
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      if (THREE.SRGBColorSpace) texture.colorSpace = THREE.SRGBColorSpace;
      
      const faceMaterial = new THREE.MeshStandardMaterial({ 
        map: texture, 
        metalness: 0.1, 
        roughness: 0.7,
        side: THREE.DoubleSide
      });
      
      const edgeMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x1e293b, 
        metalness: 0.3, 
        roughness: 0.8 
      });
      
      const backMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x0f172a, 
        metalness: 0.2, 
        roughness: 0.9,
        side: THREE.DoubleSide
      });
      
      const materials = [
        edgeMaterial, edgeMaterial, /* +Y top (–ª–∏—Ü–æ) */ faceMaterial, /* -Y bottom (—Ä—É–±–∞—à–∫–∞) */ backMaterial, edgeMaterial, edgeMaterial
      ];
      
      const card = new THREE.Mesh(geometry, materials);
      card.castShadow = true;
      card.receiveShadow = false;
      card.renderOrder = isInHand ? 3000 : 1200;
      
      card.userData = {
        type: 'card',
        cardData: cardData,
        isInHand: isInHand,
        originalPosition: new THREE.Vector3(),
        originalRotation: new THREE.Euler()
      };
      
      // –ú–∞—Å—à—Ç–∞–± –¥–ª—è —Ä—É–∫–∏ ‚Äî +50%
      if (isInHand) {
        card.scale.set(0.54, 1, 0.54);
      }
      // –ù–∞–∫–ª–∞–¥—ã–≤–∞–µ–º —Ç–æ–Ω–∫–∏–π –æ–≤–µ—Ä–ª–µ–π –≤—Å–µ–π –ª–∏—Ü–µ–≤–æ–π —Å—Ç–æ—Ä–æ–Ω—ã, —á—Ç–æ–±—ã –∏—Å–∫–ª—é—á–∏—Ç—å –≤–∏–∑—É–∞–ª—å–Ω—ã–µ –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã
      try {
        const w = geometry.parameters.width; const t = geometry.parameters.height; const h = geometry.parameters.depth;
        const faceOverlayGeom = new THREE.PlaneGeometry(w, h);
        const faceOverlayMat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
        faceOverlayMat.depthTest = true;
        faceOverlayMat.depthWrite = false;
        faceOverlayMat.polygonOffset = true;
        faceOverlayMat.polygonOffsetFactor = -2;
        faceOverlayMat.polygonOffsetUnits = -2;
        const faceOverlay = new THREE.Mesh(faceOverlayGeom, faceOverlayMat);
        faceOverlay.rotation.x = -Math.PI/2;
        faceOverlay.position.set(0, (t/2) + 0.002, 0);
        faceOverlay.renderOrder = (card.renderOrder || 1200) + 1;
        faceOverlay.userData = { kind: 'faceOverlay' };
        card.add(faceOverlay);
      } catch {}
      // –ï—Å–ª–∏ —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –∑–∞–ø—É—â–µ–Ω–∞ –∫–∞–∫ file:// ‚Äî –Ω–∞–∫–ª–∞–¥—ã–≤–∞–µ–º –∏–ª–ª—é—Å—Ç—Ä–∞—Ü–∏—é –æ—Ç–¥–µ–ª—å–Ω–æ–π –ø–ª–æ—Å–∫–æ—Å—Ç—å—é, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å tainted canvas
      try { if (location && location.protocol === 'file:') attachIllustrationPlane(card, cardData); } catch {}
      return card;
    }

    function attachIllustrationPlane(cardMesh, cardData) {
      if (!cardMesh || !cardData) return;
      // –£–¥–∞–ª–∏–º –ø—Ä–æ—à–ª—É—é
      const prev = cardMesh.children?.find(ch => ch.userData && ch.userData.kind === 'illustrationPlane');
      if (prev) { cardMesh.remove(prev); }
      const img = CARD_IMAGES[cardData.id] || CARD_IMAGES[cardData.id?.toLowerCase?.()] || CARD_IMAGES[(cardData.name||'').toLowerCase().replace(/[^a-z0-9\s_-]/g,'').replace(/\s+/g,'_')];
      // –ï—Å–ª–∏ –∏–ª–ª—é—Å—Ç—Ä–∞—Ü–∏—è –µ—â—ë –Ω–µ –≥–æ—Ç–æ–≤–∞ (—á–∞—Å—Ç–∞—è —Å–∏—Ç—É–∞—Ü–∏—è –ø—Ä–∏ file://) ‚Äî –¥–æ–±–∞–≤–∏–º –≤—Ä–µ–º–µ–Ω–Ω—É—é –∑–∞–≥–ª—É—à–∫—É
      if (!img || !img.complete) {
        try {
          const W = 256, H = 356; const illX = 16, illY = 70, illW = W - 32, illH = 120;
          const w = cardMesh.geometry.parameters.width; const t = cardMesh.geometry.parameters.height; const h = cardMesh.geometry.parameters.depth;
          const planeW = w * (illW / W); const planeH = h * (illH / H);
          const centerX = (illX + illW/2) / W; const centerY = (illY + illH/2) / H;
          const offsetX = (centerX - 0.5) * w; const offsetZ = (centerY - 0.5) * h;
          const c = document.createElement('canvas'); c.width = 64; c.height = 64; const cx = c.getContext('2d');
          const grd = cx.createLinearGradient(0,0,64,64); grd.addColorStop(0,'#1e293b'); grd.addColorStop(1,'#334155');
          cx.fillStyle = grd; cx.fillRect(0,0,64,64);
          cx.fillStyle = '#94a3b8'; cx.font = '10px Arial'; cx.textAlign = 'center'; cx.textBaseline = 'middle'; cx.fillText('Loading‚Ä¶', 32, 32);
          const tex = new THREE.CanvasTexture(c); if (THREE.SRGBColorSpace) tex.colorSpace = THREE.SRGBColorSpace;
          const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, side: THREE.DoubleSide });
          const geom = new THREE.PlaneGeometry(planeW, planeH);
          const plane = new THREE.Mesh(geom, mat);
          plane.rotation.x = -Math.PI/2;
          plane.position.set(offsetX, (t/2) + 0.001, offsetZ);
          plane.renderOrder = (cardMesh.renderOrder || 1200) + 1;
          plane.userData = { kind: 'illustrationPlane' };
          cardMesh.add(plane);
        } catch {}
        return;
      }
      // –ü—Ä–æ–ø–æ—Ä—Ü–∏–∏ –æ–±–ª–∞—Å—Ç–∏ –∏–ª–ª—é—Å—Ç—Ä–∞—Ü–∏–∏ –∏–∑ –º–∞–∫–µ—Ç–∞ –∫–∞–Ω–≤–∞—Å–∞ 256x356
      const W = 256, H = 356; const illX = 16, illY = 70, illW = W - 32, illH = 120;
      // –ì–∞–±–∞—Ä–∏—Ç—ã –∫–∞—Ä—Ç—ã
      const w = cardMesh.geometry.parameters.width; const t = cardMesh.geometry.parameters.height; const h = cardMesh.geometry.parameters.depth;
      const planeW = w * (illW / W); const planeH = h * (illH / H);
      const centerX = (illX + illW/2) / W; const centerY = (illY + illH/2) / H;
      const offsetX = (centerX - 0.5) * w; const offsetZ = (centerY - 0.5) * h;
      const tex = new THREE.Texture(img); tex.needsUpdate = true; if (THREE.SRGBColorSpace) tex.colorSpace = THREE.SRGBColorSpace;
      const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, side: THREE.DoubleSide });
      const geom = new THREE.PlaneGeometry(planeW, planeH);
      const plane = new THREE.Mesh(geom, mat);
      plane.rotation.x = -Math.PI/2; // –ª–µ—á—å –Ω–∞ –ª–∏—Ü–µ–≤—É—é —Å—Ç–æ—Ä–æ–Ω—É (+Y)
      plane.position.set(offsetX, (t/2) + 0.001, offsetZ);
      plane.renderOrder = (cardMesh.renderOrder || 1200) + 1;
      plane.userData = { kind: 'illustrationPlane' };
      cardMesh.add(plane);
    }
    function drawCardFace(ctx, cardData, width, height, hpOverride = null, atkOverride = null) {
      const gradient = ctx.createLinearGradient(0, 0, 0, height);
      gradient.addColorStop(0, '#1e293b');
      gradient.addColorStop(1, '#0f172a');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);
      
      ctx.strokeStyle = getElementColor(cardData.element);
      ctx.lineWidth = 4;
      ctx.strokeRect(4, 4, width - 8, height - 8);
      
      ctx.fillStyle = '#f1f5f9';
      ctx.font = 'bold 18px Arial, sans-serif';
      ctx.textAlign = 'center';
      const name = cardData.name.length > 20 ? cardData.name.substring(0, 20) + '...' : cardData.name;
      ctx.fillText(name, width / 2, 30);
      
      ctx.font = '24px Arial';
      ctx.fillText(elementEmoji[cardData.element] || '', width / 2, 55);
      
      // –ò–ª–ª—é—Å—Ç—Ä–∞—Ü–∏—è
      const illX = 16, illY = 70, illW = width - 32, illH = 120;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
      ctx.fillRect(illX, illY, illW, illH);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.lineWidth = 2;
      ctx.strokeRect(illX, illY, illW, illH);
      let img = CARD_IMAGES[cardData.id] || CARD_IMAGES[cardData.id?.toLowerCase?.()] || CARD_IMAGES[(cardData.name||'').toLowerCase().replace(/[^a-z0-9\s_-]/g,'').replace(/\s+/g,'_')];
      if (!img && !CARD_PENDING[cardData.id]) {
        // –õ–µ–Ω–∏–≤–∞—è –ø–æ–¥–≥—Ä—É–∑–∫–∞ –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π (–µ—Å–ª–∏ –ø—Ä–µ–ª–æ–∞–¥–µ—Ä –Ω–µ —É—Å–ø–µ–ª/–Ω–µ –Ω–∞—à—ë–ª)
        CARD_PENDING[cardData.id] = true;
        const candidates = [
          `card images/${cardData.id}.png`,
          `card images/${(cardData.id||'').toLowerCase()}.png`,
          `card images/${(cardData.name||'').toLowerCase().replace(/[^a-z0-9\s_-]/g,'').replace(/\s+/g,'_')}.png`,
          `card images/${(cardData.name||'').toLowerCase().replace(/[^a-z0-9\s_-]/g,'').replace(/\s+/g,'-')}.png`
        ];
        (function tryLoad(i){
          if (i>=candidates.length) { CARD_PENDING[cardData.id] = false; return; }
          const im = new Image();
          im.onload = () => { CARD_IMAGES[cardData.id] = im; CARD_PENDING[cardData.id] = false; requestCardsRedraw(); };
          im.onerror = () => tryLoad(i+1);
          im.src = encodeURI(candidates[i]);
        })(0);
      }
      if (img && img.complete && !(typeof location !== 'undefined' && location.protocol === 'file:')) {
        // –≤–ø–∏—à–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º —Å—Ç–æ—Ä–æ–Ω
        const ar = img.width / img.height;
        let w = illW, h = illH;
        if (w / h > ar) { w = h * ar; } else { h = w / ar; }
        const dx = illX + (illW - w) / 2; const dy = illY + (illH - h) / 2;
        try { ctx.drawImage(img, dx, dy, w, h); } catch {}
      } else {
        ctx.fillStyle = '#94a3b8';
        ctx.font = '12px Arial';
        ctx.fillText('Illustration', width / 2, 135);
      }
      
      
      ctx.fillStyle = '#cbd5e1';
      ctx.font = '11px Arial';
      ctx.textAlign = 'left';
      const text = cardData.desc || cardData.text || (cardData.keywords ? cardData.keywords.join(', ') : '');
      wrapText(ctx, text, 16, 210, width - 32, 14);
      
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(0, height - 40, width, 40);
      
      ctx.fillStyle = '#f1f5f9';
      ctx.font = 'bold 14px Arial';
      ctx.textAlign = 'left';
      const summonCostText = `üíé${cardData.cost || 0}`;
      ctx.fillText(summonCostText, 16, height - 15);
      // –°—Ç–æ–∏–º–æ—Å—Ç—å –¥–µ–π—Å—Ç–≤–∏—è ‚ö° ‚Äî –ø–µ—Ä–µ–Ω–æ—Å–∏–º —Ä—è–¥–æ–º, –Ω–µ–º–Ω–æ–≥–æ –ø—Ä–∞–≤–µ–µ, —á—Ç–æ–±—ã —á–∏—Ç–∞–ª–æ—Å—å –∫–∞–∫ –ø–∞—Ä–∞
      if (cardData.type === 'UNIT') {
        ctx.textAlign = 'left';
        ctx.font = 'bold 13px Arial';
        const act = (cardData.activation != null) ? cardData.activation : Math.max(0, (cardData.cost || 0) - 1);
        const shift = ctx.measureText(summonCostText).width + 10;
        ctx.fillText(`‚ö°${act}`, 16 + shift, height - 15);
      }
      
      if (cardData.type === 'UNIT') {
        ctx.textAlign = 'right';
        const hpToShow = (hpOverride != null) ? hpOverride : (cardData.hp || 0);
        const atkToShow = (atkOverride != null) ? atkOverride : (cardData.atk || 0);
        ctx.fillText(`‚öîÔ∏è${atkToShow}  ‚ù§Ô∏è${hpToShow}`, width - 16, height - 15);
        // 3x3 —Å—Ö–µ–º—ã: –∞—Ç–∞–∫–∞ –∏ blindspot
        drawPatternGrid(ctx, cardData, width - 76, 178, 10, 2);
        drawBlindspotGrid(ctx, cardData, width - 36, 178, 10, 2);
      }
    }
    
    function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
      if (!text) return;
      const words = text.split(' ');
      let line = '';
      
      for (let n = 0; n < words.length; n++) {
        const testLine = line + words[n] + ' ';
        const metrics = ctx.measureText(testLine);
        const testWidth = metrics.width;
        
        if (testWidth > maxWidth && n > 0) {
          ctx.fillText(line, x, y);
          line = words[n] + ' ';
          y += lineHeight;
        } else {
          line = testLine;
        }
      }
      ctx.fillText(line, x, y);
    }
    
    function getElementColor(element) {
      const colors = {
        FIRE: '#dc2626',
        WATER: '#0369a1', 
        EARTH: '#525252',
        FOREST: '#166534'
      };
      return colors[element] || '#64748b';
    }
    
    function drawPatternGrid(ctx, cardData, x, y, cell, gap) {
      const pattern = cardData.pattern || 'FRONT';
      const range = cardData.range || 1;
      // grid 3x3
      for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 3; c++) {
          const cx = x + c * (cell + gap);
          const cy = y + r * (cell + gap);
          ctx.fillStyle = 'rgba(148,163,184,0.35)';
          // center
          if (r === 1 && c === 1) ctx.fillStyle = 'rgba(250,204,21,0.7)';
          ctx.fillRect(cx, cy, cell, cell);
          // highlight directions from facing N
          const dirs = dirsForPattern('N', pattern);
          const isN = (r === 0 && c === 1);
          const isE = (r === 1 && c === 2);
          const isS = (r === 2 && c === 1);
          const isW = (r === 1 && c === 0);
          if ((isN && dirs.includes('N')) || (isE && dirs.includes('E')) || (isS && dirs.includes('S')) || (isW && dirs.includes('W'))) {
            ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 1.5; ctx.strokeRect(cx+0.5, cy+0.5, cell-1, cell-1);
          }
        }
      }
      // push center slightly if range>1
      if (range > 1) {
        ctx.fillStyle = 'rgba(148,163,184,0.5)';
        ctx.fillRect(x + 1*(cell+gap) + 0.5, y + 1*(cell+gap) + 2, cell-1, cell-1);
      }
    }
    function drawBlindspotGrid(ctx, cardData, x, y, cell, gap) {
      const blind = (cardData.blindspots && cardData.blindspots.length) ? cardData.blindspots : ['S'];
      for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 3; c++) {
          const cx = x + c * (cell + gap);
          const cy = y + r * (cell + gap);
          ctx.fillStyle = 'rgba(148,163,184,0.35)';
          if (r === 1 && c === 1) ctx.fillStyle = 'rgba(250,204,21,0.7)';
          ctx.fillRect(cx, cy, cell, cell);
          const isN = (r === 0 && c === 1);
          const isE = (r === 1 && c === 2);
          const isS = (r === 2 && c === 1);
          const isW = (r === 1 && c === 0);
          if ((isN && blind.includes('N')) || (isE && blind.includes('E')) || (isS && blind.includes('S')) || (isW && blind.includes('W'))) {
            ctx.strokeStyle = '#38bdf8'; ctx.lineWidth = 1.5; ctx.strokeRect(cx+0.5, cy+0.5, cell-1, cell-1);
          }
        }
      }
    }
    
    function updateHand() {
      // –í–æ –≤—Ä–µ–º—è –ø–æ–ª—ë—Ç–∞ –∫–∞—Ä—Ç—ã –Ω–µ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º —Ä—É–∫—É, —á—Ç–æ–±—ã –Ω–µ –ª–æ–º–∞—Ç—å –ø—Ä–µ–¥—Ä–∞—Å–∫–ª–∞–¥–∫—É
      if (drawAnimationActive) return;
      handCardMeshes.forEach(card => {
        if (card.parent) card.parent.remove(card);
      });
      handCardMeshes = [];
      hoveredHandCard = null;
      
      if (!gameState) return;

      // –í –æ–Ω–ª–∞–π–Ω–µ –≤—Å–µ–≥–¥–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –°–í–û–Æ —Ä—É–∫—É, –∞ –Ω–µ —Ä—É–∫—É –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞
      const viewerSeat = (typeof window !== 'undefined' && typeof window.MY_SEAT === 'number')
        ? window.MY_SEAT
        : gameState.active;
      let hand = (gameState.players && gameState.players[viewerSeat] && gameState.players[viewerSeat].hand)
        ? gameState.players[viewerSeat].hand.slice()
        : [];
      // –í –º–æ–º–µ–Ω—Ç –∞–Ω–∏–º–∞—Ü–∏–∏ –¥–æ–±–æ—Ä–∞ —Å–∫—Ä—ã–≤–∞–µ–º N –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –∫–∞—Ä—Ç, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è
      try {
        if (viewerSeat === (typeof window !== 'undefined' ? window.MY_SEAT : viewerSeat) && pendingDrawCount > 0) {
          hand = hand.slice(0, Math.max(0, hand.length - pendingDrawCount));
        }
      } catch {}
      // –°–∫—Ä—ã—Ç—å –æ–¥–∏–Ω —ç–∫–∑–µ–º–ø–ª—è—Ä —Ä–∏—Ç—É–∞–ª—å–Ω–æ–≥–æ —Å–ø–µ–ª–ª–∞ —É –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞ (–≤–æ –≤—Ä–µ–º—è –≤—ã–±–æ—Ä–∞ –∂–µ—Ä—Ç–≤—ã)
      let indices = [];
      for (let i = 0; i < hand.length; i++) {
        if (viewerSeat === gameState.active && typeof pendingRitualSpellHandIndex === 'number' && i === pendingRitualSpellHandIndex) continue;
        indices.push(i);
      }
      const handSize = indices.length;
      
      if (handSize === 0) return;
      
      // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –≤–µ–µ—Ä–Ω–æ–≥–æ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è
      const spread = Math.min(4.0, Math.max(2.0, 20 / (handSize + 2)));
      const angleSpread = Math.min(0.3, 1.2 / (handSize + 1));
      const radius = 8.0;  // –†–∞–∑—É–º–Ω—ã–π —Ä–∞–¥–∏—É—Å –¥–ª—è –≤–∏–¥–∏–º–æ—Å—Ç–∏
      const baseY = 6.0;   // –†—É–∫–∞ –Ω–∞–¥ –ø–æ–ª–µ–º, –Ω–æ –Ω–µ —Å–ª–∏—à–∫–æ–º –≤—ã—Å–æ–∫–æ
      
      for (let k = 0; k < handSize; k++) {
        const i = indices[k];
        const cardData = hand[i];
        const card = createCard3D(cardData, true);
        
        // –í—ã—á–∏—Å–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –¥–ª—è –≤–µ–µ—Ä–Ω–æ–≥–æ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è
        const angle = (k - (handSize - 1) / 2) * angleSpread;
        const x = Math.sin(angle) * radius;
        const z = radius + Math.cos(angle) * radius * 0.3 - HAND_Z_OFFSET;
        const y = baseY + Math.sin(angle) * 1.5; // –ù–µ–±–æ–ª—å—à–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ –ø–æ Y –¥–ª—è –æ–±—ä–µ–º–∞
        
        card.position.set(x, y, z);
        
        // –ü–æ–≤–æ—Ä–æ—Ç –∫–∞—Ä—Ç—ã –¥–ª—è –≤–µ–µ—Ä–Ω–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞
        card.rotation.set(
            -0.2 + angle * 0.1,   // –ù–∞–∫–ª–æ–Ω –≤–ø–µ—Ä–µ–¥
            angle * 0.5,           // –ü–æ–≤–æ—Ä–æ—Ç –≤ —Å—Ç–æ—Ä–æ–Ω—É
            0                       // –ë–µ–∑ –∫—Ä–µ–Ω–∞
        );
        
        card.userData.originalPosition.copy(card.position);
        card.userData.originalRotation.copy(card.rotation);
        card.userData.handIndex = i;
        card.userData.cardData = cardData;
        
        card.renderOrder = 2000; // –ø–æ–≤–µ—Ä—Ö —Ä–∞–º–æ–∫
        cardGroup.add(card);
        handCardMeshes.push(card);
      }
    }

    function computeHandTransform(index, total) {
      const handSize = Math.max(1, total);
      const angleSpread = Math.min(0.3, 1.2 / (handSize + 1));
      const radius = 8.0;
      const baseY = 6.0;
      const angle = (index - (handSize - 1) / 2) * angleSpread;
      const x = Math.sin(angle) * radius;
      const z = radius + Math.cos(angle) * radius * 0.3 - HAND_Z_OFFSET;
      const y = baseY + Math.sin(angle) * 1.5;
      const rot = new THREE.Euler(
        -0.2 + angle * 0.1,
        angle * 0.5,
        0
      );
      const pos = new THREE.Vector3(x, y, z);
      const scale = new THREE.Vector3(0.54, 1, 0.54);
      return { position: pos, rotation: rot, scale };
    }

    function setHandCardHoverVisual(mesh, hovered) {
      if (!mesh) return;
      const materials = [];
      const collect = (obj) => {
        if (!obj) return;
        if (obj.material) {
          if (Array.isArray(obj.material)) materials.push(...obj.material);
          else materials.push(obj.material);
        }
        (obj.children || []).forEach(collect);
      };
      collect(mesh);
      if (hovered) {
        mesh.renderOrder = 10000;
        // –í–ê–ñ–ù–û: –æ—Å—Ç–∞–≤–ª—è–µ–º depthWrite=true, —á—Ç–æ–±—ã –∫–∞—Ä—Ç–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ —Ä–∏—Å–æ–≤–∞–ª–∞ —Å–≤–æ—é –ª–∏—Ü–µ–≤—É—é —Å—Ç–æ—Ä–æ–Ω—É –Ω–∞–¥ —Å–≤–æ–∏–º–∏ –∂–µ –≥—Ä–∞–Ω—è–º–∏/—Ä—É–±–∞—à–∫–æ–π
        materials.forEach(m => { if (m) { m.depthTest = true; m.depthWrite = true; m.needsUpdate = true; } });
        // –ü–æ–¥–Ω–∏–º–µ–º –∏ –Ω–µ–º–Ω–æ–≥–æ –ø—Ä–∏–±–ª–∏–∑–∏–º –∫ –∫–∞–º–µ—Ä–µ –≤–¥–æ–ª—å –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤–∑–≥–ª—è–¥–∞
        try {
          if (mesh.userData && mesh.userData.originalPosition) {
            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);
            const towardCamera = camDir.clone().multiplyScalar(-0.7); // —à–∞–≥ –∫ –∫–∞–º–µ—Ä–µ
            const target = mesh.userData.originalPosition.clone().add(new THREE.Vector3(0, 0.9, 0)).add(towardCamera);
            gsap.to(mesh.position, { x: target.x, y: target.y, z: target.z, duration: 0.18 });
          }
        } catch {}
        // –ü–æ–¥–Ω–∏–º–µ–º –∏–ª–ª—é—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω—ã–π –ø–ª–µ–π–Ω (–µ—Å–ª–∏ –µ—Å—Ç—å) –ø–æ–≤–µ—Ä—Ö —Å–∞–º–æ–π –∫–∞—Ä—Ç—ã
        try { (mesh.children || []).forEach(ch => { if (ch && ch.userData && ch.userData.kind === 'illustrationPlane') { ch.renderOrder = mesh.renderOrder + 1; } }); } catch {}
      } else {
        mesh.renderOrder = 2000;
        // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ —Ç–µ—Å—Ç/–∑–∞–ø–∏—Å—å –≥–ª—É–±–∏–Ω—ã
        materials.forEach(m => { if (m) { m.depthTest = true; m.depthWrite = true; m.needsUpdate = true; } });
        try { if (mesh.userData && mesh.userData.originalPosition) { const p = mesh.userData.originalPosition; gsap.to(mesh.position, { x: p.x, y: p.y, z: p.z, duration: 0.18 }); } } catch {}
        try { (mesh.children || []).forEach(ch => { if (ch && ch.userData && ch.userData.kind === 'illustrationPlane') { ch.renderOrder = mesh.renderOrder + 1; } }); } catch {}
      }
    }

    async function animateDrawnCardToHand(cardTpl) {
      try {
        if (!cardTpl) return;
        drawAnimationActive = true; refreshInputLockUI();
        // –°–æ–∑–¥–∞—ë–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π –∫—Ä—É–ø–Ω—ã–π –º–µ—à (–Ω–µ –æ—Ç–Ω–æ—Å–∏—Ç—Å—è –∫ —Ä—É–∫–µ), –∏ –æ—Ä–∏–µ–Ω—Ç–∏—Ä—É–µ–º –∫–∞–∫ ¬´–±–∏–ª–±–æ—Ä–¥¬ª –∫ –∫–∞–º–µ—Ä–µ
        const big = createCard3D(cardTpl, false);
        // –†–∞–∑–º–µ—Å—Ç–∏–º –∫–∞—Ä—Ç—É –≤—ã—à–µ –∏ –±–ª–∏–∂–µ –∫ —Ü–µ–Ω—Ç—Ä—É —Å—Ç–æ–ª–∞, —á—Ç–æ–±—ã –Ω–µ –ø–µ—Ä–µ—Å–µ–∫–∞–ª–∞—Å—å —Å —Ä—É–∫–æ–π
        const T = window.DRAW_CARD_TUNE || {};
        big.position.set(0, (T.posY ?? 10.0), (T.posZ ?? 2.4));
        // –ü–æ–≤–µ—Ä–Ω—É—Ç—å –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ –∫–∞–º–µ—Ä–µ: —Ñ—Ä–æ–Ω—Ç –∫–∞—Ä—Ç—ã –Ω–∞ –∫–∞–º–µ—Ä—É, –±–µ–∑ —É–≥–æ–ª–∫–∞ –ø–µ—Ä—Å–ø–µ–∫—Ç.
        // –ö–∞–º–µ—Ä–∞ —Å–º–æ—Ç—Ä–∏—Ç –Ω–∞ (0,1.2,0), –±–µ—Ä–µ–º –µ—ë yaw –≤–æ–∫—Ä—É–≥ Y
        try {
          // –û—Ä–∏–µ–Ω—Ç–∏—Ä—É–µ–º –∫–∞—Ä—Ç—É —Å—Ç—Ä–æ–≥–æ –∫ –∫–∞–º–µ—Ä–µ: –ª–∏—Ü–µ–≤–∞—è –Ω–æ—Ä–º–∞–ª—å = -–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤–∑–≥–ª—è–¥–∞ –∫–∞–º–µ—Ä—ã,
          // –≤–µ—Ä—Ö –∫–∞—Ä—Ç—ã –≤—ã—Ä–æ–≤–Ω–µ–Ω —Å up –∫–∞–º–µ—Ä–æ–π.
          const camForward = new THREE.Vector3();
          camera.getWorldDirection(camForward); // –∫—É–¥–∞ —Å–º–æ—Ç—Ä–∏—Ç –∫–∞–º–µ—Ä–∞
          const faceNormal = camForward.clone().negate().normalize(); // –ª–∏—Ü–æ–º –∫ –∫–∞–º–µ—Ä–µ
          const camUpWorld = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion).normalize();
          let right = new THREE.Vector3().crossVectors(camUpWorld, faceNormal);
          if (right.lengthSq() < 1e-6) right.set(1, 0, 0); else right.normalize();
          const upInPlane = new THREE.Vector3().crossVectors(faceNormal, right).normalize();
          const basis = new THREE.Matrix4().makeBasis(right, faceNormal, upInPlane);
          const q = new THREE.Quaternion().setFromRotationMatrix(basis);
          big.setRotationFromQuaternion(q);
        } catch { big.rotation.set(0, 0, 0); }
        big.scale.set((T.scale ?? 1.7), (T.scale ?? 1.7), (T.scale ?? 1.7));
        big.renderOrder = 9000;
        // –°–æ–±–µ—Ä—ë–º –≤—Å–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã (–≤–∫–ª—é—á–∞—è –Ω–∞–∫–ª–∞–¥–Ω—ã–µ –ø–ª–µ–π–Ω—ã –∏–ª–ª—é—Å—Ç—Ä–∞—Ü–∏–∏ –∏ –æ–≤–µ—Ä–ª–µ–π –ª–∏—Ü–∞),
        // —á—Ç–æ–±—ã –æ–±–µ—Å–ø–µ—á–∏—Ç—å –ø–ª–∞–≤–Ω–æ–µ –ø—Ä–æ—è–≤–ª–µ–Ω–∏–µ –±–µ–∑ –º–≥–Ω–æ–≤–µ–Ω–Ω–æ–≥–æ –≤—Å–ø–ª—ã—Ç–∏—è —Å–ª–æ—ë–≤
        const mats = Array.isArray(big.material) ? big.material : [big.material];
        const allMaterials = [];
        const collectMaterials = (obj) => {
          if (!obj) return;
          if (obj.material) {
            if (Array.isArray(obj.material)) allMaterials.push(...obj.material);
            else allMaterials.push(obj.material);
          }
          (obj.children || []).forEach(collectMaterials);
        };
        collectMaterials(big);
        allMaterials.forEach(m => { if (m) { m.transparent = true; m.opacity = 0; } });
        cardGroup.add(big);

        // –¶–µ–ª–µ–≤–∞—è –ø–æ–∑–∏—Ü–∏—è –≤ —Ä—É–∫–µ ‚Äî –≤—ã—á–∏—Å–ª–∏–º, –∫–∞–∫ –±—É–¥—Ç–æ –∫–∞—Ä—Ç–∞ —Å—Ç–∞–Ω–µ—Ç –ø–æ—Å–ª–µ–¥–Ω–µ–π
        // –í –º–æ–º–µ–Ω—Ç –∞–Ω–∏–º–∞—Ü–∏–∏ –º—ã —É–∂–µ —Å–ø—Ä—è—Ç–∞–ª–∏ –ø–æ—Å–ª–µ–¥–Ω—é—é –∫–∞—Ä—Ç—É (pendingDrawCount=1),
        // –ø–æ—ç—Ç–æ–º—É –±–µ—Ä—ë–º —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏–π —Ä–µ–Ω–¥–µ—Ä–∏–º—ã–π —Ä–∞–∑–º–µ—Ä —Ä—É–∫–∏ –∏ –ø—Ä–∏–±–∞–≤–ª—è–µ–º 1.
        const totalVisible = Math.max(0, handCardMeshes.filter(m => m?.userData?.isInHand).length);
        const totalAfter = totalVisible + 1;
        const indexAfter = totalAfter - 1;
        const target = computeHandTransform(indexAfter, totalAfter);

        // –ü—Ä–µ–¥—Ä–∞—Å–∫–ª–∞–¥–∫–∞: –∑–∞—Ä–∞–Ω–µ–µ —Å–º–µ—Å—Ç–∏–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –∫–∞—Ä—Ç—ã —Ä—É–∫–∏ –≤ –ø–æ–ª–æ–∂–µ–Ω–∏—è –¥–ª—è totalAfter,
        // —á—Ç–æ–±—ã –∫ –º–æ–º–µ–Ω—Ç—É –ø—Ä–∏–ª—ë—Ç–∞ –Ω–æ–≤–æ–π –∫–∞—Ä—Ç—ã —Å–æ—Å–µ–¥–∏ —É–∂–µ —Å—Ç–æ—è–ª–∏ –Ω–∞ —Å–≤–æ–∏—Ö –º–µ—Å—Ç–∞—Ö
        try {
          const preLayoutDuration = 0.6;
          for (let i = 0; i < handCardMeshes.length; i++) {
            const mesh = handCardMeshes[i];
            if (!mesh || !mesh.userData || !mesh.userData.isInHand) continue;
            // –£—á—Ç—ë–º, —á—Ç–æ new card –∑–∞–π–º—ë—Ç –ø–æ–∑–∏—Ü–∏—é indexAfter, –ø–æ—ç—Ç–æ–º—É —Å—Ç–∞—Ä—ã–µ –∏–Ω–¥–µ–∫—Å—ã –Ω–µ —Å–¥–≤–∏–≥–∞–µ–º —á—Ä–µ–∑–º–µ—Ä–Ω–æ
            const t = computeHandTransform(i, totalAfter);
            gsap.to(mesh.position, {
              x: t.position.x,
              y: t.position.y,
              z: t.position.z,
              duration: preLayoutDuration,
              ease: 'power2.inOut'
            });
            gsap.to(mesh.rotation, {
              x: t.rotation.x,
              y: t.rotation.y,
              z: t.rotation.z,
              duration: preLayoutDuration,
              ease: 'power2.inOut'
            });
            // –í–µ—Ä–Ω—ë–º –º–∞—Å—à—Ç–∞–± –∫ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–º—É –¥–ª—è —Ä—É–∫–∏ –Ω–∞ —Å–ª—É—á–∞–π, –µ—Å–ª–∏ –∫–∞–∫–∞—è-—Ç–æ –∫–∞—Ä—Ç–∞ –±—ã–ª–∞ –Ω–∞–≤–µ–¥–µ–Ω–∞
            gsap.to(mesh.scale, { x: 0.54, y: 1, z: 0.54, duration: 0.18 });
            // –û–±–Ω–æ–≤–∏–º –±–∞–∑–æ–≤—ã–µ –ø–æ–∑–∏—Ü–∏–∏/—É–≥–ª—ã –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ —Ö–æ–≤–µ—Ä–∞ –ø–æ—Å–ª–µ –∞–Ω–∏–º–∞—Ü–∏–∏
            try { mesh.userData.originalPosition.copy(t.position); } catch {}
            try { mesh.userData.originalRotation.copy(t.rotation); } catch {}
          }
        } catch {}

        await new Promise(resolve => {
          const tl = gsap.timeline({ onComplete: resolve });
          // –ü—Ä–æ—è–≤–ª–µ–Ω–∏–µ ‚â§ 1.0—Å
          tl.to(allMaterials, { opacity: 1, duration: 0.8, ease: 'power2.out' })
            // –ü–æ–ª—ë—Ç –≤ —Ä—É–∫—É ‚â§ 0.7—Å, –≤—Å–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ
            .to(big.position, { x: target.position.x, y: target.position.y, z: target.position.z, duration: 0.7, ease: 'power2.inOut' }, 'fly')
            .to(big.rotation, { x: target.rotation.x, y: target.rotation.y, z: target.rotation.z, duration: 0.7, ease: 'power2.inOut' }, 'fly')
            .to(big.scale, { x: target.scale.x, y: target.scale.y, z: target.scale.z, duration: 0.7, ease: 'power2.inOut' }, 'fly');
          // –ü–æ—Å–ª–µ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏ –∫ –∫–∞–º–µ—Ä–µ –ø—Ä–∏–º–µ–Ω–∏–º —Ä—É—á–Ω—ã–µ —É–≥–ª—ã (–≤ –≥—Ä–∞–¥—É—Å–∞—Ö)
          try {
            big.rotateX(THREE.MathUtils.degToRad(T.pitchDeg || 0));
            big.rotateY(THREE.MathUtils.degToRad(T.yawDeg || 0));
            big.rotateZ(THREE.MathUtils.degToRad(T.rollDeg || 0));
          } catch {}
        });
        try { cardGroup.remove(big); } catch {}
        drawAnimationActive = false; refreshInputLockUI();
      } catch {}
    }
    
    function updateUnits() {
      unitMeshes.forEach(unit => {
        if (unit.parent) unit.parent.remove(unit);
      });
      unitMeshes = [];
      
      if (!gameState) return;
      
      const tileSize = 6.2;
      const spacing = 0.2;
      const boardZShift = -3.5;
      
      for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 3; c++) {
          const unit = gameState.board[r][c].unit;
          // –û–±–Ω–æ–≤–∏–º —Ä–∞–º–∫–∏ –≤–ª–∞–¥–µ–Ω–∏—è
          if (tileFrames[r] && tileFrames[r][c]) {
            const frame = tileFrames[r][c];
            const setFrame = (opacity, color) => {
              frame.traverse(child => { if (child.isMesh && child.material) { child.material.opacity = opacity; child.material.color = new THREE.Color(color); } });
            };
            if (unit) {
              // –í –æ–Ω–ª–∞–π–Ω–µ: –ø–æ–¥—Å–≤–µ—Ç–∫–∞ –ø–æ –≤–ª–∞–¥–µ–ª—å—Ü—É –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –º–æ–µ–≥–æ –º–µ—Å—Ç–∞ (MY_SEAT)
              // –û—Ñ—Ñ–ª–∞–π–Ω: –ø–æ –≤–ª–∞–¥–µ–ª—å—Ü—É (0 –∑–µ–ª—ë–Ω—ã–π, 1 –∫—Ä–∞—Å–Ω—ã–π)
              // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –º–µ—Å—Ç–æ –∑—Ä–∏—Ç–µ–ª—è: –æ–Ω–ª–∞–π–Ω ‚Äî MY_SEAT, –æ—Ñ–ª–∞–π–Ω ‚Äî —Ç–µ–∫—É—â–∏–π –∞–∫—Ç–∏–≤–Ω—ã–π
              let viewerSeat = null;
              try {
                if (typeof window !== 'undefined' && typeof window.MY_SEAT === 'number') viewerSeat = window.MY_SEAT;
                else viewerSeat = gameState.active;
              } catch { viewerSeat = gameState.active; }
              const isMine = (unit.owner === viewerSeat);
              const col = isMine ? 0x22c55e : 0xef4444;
              setFrame(0.95, col);
            } else {
              setFrame(0.0, 0x000000);
            }
          }
          if (!unit) continue;
          
          const cardData = CARDS[unit.tplId];
          const stats = effectiveStats(gameState.board[r][c], unit);
          const unitMesh = createCard3D(cardData, false, unit.currentHP, stats.atk);
          
          const x = (c - 1) * (tileSize + spacing);
          const z = (r - 1) * (tileSize + spacing) + boardZShift + 0.0; // –í–∞–∂–Ω–æ - —Å–º–µ—â–µ–Ω–∏–µ –∫–∞—Ä—Ç –Ω–∞ –ø–æ–ª–µ?
          const yBase = tileFrames[r] && tileFrames[r][c] ? (tileFrames[r][c].children?.[0]?.position?.y || (0.5 + 0.5)) : (0.5 + 0.5);
          unitMesh.position.set(x, yBase + 0.28, z);
          
          const facingAngle = facingDeg[unit.facing] * Math.PI / 180;
          unitMesh.rotation.y = facingAngle;
          
          const ownerColor = unit.owner === 0 ? 0x22c55e : 0xef4444;
          const glowMaterial = new THREE.MeshStandardMaterial({
            color: ownerColor,
            emissive: ownerColor,
            emissiveIntensity: 0.2,
            transparent: true,
            opacity: 0.3
          });
          
          const glowGeometry = new THREE.BoxGeometry(1.8, 0.02, 2.4);
          const glow = new THREE.Mesh(glowGeometry, glowMaterial);
          glow.position.set(0, -0.05, 0);
          unitMesh.add(glow);
          
          unitMesh.userData = {
            type: 'unit',
            row: r,
            col: c,
            unitData: unit,
            cardData: cardData
          };
          // –£–±—Ä–∞–ª–∏ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π HP-–æ–≤–µ—Ä–ª–µ–π, —Ç–∞–∫ –∫–∞–∫ —Ü–∏—Ñ—Ä–∞ HP —Ä–∏—Å—É–µ—Ç—Å—è –Ω–∞ —Å–∞–º–æ–π –∫–∞—Ä—Ç–µ
          
          cardGroup.add(unitMesh);
          unitMeshes.push(unitMesh);
        }
      }
    }

    // –í–∏–∑—É–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è –º–µ–∂–¥—É –ø—Ä–µ–¥—ã–¥—É—â–∏–º –∏ –Ω–æ–≤—ã–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ–º (–¥–ª—è –Ω–∞–±–ª—é–¥–∞—Ç–µ–ª—è/–æ–ø–ø–æ–Ω–µ–Ω—Ç–∞)
    function playDeltaAnimations(prevState, nextState) {
      try {
        if (!prevState || !nextState) return;
        const prevB = prevState.board || [];
        const nextB = nextState.board || [];
        // –ü–æ–ø—Ä–æ–±—É–µ–º –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∞—Ç–∞–∫—É—é—â–µ–≥–æ —ç—Ç–æ–≥–æ —Ö–æ–¥–∞ (—É –Ω–µ–≥–æ lastAttackTurn === nextState.turn)
        let attackerCell = null;
        for (let r = 0; r < 3; r++) {
          for (let c = 0; c < 3; c++) {
            const u = (nextB[r] && nextB[r][c] && nextB[r][c].unit) ? nextB[r][c].unit : null;
            if (u && u.lastAttackTurn === nextState.turn) { attackerCell = { r, c }; break; }
          }
          if (attackerCell) break;
        }
        if (attackerCell) {
          try {
            const aMesh = unitMeshes.find(m => m.userData.row === attackerCell.r && m.userData.col === attackerCell.c);
            const hitsPrev = computeHits(prevState, attackerCell.r, attackerCell.c);
            if (aMesh && hitsPrev && hitsPrev.length) {
              const first = hitsPrev[0];
              const targetPos = tileMeshes[first.r][first.c].position;
              const dir = new THREE.Vector3().subVectors(targetPos, aMesh.position).normalize();
              const push = { x: dir.x * 0.6, z: dir.z * 0.6 };
              const tl = gsap.timeline();
              tl.to(aMesh.position, { x: `+=${push.x}`, z: `+=${push.z}`, duration: 0.22, ease: 'power2.out' })
                .to(aMesh.position, { x: `-=${push.x}`, z: `-=${push.z}`, duration: 0.30, ease: 'power2.inOut' });
              // –ü—Ä–æ–±—É–µ–º –∞–Ω–∏–º–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ—Å—Ç–æ–π –≤—ã–ø–∞–¥ –∫–æ–Ω—Ç—Ä–∞—Ç–∞–∫—É—é—â–∏—Ö –ø–æ –ø—Ä–µ–¥–ø–æ–ª–æ–∂–µ–Ω–∏—é
              try {
                const staged = stagedAttack(prevState, attackerCell.r, attackerCell.c);
                const ret = staged && staged.step2 ? (staged.step2() || { total: 0, retaliators: [] }) : { total: 0, retaliators: [] };
                const retaliators = (ret.retaliators || []);
                retaliators.forEach(rrObj => {
                  const rMesh = unitMeshes.find(m => m.userData.row === rrObj.r && m.userData.col === rrObj.c);
                  if (!rMesh) return;
                  const dir2 = new THREE.Vector3().subVectors(aMesh.position, rMesh.position).normalize();
                  const push2 = { x: dir2.x * 0.6, z: dir2.z * 0.6 };
                  gsap.to(rMesh.position, { x: `+=${push2.x}`, z: `+=${push2.z}`, duration: 0.22, ease: 'power2.out' })
                    .then(() => gsap.to(rMesh.position, { x: `-=${push2.x}`, z: `-=${push2.z}`, duration: 0.30, ease: 'power2.inOut' }));
                });
              } catch {}
            }
          } catch {}
        }
        for (let r = 0; r < 3; r++) {
          for (let c = 0; c < 3; c++) {
            const pu = (prevB[r] && prevB[r][c] && prevB[r][c].unit) ? prevB[r][c].unit : null;
            const nu = (nextB[r] && nextB[r][c] && nextB[r][c].unit) ? nextB[r][c].unit : null;
            if (pu && nu) {
              const pHP = (typeof pu.currentHP === 'number') ? pu.currentHP : pu.hp;
              const nHP = (typeof nu.currentHP === 'number') ? nu.currentHP : nu.hp;
              const delta = (typeof pHP === 'number' && typeof nHP === 'number') ? (nHP - pHP) : 0;
              if (delta !== 0) {
                try {
                  const tMesh = unitMeshes.find(m => m.userData.row === r && m.userData.col === c);
                  if (tMesh) {
                    spawnDamageText(tMesh, `${delta > 0 ? '+' : ''}${delta}`, delta > 0 ? '#22c55e' : '#ef4444');
                    if (delta < 0) { shakeMesh(tMesh, 6, 0.12); }
                  }
                } catch {}
              }
            } else if (pu && !nu) {
              // –Æ–Ω–∏—Ç –∏—Å—á–µ–∑ ‚Äî –ø—Ä–æ–∏–≥—Ä—ã–≤–∞–µ–º —à–µ–π–¥–µ—Ä–Ω–æ–µ ¬´–∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏–µ¬ª —Ñ–∞–Ω—Ç–æ–º–∞ –∏ –æ—Ä–± –º–∞–Ω—ã
              try {
                const tile = tileMeshes?.[r]?.[c]; if (!tile) continue;
                const ghost = createCard3D(CARDS[pu.tplId], false);
                ghost.position.copy(tile.position).add(new THREE.Vector3(0, 0.28, 0));
                try { effectsGroup.add(ghost); } catch { cardGroup.add(ghost); }
                dissolveAndAsh(ghost, new THREE.Vector3(0,0,0.6), 0.9);
                const p = tile.position.clone().add(new THREE.Vector3(0, 1.2, 0));
                animateManaGainFromWorld(p, pu.owner);
                // –ù–µ —Ç—Ä–æ–≥–∞–µ–º gameState –≤ –æ–Ω–ª–∞–π–Ω–µ, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –¥–≤–æ–π–Ω–æ–≥–æ —É—á—ë—Ç–∞. –í –æ—Ñ–ª–∞–π–Ω–µ –º–æ–∂–Ω–æ –ø–æ–¥–≤–∏–Ω—É—Ç—å UI —Å—Ä–∞–∑—É.
                try { if (!NET_ACTIVE && gameState && gameState.players && typeof pu.owner === 'number') { gameState.players[pu.owner].mana = capMana((gameState.players[pu.owner].mana||0) + 1); updateUI(); } } catch {}
              } catch {}
            } else if (!pu && nu) {
              // –Æ–Ω–∏—Ç –ø–æ—è–≤–∏–ª—Å—è ‚Äî –ª—ë–≥–∫–∏–π ¬´–ø–æ–ø¬ª –º–∞—Å—à—Ç–∞–±–∞
              try {
                const tMesh = unitMeshes.find(m => m.userData.row === r && m.userData.col === c);
                if (tMesh) {
                  const s = tMesh.scale.clone();
                  tMesh.scale.set(s.x * 0.7, s.y * 0.7, s.z * 0.7);
                  gsap.to(tMesh.scale, { x: s.x, y: s.y, z: s.z, duration: 0.28, ease: 'power2.out' });
                }
              } catch {}
            }
          }
        }
      } catch {}
    }
    // attachHpOverlay —É–¥–∞–ª—ë–Ω, —Ç.–∫. HP —Ç–µ–ø–µ—Ä—å –ø–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ—Ç—Å—è –Ω–∞ —Å–∞–º–æ–π –∫–∞—Ä—Ç–µ
    
    function updateUI() {
      if (!gameState) return;
      
      document.getElementById('turn-info').textContent = `–•–æ–¥: ${gameState.turn}`;
      // –û–±–Ω–æ–≤–∏—Ç—å —á–∏—Å–ª–æ–≤–æ–π —Ç–µ–∫—Å—Ç —Ç–∞–π–º–µ—Ä–∞ –≤ –∫—Ä—É–≥–ª–æ–π –∫–Ω–æ–ø–∫–µ –∏ –≤—ã—Å–æ—Ç—É –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è
      try {
        const btn = document.getElementById('end-turn-btn');
        if (btn) {
          const fill = btn.querySelector('.time-fill');
          const txt = btn.querySelector('.sec-text');
          if (typeof window.__turnTimerSeconds === 'number') {
            const s = Math.max(0, Math.min(100, window.__turnTimerSeconds));
            if (txt) txt.textContent = `${s}`;
            // –ò–Ω–≤–µ—Ä—Å–∏—è: –æ–ø—É—Å–∫–∞–µ–º –≤–µ—Ä—Ö–Ω—é—é –≥—Ä–∞–Ω–∏—Ü—É –∂—ë–ª—Ç–æ–π –∑–∞–ª–∏–≤–∫–∏ —Å–≤–µ—Ä—Ö—É –≤–Ω–∏–∑
            const percent = s / 100; // 1 -> top:0%, 0 -> top:100%
            if (fill) fill.style.top = `${Math.round((1 - percent) * 100)}%`;
          }
        }
      } catch {}
      // –í—ã–¥–µ–ª–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞
      try {
        const leftSide = document.getElementById('left-side');
        const rightSide = document.getElementById('right-side');
        const t0 = document.getElementById('player-title-0');
        const t1 = document.getElementById('player-title-1');
        if (leftSide && rightSide && t0 && t1) {
          if (gameState.active === 0) {
            // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º –æ–±–µ –ø–∞–Ω–µ–ª–∏ (–º–∞–Ω–∞ –∏ –∫–æ–Ω—Ç—Ä–æ–ª—å) —É –∞–∫—Ç–∏–≤–Ω–æ–≥–æ
            leftSide.querySelectorAll('.overlay-panel').forEach(el => el.classList.add('active-player-panel'));
            rightSide.querySelectorAll('.overlay-panel').forEach(el => el.classList.remove('active-player-panel'));
            t0.classList.add('title-pulse');
            t1.classList.remove('title-pulse');
          } else {
            rightSide.querySelectorAll('.overlay-panel').forEach(el => el.classList.add('active-player-panel'));
            leftSide.querySelectorAll('.overlay-panel').forEach(el => el.classList.remove('active-player-panel'));
            t1.classList.add('title-pulse');
            t0.classList.remove('title-pulse');
          }
        }
      } catch {}
      
      // –û–±–Ω–æ–≤–ª—è–µ–º –¥–≤–µ –ø–∞–Ω–µ–ª–∏ –º–∞–Ω—ã (–¥–ª—è –æ–±–æ–∏—Ö –∏–≥—Ä–æ–∫–æ–≤)
      const total = 10;
      for (let p = 0; p < 2; p++) {
        const manaDisplay = document.getElementById(`mana-display-${p}`);
        if (!manaDisplay) continue;
        const prev = manaDisplay.querySelectorAll('.mana-orb').length;
        const currentMana = gameState.players[p].mana;
        const pending = (PENDING_MANA_ANIM && PENDING_MANA_ANIM.ownerIndex === p) ? PENDING_MANA_ANIM : null;
        const renderMana = pending ? Math.min(currentMana, Math.max(0, pending.startIdx)) : currentMana;
        manaDisplay.innerHTML = '';
        for (let i = 0; i < total; i++) {
          const orb = document.createElement('div');
          const filled = i < renderMana;
          const isBlockedForAnim = !!(pending && i >= pending.startIdx && i <= pending.endIdx);
          orb.className = filled ? 'mana-orb' : 'mana-slot';
          orb.style.opacity = filled ? '0' : '1';
          manaDisplay.appendChild(orb);
          // –ü–ª–∞–≤–Ω–æ–µ –ø—Ä–æ—è–≤–ª–µ–Ω–∏–µ —Ç–æ–ª—å–∫–æ –¥–ª—è —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –æ—Ä–±–æ–≤; –Ω–æ–≤—ã–µ –æ—Ä–±—ã –≤–æ –≤—Ä–µ–º—è –∞–Ω–∏–º–∞—Ü–∏–∏
          // –ø–æ—è–≤—è—Ç—Å—è –∏–∑ animateTurnManaGain (—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ —Å–æ –≤—Å–ø—ã—à–∫–æ–π)
          if (filled && !isBlockedForAnim) {
            const delay = 0.06 * Math.max(0, i - prev);
            setTimeout(()=>{
              orb.style.transform = 'translateX(16px) scale(0.6)';
              orb.style.transition = 'transform 220ms ease, opacity 220ms ease';
              requestAnimationFrame(()=>{
                orb.style.opacity = '1';
                orb.style.transform = 'translateX(0) scale(1)';
              });
            }, delay*1000);
          }
        }
      }
      
      const controlA = countControlled(gameState, 0);
      const controlB = countControlled(gameState, 1);
      const ci0 = document.getElementById('control-info-0'); if (ci0) ci0.textContent = `–ö–æ–Ω—Ç—Ä–æ–ª—å: ${controlA}`;
      const ci1 = document.getElementById('control-info-1'); if (ci1) ci1.textContent = `–ö–æ–Ω—Ç—Ä–æ–ª—å: ${controlB}`;
      
      if (controlA >= 5) {
        showNotification('–ò–≥—Ä–æ–∫ 1 –ø–æ–±–µ–∂–¥–∞–µ—Ç!', 'success');
        gameState.winner = 0;
      } else if (controlB >= 5) {
        showNotification('–ò–≥—Ä–æ–∫ 2 –ø–æ–±–µ–∂–¥–∞–µ—Ç!', 'success');
        gameState.winner = 1;
      }
    }
    
    function showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.className = `overlay-panel p-4 mb-2 ${type === 'success' ? 'bg-green-600' : type === 'error' ? 'bg-red-600' : 'bg-blue-600'}`;
      notification.textContent = message;
      
      const container = document.getElementById('notifications');
      container.appendChild(notification);
      
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 3000);
    }
    
    function addLog(message) {
      logEntries.unshift(`‚Ä¢ ${message}`);
      if (logEntries.length > 100) logEntries.pop();
      
      const logContent = document.getElementById('log-content');
      if (logContent) {
        logContent.innerHTML = logEntries.map(entry => `<div>${entry}</div>`).join('');
      }
    }
    
    // –í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ
    function onMouseMove(event) {
      if (isInputLocked()) return;
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      
      if (draggedCard) {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(tileMeshes.flat());
        
        if (hoveredTile) {
          hoveredTile.material.emissiveIntensity = 0.1;
        }
        
        if (intersects.length > 0) {
          hoveredTile = intersects[0].object;
          hoveredTile.material.emissiveIntensity = 0.3;
          
          const targetPos = hoveredTile.position.clone();
          targetPos.y = 2;
          gsap.to(draggedCard.position, {
            x: targetPos.x,
            y: targetPos.y,
            z: targetPos.z,
            duration: 0.1
          });
        } else {
          hoveredTile = null;
        }
      } else {
        // –•–æ–≤–µ—Ä –ø–æ –∫–∞—Ä—Ç–∞–º –≤ —Ä—É–∫–µ: —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º –Ω–∞–≤–µ–¥—ë–Ω–Ω—É—é, —É–º–µ–Ω—å—à–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â—É—é, –ø–æ–¥–Ω–∏–º–∞–µ–º –Ω–∞–¥ —Å—Ç–µ–∫–æ–º
        raycaster.setFromCamera(mouse, camera);
        const handHits = drawAnimationActive ? [] : raycaster.intersectObjects(handCardMeshes, true);
        const newHover = handHits.length > 0 ? (handHits[0].object.userData?.isInHand ? handHits[0].object : handHits[0].object.parent) : null;
        if (hoveredHandCard && hoveredHandCard !== newHover) {
          gsap.to(hoveredHandCard.scale, { x: 0.54, y: 1, z: 0.54, duration: 0.18 });
          setHandCardHoverVisual(hoveredHandCard, false);
          hoveredHandCard = null;
        }
        if (newHover && newHover.userData && newHover.userData.isInHand) {
          hoveredHandCard = newHover;
          gsap.to(newHover.scale, { x: 0.675, y: 1, z: 0.675, duration: 0.18 });
          setHandCardHoverVisual(newHover, true);
        }
      }
      // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã—Ö —Ü–µ–ª–µ–π –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–æ–π –ø–∞–Ω–µ–ª–∏ –¥–µ–π—Å—Ç–≤–∏–π —é–Ω–∏—Ç–∞
      if (selectedUnit) {
        const r = selectedUnit.userData.row; const c = selectedUnit.userData.col;
        const hits = computeHits(gameState, r, c);
        // —É–±–∏—Ä–∞–µ–º –ø—Ä–æ—à–ª—É—é –ø–æ–¥—Å–≤–µ—Ç–∫—É
        unitMeshes.forEach(m => { if (m.material && m.material[2]) { /* no-op here */ } });
        // –ø–æ–¥—Å–≤–µ—Ç–∏–º —Ü–µ–ª–∏ –Ω–µ–±–æ–ª—å—à–∏–º –≤—Å–ø–ª–µ—Å–∫–æ–º –ø–æ Y
        for (const h of hits) {
          const m = unitMeshes.find(m => m.userData.row === h.r && m.userData.col === h.c);
          if (m) gsap.to(m.position, { y: 0.7, yoyo: true, repeat: 1, duration: 0.2 });
        }
      }

      // Tooltip –¥–ª—è –∫–æ–ª–æ–¥/–∫–ª–∞–¥–±–∏—â
      {
        raycaster.setFromCamera(mouse, camera);
        const metaHits = raycaster.intersectObjects([...deckMeshes, ...graveyardMeshes], true);
        const tip = document.getElementById('hover-tooltip');
        if (metaHits.length > 0) {
          const obj = metaHits[0].object;
          const data = obj.userData || obj.parent?.userData || {};
          if (data && data.metaType) {
            const p = data.player ?? 0;
            hoveredMeta = { metaType: data.metaType, player: p };
            if (tip) {
              const deckCount = gameState?.players?.[p]?.deck?.length ?? 0;
              const gyCount = gameState?.players?.[p]?.graveyard?.length ?? 0;
              tip.textContent = data.metaType === 'deck' ? `–ö–æ–ª–æ–¥–∞ –ò–≥—Ä–æ–∫ ${p===0? '1':'2'}: ${deckCount}` : `–ö–ª–∞–¥–±–∏—â–µ –ò–≥—Ä–æ–∫ ${p===0? '1':'2'}: ${gyCount}`;
              tip.style.left = (event.clientX + 16) + 'px';
              tip.style.top = (event.clientY + 16) + 'px';
              tip.classList.remove('hidden');
            }
          }
        } else {
          hoveredMeta = null;
          const tipEl = document.getElementById('hover-tooltip');
          if (tipEl) tipEl.classList.add('hidden');
        }
      }
    }
    
    function onMouseDown(event) {
      if (!gameState || gameState.winner !== null) return;
      if (isInputLocked()) return;
      
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      
      const handIntersects = raycaster.intersectObjects(handCardMeshes, true);
      if (handIntersects.length > 0) {
        const hitObj = handIntersects[0].object;
        const card = hitObj.userData?.isInHand ? hitObj : hitObj.parent;
        const cardData = card.userData.cardData;
        // –ï—Å–ª–∏ –∂–¥—ë–º —Ä–∏—Ç—É–∞–ª—å–Ω–æ–≥–æ –¥–∏—Å–∫–∞—Ä–¥–∞ ‚Äî –ø–µ—Ä–µ—Ö–≤–∞—Ç –∫–ª–∏–∫–∞ –ø–æ —Ä—É–∫–µ
        if (pendingDiscardSelection && cardData && cardData.type === (pendingDiscardSelection.requiredType || cardData.type)) {
          const owner = gameState.players[gameState.active];
          const handIdx = card.userData.handIndex;
          try { pendingDiscardSelection.onPicked(handIdx); } catch {}
          pendingDiscardSelection = null;
          return;
        }
        
        if (cardData.type === 'UNIT') {
          startCardDrag(card);
        } else if (cardData.type === 'SPELL') {
          // –ù–æ–≤—ã–π –ø—Ä–∏–Ω—Ü–∏–ø: —Å–ø–µ–ª–ª—ã —Ä–∞–∑—ã–≥—Ä—ã–≤–∞—é—Ç—Å—è –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ–º, –∞ –Ω–µ –∫–ª–∏–∫–æ–º
          startCardDrag(card);
        }
        return;
      }
      
      const unitIntersects = raycaster.intersectObjects(unitMeshes, true);
      if (unitIntersects.length > 0) {
        const hitObj = unitIntersects[0].object;
        let unit = hitObj;
        while (unit && (!unit.userData || unit.userData.type !== 'unit')) unit = unit.parent;
        if (!unit) return;
        // –µ—Å–ª–∏ –≤ —Ä–µ–∂–∏–º–µ –º–∞–≥–∏—á–µ—Å–∫–æ–π –∞—Ç–∞–∫–∏
        if (magicFrom) {
          performMagicAttack(magicFrom, unit);
          magicFrom = null;
          return;
        }
        if (selectedCard && selectedCard.userData.cardData.type === 'SPELL') {
          castSpellOnUnit(selectedCard, unit);
        } else if (unit.userData.unitData.owner === gameState.active) {
          showUnitActionPanel(unit);
        }
        return;
      }
      
      if (selectedCard) {
        resetCardSelection();
      }
      // –û—Ç–º–µ–Ω–∞ —Ä–∏—Ç—É–∞–ª—å–Ω–æ–≥–æ –¥–∏—Å–∫–∞—Ä–¥–∞ –∫–ª–∏–∫–æ–º –ø–æ –ø–æ–ª—é
      if (pendingDiscardSelection) {
        try { hidePrompt(); } catch {}
        pendingDiscardSelection = null;
        // –í–µ—Ä–Ω—ë–º –≤–∏–∑—É–∞–ª—å–Ω–æ –∫–∞—Ä—Ç—É —Å–ø–µ–ª–ª–∞, –µ—Å–ª–∏ –æ–Ω–∞ –±—ã–ª–∞ –ø–µ—Ä–µ—Ç—è–Ω—É—Ç–∞
        if (draggedCard && draggedCard.userData && draggedCard.userData.cardData && draggedCard.userData.cardData.type === 'SPELL') {
          returnCardToHand(draggedCard);
        }
      }
    }
    
    function onMouseUp(event) {
      if (isInputLocked()) { endCardDrag(); return; }
      if (draggedCard) {
        const cardData = draggedCard.userData.cardData;
        // –û–ø—Ä–µ–¥–µ–ª–∏–º, –Ω–∞–≤–µ–ª–∏ –ª–∏ –Ω–∞ —é–Ω–∏—Ç–∞
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const unitIntersects = raycaster.intersectObjects(unitMeshes, true);
        let unitMesh = null;
        if (unitIntersects.length > 0) {
          let u = unitIntersects[0].object;
          while (u && (!u.userData || u.userData.type !== 'unit')) u = u.parent;
          unitMesh = u;
        }
        if (cardData.type === 'SPELL') {
          // –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ —Å–ø–µ–ª–ª–∞: –∫–∞—Å—Ç –ø–æ —Ü–µ–ª–∏ (—é–Ω–∏—Ç/–∫–ª–µ—Ç–∫–∞)
          try { castSpellByDrag(draggedCard, unitMesh, hoveredTile); } catch {}
          // –ï—Å–ª–∏ –ª–æ–≥–∏–∫–∞ –∫–∞—Å—Ç–∞ —Å–æ–∑–¥–∞–ª–∞ –±–æ—Ä–¥–æ–≤—ã–π –º–µ—à/—Å–æ–∂–≥–ª–∞ –∫–∞—Ä—Ç—É (spellDragHandled=true) ‚Äî –Ω–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º; –∏–Ω–∞—á–µ –≤–µ—Ä–Ω—É—Ç—å –≤ —Ä—É–∫—É
          if (!spellDragHandled) {
            returnCardToHand(draggedCard);
          }
          spellDragHandled = false;
        } else if (cardData.type === 'UNIT') {
          // –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ —Å—É—â–µ—Å—Ç–≤–∞: –ø—Ä–µ–∂–Ω—è—è –ª–æ–≥–∏–∫–∞ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –Ω–∞ –ø—É—Å—Ç—É—é –∫–ª–µ—Ç–∫—É
          if (hoveredTile) {
            const row = hoveredTile.userData.row;
            const col = hoveredTile.userData.col;
            if (gameState.board[row][col].unit) {
              showNotification('–ö–ª–µ—Ç–∫–∞ —É–∂–µ –∑–∞–Ω—è—Ç–∞!', 'error');
              returnCardToHand(draggedCard);
            } else {
              pendingPlacement = {
                card: draggedCard,
                row: row,
                col: col,
                handIndex: draggedCard.userData.handIndex
              };
              showOrientationPanel();
            }
          } else {
            returnCardToHand(draggedCard);
          }
        }
        endCardDrag();
        return;
      }
      endCardDrag();
    }
    
    function startCardDrag(card) {
      draggedCard = card;
      // –µ—Å–ª–∏ –∫–∞—Ä—Ç–∞ –±—ã–ª–∞ —É–≤–µ–ª–∏—á–µ–Ω–∞ —Ö–æ–≤–µ—Ä–æ–º ‚Äî –≤–µ—Ä–Ω—ë–º –∫ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–º—É –º–∞—Å—à—Ç–∞–±—É —Ä—É–∫–∏
      if (hoveredHandCard) {
        gsap.to(hoveredHandCard.scale, { x: 0.54, y: 1, z: 0.54, duration: 0.1 });
        setHandCardHoverVisual(hoveredHandCard, false);
        hoveredHandCard = null;
      }
      
      gsap.to(card.position, {
        y: card.position.y + 1,
        duration: 0.2,
        ease: "power2.out"
      });
      
      gsap.to(card.rotation, {
        x: 0,
        z: 0,
        duration: 0.2
      });
      
      gsap.to(card.scale, {
        x: 1.1,
        y: 1.1,
        z: 1.1,
        duration: 0.2
      });
    }
    
    function endCardDrag() {
      if (hoveredTile) {
        hoveredTile.material.emissiveIntensity = 0.1;
        hoveredTile = null;
      }
      draggedCard = null;
    }
    
    function returnCardToHand(card) {
      gsap.to(card.position, {
        x: card.userData.originalPosition.x,
        y: card.userData.originalPosition.y,
        z: card.userData.originalPosition.z,
        duration: 0.3,
        ease: "power2.inOut"
      });
      
      gsap.to(card.rotation, {
        x: card.userData.originalRotation.x,
        y: card.userData.originalRotation.y,
        z: card.userData.originalRotation.z,
        duration: 0.3
      });
      
      gsap.to(card.scale, {
        x: card.userData && card.userData.isInHand ? 0.54 : 1,
        y: 1,
        z: card.userData && card.userData.isInHand ? 0.54 : 1,
        duration: 0.3
      });
    }
    
    function selectSpellCard(card) { /* –±–æ–ª—å—à–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è ‚Äî –∫–∞—Å—Ç —Å–ø–µ–ª–ª–æ–≤ —Ç–æ–ª—å–∫–æ drag&drop */ }
    
    function resetCardSelection() {
      if (selectedCard) {
        returnCardToHand(selectedCard);
        selectedCard.material[2].emissive = new THREE.Color(0x000000);
        selectedCard.material[2].emissiveIntensity = 0;
        selectedCard = null;
      }
    }
    
    function showOrientationPanel() {
      document.getElementById('orientation-panel').classList.remove('hidden');
    }
    
    function hideOrientationPanel() {
      document.getElementById('orientation-panel').classList.add('hidden');
      pendingPlacement = null;
    }
    
    function showUnitActionPanel(unitMesh) {
      selectedUnit = unitMesh;
      const unitData = unitMesh.userData.unitData;
      const cardData = unitMesh.userData.cardData;
      
      document.getElementById('unit-info').textContent = 
        `${cardData.name} (${unitMesh.userData.row + 1},${unitMesh.userData.col + 1})`;
      
      const alreadyAttacked = unitData.lastAttackTurn === gameState.turn;
      const attackBtn = document.getElementById('attack-btn');
      attackBtn.disabled = alreadyAttacked;
      const cost = attackCost(cardData);
      attackBtn.textContent = alreadyAttacked ? '–£–∂–µ –∞—Ç–∞–∫–æ–≤–∞–ª' : `–ê—Ç–∞–∫–æ–≤–∞—Ç—å (‚àí${cost})`;
      // –†–æ—Ç–∞—Ü–∏—è: –ø–ª–∞—Ç–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ, 1 —Ä–∞–∑ –∑–∞ —Ö–æ–¥
      const rotateCost = attackCost(cardData);
      const alreadyRotated = unitData.lastRotateTurn === gameState.turn;
      const rCw = document.getElementById('rotate-cw-btn');
      const rCcw = document.getElementById('rotate-ccw-btn');
      if (rCw && rCcw) {
        rCw.disabled = !!alreadyRotated;
        rCcw.disabled = !!alreadyRotated;
        rCw.textContent = alreadyRotated ? '–£–∂–µ –ø–æ–≤–æ—Ä–∞—á–∏–≤–∞–ª—Å—è' : `–ü–æ–≤–µ—Ä–Ω—É—Ç—å ‚Üª (‚àí${rotateCost})`;
        rCcw.textContent = alreadyRotated ? '–£–∂–µ –ø–æ–≤–æ—Ä–∞—á–∏–≤–∞–ª—Å—è' : `–ü–æ–≤–µ—Ä–Ω—É—Ç—å ‚Ü∫ (‚àí${rotateCost})`;
      }
      // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã—Ö —Ü–µ–ª–µ–π –≤ –ø–∞–Ω–µ–ª–∏ –¥–µ–π—Å—Ç–≤–∏–π
      const hits = computeHits(gameState, selectedUnit.userData.row, selectedUnit.userData.col);
      for (const h of hits) {
        const m = unitMeshes.find(m => m.userData.row === h.r && m.userData.col === h.c);
        if (!m) continue;
        const ringGeom = new THREE.RingGeometry(0.6, 0.8, 24);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0xf97316, transparent:true, opacity:0.7, side:THREE.DoubleSide });
        const ring = new THREE.Mesh(ringGeom, ringMat);
        ring.rotation.x = -Math.PI/2;
        ring.position.copy(m.position).add(new THREE.Vector3(0, -0.45, 0));
        effectsGroup.add(ring);
        gsap.to(ring.material, { opacity: 0, duration: 0.8, onComplete: ()=> effectsGroup.remove(ring) });
      }
      
      document.getElementById('unit-action-panel').classList.remove('hidden');
    }
    
    function hideUnitActionPanel() {
      document.getElementById('unit-action-panel').classList.add('hidden');
      selectedUnit = null;
    }
    
    async function initGame() {
      gameState = startGame(STARTER_FIRESET, STARTER_FIRESET);
      
      // –°—Ä–∞–∑—É —Å—Ç—Ä–æ–∏–º —Å—Ü–µ–Ω—É –∏ –º–µ—Ç–∞-–æ–±—ä–µ–∫—Ç—ã, –±–µ–∑ –∑–∞–¥–µ—Ä–∂–∫–∏ –ø–æ—è–≤–ª–µ–Ω–∏—è
      createBoard();
      createMetaObjects();
      updateUnits();
      updateHand();
      updateUI();
      // –ó–∞—Å—Ç–∞–≤–∫–∞ —Ö–æ–¥–∞ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –∏–≥—Ä—ã —Å —Ä–µ–∑–µ—Ä–≤–æ–º (—É—Å–∫–æ—Ä–µ–Ω–∞)
      try { await forceTurnSplashWithRetry(2); } catch {}
      // –ó–∞–ø—É—Å–∫ —Ç–∞–π–º–µ—Ä–∞ –Ω–∞ –ø–µ—Ä–≤–æ–º —Ö–æ–¥—É
      try { if (window.__turnTimerId) clearInterval(window.__turnTimerId); } catch {}
      window.__turnTimerSeconds = 100;
      (function syncBtn(){ try {
        const btn = document.getElementById('end-turn-btn');
        if (btn) {
          const fill = btn.querySelector('.time-fill');
          const txt = btn.querySelector('.sec-text');
          if (txt) txt.textContent = `${window.__turnTimerSeconds}`;
          if (fill) fill.style.top = `0%`;
        }
      } catch {} })();
      window.__turnTimerId = setInterval(() => {
        if (typeof window.__turnTimerSeconds !== 'number') window.__turnTimerSeconds = 100;
        if (window.__turnTimerSeconds > 0) window.__turnTimerSeconds -= 1;
        try {
          const btn = document.getElementById('end-turn-btn');
          if (btn) {
            const fill = btn.querySelector('.time-fill');
            const txt = btn.querySelector('.sec-text');
            const s = Math.max(0, Math.min(100, window.__turnTimerSeconds));
            if (txt) txt.textContent = `${s}`;
            const percent = s / 100; if (fill) fill.style.top = `${Math.round((1 - percent) * 100)}%`;
            if (s <= 10) { btn.classList.add('urgent'); } else { btn.classList.remove('urgent'); }
          }
        } catch {}
      }, 1000);
      
      addLog('–ò–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å! –ò–≥—Ä–æ–∫ 1 —Ö–æ–¥–∏—Ç –ø–µ—Ä–≤—ã–º.');
      addLog('–ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–π—Ç–µ –∫–∞—Ä—Ç—ã —Å—É—â–µ—Å—Ç–≤ –Ω–∞ –ø–æ–ª–µ, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∑–∞–∫–ª–∏–Ω–∞–Ω–∏—è –∫–ª–∏–∫–æ–º.');
    }
    
    async function endTurn() {
      if (!gameState || gameState.winner !== null) return;
      if (isInputLocked()) return;
      // –û–Ω–ª–∞–π–Ω-–≥–µ–π—Ç: –Ω–µ –ø–æ–∑–≤–æ–ª—è–µ–º –∑–∞–≤–µ—Ä—à–∏—Ç—å —Ö–æ–¥, –µ—Å–ª–∏ —Å–µ–π—á–∞—Å –Ω–µ –≤–∞—à —Ö–æ–¥
      try {
        if (typeof window !== 'undefined' && typeof window.MY_SEAT === 'number') {
          if (gameState.active !== window.MY_SEAT) { showNotification('–°–µ–π—á–∞—Å —Ö–æ–¥ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞', 'error'); return; }
        }
      } catch {}
      __endTurnInProgress = true;
      // –°–±—Ä–æ—Å –∏ –∑–∞–ø—É—Å–∫ —Ç–∞–π–º–µ—Ä–∞ —Ö–æ–¥–∞ –Ω–∞ 100 —Å–µ–∫—É–Ω–¥
      try { if (window.__turnTimerId) clearInterval(window.__turnTimerId); } catch {}
      window.__turnTimerSeconds = 100;
      (function syncBtn(){ try {
        const btn = document.getElementById('end-turn-btn');
        if (btn) {
          const fill = btn.querySelector('.time-fill');
          const txt = btn.querySelector('.sec-text');
          if (txt) txt.textContent = `${window.__turnTimerSeconds}`;
          if (fill) fill.style.top = `0%`;
        }
      } catch {} })();
      window.__turnTimerId = setInterval(() => {
        if (typeof window.__turnTimerSeconds !== 'number') window.__turnTimerSeconds = 100;
        if (window.__turnTimerSeconds > 0) window.__turnTimerSeconds -= 1;
        try {
          const btn = document.getElementById('end-turn-btn');
          if (btn) {
            const fill = btn.querySelector('.time-fill');
            const txt = btn.querySelector('.sec-text');
            const s = Math.max(0, Math.min(100, window.__turnTimerSeconds));
            if (txt) txt.textContent = `${s}`;
            const percent = s / 100; // 1 -> top:0%, 0 -> top:100%
            if (fill) fill.style.top = `${Math.round((1 - percent) * 100)}%`;
            // –ü—É–ª—å—Å–∞—Ü–∏—è —Ä–∞–º–∫–∏ –≤ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 10 —Å–µ–∫—É–Ω–¥
            if (s <= 10) { btn.classList.add('urgent'); } else { btn.classList.remove('urgent'); }
          }
        } catch {}
      }, 1000);
      
      const controlledCells = countControlled(gameState, gameState.active);
      if (controlledCells >= 5) {
        gameState.winner = gameState.active;
        showNotification(`${gameState.players[gameState.active].name} –ø–æ–±–µ–∂–¥–∞–µ—Ç!`, 'success');
        return;
      }
      
      // –û—á–∏—Å—Ç–∏—Ç—å –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –±–∞—Ñ—ã, –¥–µ–π—Å—Ç–≤—É—é—â–∏–µ ¬´–¥–æ –∫–æ–Ω—Ü–∞ —Ö–æ–¥–∞ –∫–∞—Å—Ç–µ—Ä–∞¬ª
      try {
        for (let rr = 0; rr < 3; rr++) for (let cc = 0; cc < 3; cc++) {
          const u = gameState.board[rr][cc].unit; if (!u) continue;
          if (typeof u.tempAtkBuff === 'number' && u.tempBuffOwner === gameState.active) {
            delete u.tempAtkBuff; delete u.tempBuffOwner;
          }
        }
      } catch {}
      gameState.active = gameState.active === 0 ? 1 : 0;
      gameState.turn += 1;
      
      const player = gameState.players[gameState.active];
      const before = player.mana;
      const manaAfter = capMana(before + 2);
      // –ö–∞—Ä—Ç–∞ –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏: –∏–∑–≤–ª–µ–∫–∞–µ–º
      const drawnTpl = drawOneNoAdd(gameState, gameState.active);
      // –õ–û–ì–ò–ö–ê: –ø—Ä–∏–º–µ–Ω–∏–º –º–∞–Ω—É —Å—Ä–∞–∑—É, –∞ –∫–∞—Ä—Ç—É –¥–æ–±–∞–≤–∏–º –ø–æ—Å–ª–µ –∞–Ω–∏–º–∞—Ü–∏–∏ (—É –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –∫–ª–∏–µ–Ω—Ç–∞)
      player.mana = manaAfter;
      // –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–µ–∂–¥–µ–≤—Ä–µ–º–µ–Ω–Ω–æ–µ –ø–æ—è–≤–ª–µ–Ω–∏–µ –Ω–æ–≤—ã—Ö –æ—Ä–±–æ–≤ –¥–æ –∞–Ω–∏–º–∞—Ü–∏–∏ –≤—Å–ø—ã—à–∫–∏
      try { PENDING_MANA_ANIM = { ownerIndex: gameState.active, startIdx: Math.max(0, Math.min(9, before)), endIdx: Math.max(-1, Math.min(9, manaAfter - 1)) }; } catch {}
      let shouldAnimateDraw = false;
      try {
        const amIActiveNow = (typeof window !== 'undefined' && typeof window.MY_SEAT === 'number')
          ? (window.MY_SEAT === gameState.active)
          : true;
        shouldAnimateDraw = !!(amIActiveNow && drawnTpl);
        if (!shouldAnimateDraw && drawnTpl) {
          // –ï—Å–ª–∏ —ç—Ç–æ –Ω–µ –Ω–∞—à –∫–ª–∏–µ–Ω—Ç ‚Äî –¥–æ–±–∞–≤–∏–º –∫–∞—Ä—Ç—É —Å—Ä–∞–∑—É (–±–µ–∑ –∞–Ω–∏–º–∞—Ü–∏–∏)
          try { gameState.players[gameState.active].hand.push(drawnTpl); } catch {}
        }
      } catch {}
      updateHand();
      try { schedulePush('endTurn-apply', { force: true }); } catch {}
      
      resetCardSelection();
      
      updateHand();
      updateUnits();
      // updateUI –≤—ã–ø–æ–ª–Ω–∏—Ç—Å—è –≤–º–µ—Å—Ç–µ —Å –∞–Ω–∏–º–∞—Ü–∏–µ–π –º–∞–Ω—ã (–ø–æ—Å–ª–µ –∑–∞—Å—Ç–∞–≤–∫–∏)
      // –ü–æ–∫–∞–∑ –∑–∞—Å—Ç–∞–≤–∫–∏ —Ö–æ–¥–∞: —Å—Ç—Ä–æ–≥–æ –±–ª–æ–∫–∏—Ä—É—é—â–µ (–≤–∏–∑—É–∞–ª—å–Ω–∞—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å)
      try { await forceTurnSplashWithRetry(2); } catch {}
      // –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å —Ç–∞–π–º–µ—Ä —Ö–æ–¥–∞ –Ω–∞ 100 —Å–µ–∫ –ø–æ—Å–ª–µ –∑–∞—Å—Ç–∞–≤–∫–∏ (–∞–Ω–∏–º–∞—Ü–∏—è —Ç–∞–π–º–µ—Ä–∞ –ª–æ–∫–∞–ª—å–Ω–æ —É –æ–±–æ–∏—Ö)
      try { if (window.__turnTimerId) clearInterval(window.__turnTimerId); } catch {}
      window.__turnTimerSeconds = 100;
      (function syncBtn(){ try {
        const btn = document.getElementById('end-turn-btn');
        if (btn) {
          const fill = btn.querySelector('.time-fill');
          const txt = btn.querySelector('.sec-text');
          if (txt) txt.textContent = `${window.__turnTimerSeconds}`;
          if (fill) fill.style.top = `0%`;
        }
      } catch {} })();
      window.__turnTimerId = setInterval(() => {
        if (typeof window.__turnTimerSeconds !== 'number') window.__turnTimerSeconds = 100;
        if (window.__turnTimerSeconds > 0) window.__turnTimerSeconds -= 1;
        try {
          const btn = document.getElementById('end-turn-btn');
          if (btn) {
            const fill = btn.querySelector('.time-fill');
            const txt = btn.querySelector('.sec-text');
            const s = Math.max(0, Math.min(100, window.__turnTimerSeconds));
            if (txt) txt.textContent = `${s}`;
            const percent = s / 100;
            if (fill) fill.style.top = `${Math.round((1 - percent) * 100)}%`;
            if (s <= 10) { btn.classList.add('urgent'); } else { btn.classList.remove('urgent'); }
          }
        } catch {}
      }, 1000);
      // –≠—Ñ—Ñ–µ–∫—Ç–Ω–∞—è –∞–Ω–∏–º–∞—Ü–∏—è –º–∞–Ω—ã: –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —É –æ–±–æ–∏—Ö –∏–≥—Ä–æ–∫–æ–≤, –Ω–æ –¥–ª—è –∞–∫—Ç–∏–≤–Ω–æ–≥–æ ‚Äî –∞–Ω–∏–º–∏—Ä—É–µ–º –µ–≥–æ –ø–∞–Ω–µ–ª—å
      try { await animateTurnManaGain(gameState.active, before, manaAfter, 1500); } catch {}
      // –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ (<0.1—Å) –ø–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º –ø—Ä–æ—è–≤–ª–µ–Ω–∏—è –±–æ–ª—å—à–æ–π –∫–∞—Ä—Ç—ã
      await sleep(80);
      // –í–ò–ó–£–ê–õ: –ª–æ–∫–∞–ª—å–Ω–æ –ø—Ä–æ–∏–≥—Ä—ã–≤–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏–∏ –¥–æ–±–æ—Ä–∞ –¢–û–õ–¨–ö–û –µ—Å–ª–∏ —ç—Ç–æ –Ω–∞—à –∫–ª–∏–µ–Ω—Ç
      updateUI();
      try {
        if (shouldAnimateDraw && drawnTpl) {
          // –°–∫—Ä—ã–≤–∞–µ–º ¬´–∑–∞–¥–µ—Ä–∂–∞–Ω–Ω—É—é¬ª –∫–∞—Ä—Ç—É –∏–∑ —Ä—É–∫–∏, –ø–æ–∫–∞ –∏–¥—ë—Ç –ø–æ–ª—ë—Ç
          pendingDrawCount = 1; updateHand();
          refreshInputLockUI();
          await animateDrawnCardToHand(drawnTpl);
          // –ü–æ—Å–ª–µ –ø–æ–ª—ë—Ç–∞ –¥–æ–±–∞–≤–ª—è–µ–º –∫–∞—Ä—Ç—É –≤ —Ä—É–∫—É –∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –µ—ë
          try { gameState.players[gameState.active].hand.push(drawnTpl); } catch {}
          pendingDrawCount = 0; updateHand();
        }
      } catch { pendingDrawCount = 0; }
      
      addLog(`–•–æ–¥ ${gameState.turn}. ${player.name} –ø–æ–ª—É—á–∞–µ—Ç +2 –º–∞–Ω—ã –∏ –¥–æ–±–∏—Ä–∞–µ—Ç –∫–∞—Ä—Ç—É.`);
      
      // –ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –≤–≤–æ–¥–∞
      __endTurnInProgress = false;
      manaGainActive = false;
      refreshInputLockUI();
    }
    function placeUnitWithDirection(direction) {
      if (!pendingPlacement) return;
      
      const { card, row, col, handIndex } = pendingPlacement;
      const cardData = card.userData.cardData;
      const player = gameState.players[gameState.active];
      
      if (cardData.cost > player.mana) {
        showNotification('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–∞–Ω—ã!', 'error');
        returnCardToHand(card);
        hideOrientationPanel();
        return;
      }
      
      const unit = {
        uid: uid(),
        owner: gameState.active,
        tplId: cardData.id,
        currentHP: cardData.hp,
        facing: direction
      };
      
      gameState.board[row][col].unit = unit;
      
      player.mana -= cardData.cost;
      player.discard.push(cardData);
      player.hand.splice(handIndex, 1);
      
      const cellElement = gameState.board[row][col].element;
      const buff = computeCellBuff(cellElement, cardData.element);
      if (buff.hp !== 0) {
        const before = unit.currentHP;
        unit.currentHP = Math.max(0, unit.currentHP + buff.hp);
        if (buff.hp > 0) {
          addLog(`–≠–ª–µ–º–µ–Ω—Ç —É—Å–∏–ª–∏–≤–∞–µ—Ç ${cardData.name}: HP ${before}‚Üí${unit.currentHP}`);
        } else {
          addLog(`–≠–ª–µ–º–µ–Ω—Ç –æ—Å–ª–∞–±–ª—è–µ—Ç ${cardData.name}: HP ${before}‚Üí${unit.currentHP}`);
        }
      }
      
      if (unit.currentHP <= 0) {
        addLog(`${cardData.name} –ø–æ–≥–∏–±–∞–µ—Ç –æ—Ç –Ω–µ–±–ª–∞–≥–æ–ø—Ä–∏—è—Ç–Ω–æ–π —Å—Ç–∏—Ö–∏–∏!`);
        const owner = unit.owner;
        // –∞–Ω–∏–º–∞—Ü–∏—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –º–∞–Ω—ã + —É—á—ë—Ç –∫–ª–∞–¥–±–∏—â–∞
        try { gameState.players[owner].graveyard.push(CARDS[unit.tplId]); } catch {}
        const pos = tileMeshes[row][col].position.clone().add(new THREE.Vector3(0, 1.2, 0));
        animateManaGainFromWorld(pos, owner);
        gameState.board[row][col].unit = null;
      }
      
      const targetPos = tileMeshes[row][col].position.clone();
      targetPos.y = tileMeshes[row][col].position.y + 0.28;
      
      gsap.to(card.position, {
        x: targetPos.x,
        y: targetPos.y,
        z: targetPos.z,
        duration: 0.5,
        ease: "power2.inOut"
      });
      
      gsap.to(card.rotation, {
        x: 0,
        y: (facingDeg[direction]) * Math.PI / 180,
        z: 0,
        duration: 0.5,
        onComplete: () => {
          updateHand();
          updateUnits();
          updateUI();
          // –ü–æ—Å–ª–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è ‚Äî –µ—Å–ª–∏ –µ—Å—Ç—å —Ü–µ–ª–∏, –∑–∞–ø—É—Å–∫–∞–µ–º –µ–¥–∏–Ω—ã–π –±–æ–µ–≤–æ–π —Å—Ü–µ–Ω–∞—Ä–∏–π
          const hitsNow = computeHits(gameState, row, col);
          if (hitsNow && hitsNow.length) performBattleSequence(row, col, false);
        }
      });
      
      addLog(`${player.name} –ø—Ä–∏–∑—ã–≤–∞–µ—Ç ${cardData.name} –Ω–∞ (${row + 1},${col + 1})`);
      hideOrientationPanel();
    }
    
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function init() {
      initThreeJS();
      initGame();
      preloadCardImages();
      
      renderer.domElement.addEventListener('mousemove', onMouseMove);
      renderer.domElement.addEventListener('mousedown', onMouseDown);
      renderer.domElement.addEventListener('mouseup', onMouseUp);
      renderer.domElement.addEventListener('mouseleave', () => {
        if (hoveredHandCard) {
          gsap.to(hoveredHandCard.scale, { x: 0.54, y: 1, z: 0.54, duration: 0.18 });
          setHandCardHoverVisual(hoveredHandCard, false);
          hoveredHandCard = null;
        }
      });
      window.addEventListener('resize', onWindowResize);
      
      animate();
    }

    function createMetaObjects() {
      // –û—á–∏—Å—Ç–∏—Ç—å –ø—Ä–µ–¥—ã–¥—É—â–∏–µ
      deckMeshes.forEach(m => m.parent && m.parent.remove(m));
      graveyardMeshes.forEach(m => m.parent && m.parent.remove(m));
      deckMeshes = []; graveyardMeshes = [];
      if (!gameState) return;
      const baseX = (6.2 + 0.2) * 1 + 6.6; // –ø—Ä–∞–≤–µ–µ –ø–æ–ª—è
      const zA = -5.2 - META_Z_AWAY; const zB = 0.2 + META_Z_AWAY; // –í–∞–∂–Ω–æ (—Å–º–µ—â–µ–Ω–∏–µ –∫–æ–ª–æ–¥—ã/–∫–ª–∞–¥–±–∏—â–∞ –æ—Ç –∫–∞–º–µ—Ä—ã)
      function buildDeck(player, z) {
        const g = new THREE.Group(); g.position.set(baseX, 0.5, z); g.userData = { metaType: 'deck', player };
        const body = new THREE.Mesh(new THREE.BoxGeometry(3.6, 0.8, 5.0), new THREE.MeshStandardMaterial({ color: 0x0f172a, metalness: 0.3, roughness: 0.8 }));
        body.castShadow = true; body.receiveShadow = true; body.userData = { metaType: 'deck', player };
        const top = new THREE.Mesh(new THREE.BoxGeometry(3.62, 0.04, 5.02), new THREE.MeshStandardMaterial({ color: 0x1e293b }));
        top.position.y = 0.42; top.userData = { metaType: 'deck', player };
        g.add(body); g.add(top); metaGroup.add(g); deckMeshes.push(g);
      }
      function buildGrave(player, z) {
        const g = new THREE.Group(); g.position.set(baseX + 4.2, 0.5, z); g.userData = { metaType: 'grave', player };
        const base = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.2, 0.3, 20), new THREE.MeshStandardMaterial({ color: 0x334155 }));
        base.userData = { metaType: 'grave', player };
        const icon = new THREE.Mesh(new THREE.BoxGeometry(1.0, 1.2, 0.1), new THREE.MeshStandardMaterial({ color: 0x64748b }));
        icon.position.y = 0.9; icon.rotation.y = Math.PI / 8; icon.userData = { metaType: 'grave', player };
        g.add(base); g.add(icon); metaGroup.add(g); graveyardMeshes.push(g);
      }
      buildDeck(0, zA); buildDeck(1, zB); buildGrave(0, zA); buildGrave(1, zB);
    }
    
    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ UI
    document.getElementById('end-turn-btn').addEventListener('click', () => {
      try { if (typeof window.endTurn === 'function') window.endTurn(); } catch {}
    });
    refreshInputLockUI();
    document.getElementById('new-game-btn').addEventListener('click', () => location.reload());
    document.getElementById('log-btn').addEventListener('click', () => {
      const lp = document.getElementById('log-panel');
      lp.classList.toggle('hidden');
      // –ù–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π –∂—ë—Å—Ç–∫–æ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –Ω–∏–∂–µ –∫–æ–Ω—Ç—Ä–æ–ª–æ–≤
      lp.style.top = (document.getElementById('controls').offsetHeight + 40) + 'px';
      if (!lp.classList.contains('hidden')) lp.style.pointerEvents = 'auto';
    });
    document.getElementById('close-log-btn').addEventListener('click', () => {
      document.getElementById('log-panel').classList.add('hidden');
    });
    document.getElementById('help-btn').addEventListener('click', () => {
      document.getElementById('help-panel').classList.remove('hidden');
    });
    document.getElementById('close-help-btn').addEventListener('click', () => {
      document.getElementById('help-panel').classList.add('hidden');
    });
    // Prompt handlers
    document.getElementById('cancel-prompt-btn').addEventListener('click', () => {
      if (activePrompt && typeof activePrompt.onCancel === 'function') {
        try { activePrompt.onCancel(); } catch {}
      }
      hidePrompt();
    });
    document.getElementById('cancel-orient-btn').addEventListener('click', () => {
      if (pendingPlacement) {
        returnCardToHand(pendingPlacement.card);
      }
      hideOrientationPanel();
    });
    document.getElementById('cancel-action-btn').addEventListener('click', hideUnitActionPanel);
    // –î–µ–π—Å—Ç–≤–∏—è –≤ –ø–∞–Ω–µ–ª–∏ —é–Ω–∏—Ç–∞
    document.getElementById('rotate-cw-btn').addEventListener('click', () => {
      if (selectedUnit) rotateUnit(selectedUnit, 'cw');
    });
    document.getElementById('rotate-ccw-btn').addEventListener('click', () => {
      if (selectedUnit) rotateUnit(selectedUnit, 'ccw');
    });
    document.getElementById('attack-btn').addEventListener('click', () => {
      if (selectedUnit) performUnitAttack(selectedUnit);
    });
    
    document.querySelectorAll('[data-dir]').forEach(btn => {
      btn.addEventListener('click', () => {
        // –Ø–≤–Ω–æ–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Å–∏–º–≤–æ–ª–æ–≤ –Ω–∞ –∫–Ω–æ–ø–∫–∞—Ö –∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π
        const direction = btn.getAttribute('data-dir'); // 'N' | 'E' | 'S' | 'W'
        // –ï—Å–ª–∏ –æ–∂–∏–¥–∞–µ—Ç—Å—è –≤—ã–±–æ—Ä –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–ª—è —Å–ø–µ–ª–ª–∞ ‚Äî –ø—Ä–∏–º–µ–Ω–∏–º –µ–≥–æ –∏ –∑–∞–≤–µ—Ä—à–∏–º
        if (pendingSpellOrientation) {
          const { spellCardMesh, unitMesh } = pendingSpellOrientation;
          const idx = spellCardMesh.userData.handIndex;
          const pl = gameState.players[gameState.active];
          const tpl = pl.hand[idx];
          const r = unitMesh.userData.row; const c = unitMesh.userData.col; const u = gameState.board[r][c].unit;
          if (tpl && tpl.id === 'SPELL_BEGUILING_FOG' && u) {
            u.facing = direction;
            addLog(`${tpl.name}: ${CARDS[u.tplId].name} –ø–æ–≤—ë—Ä–Ω—É—Ç –≤ ${direction}.`);
            pl.discard.push(tpl); pl.hand.splice(idx, 1);
            resetCardSelection(); updateHand(); updateUnits(); updateUI();
          }
          pendingSpellOrientation = null; hideOrientationPanel();
          return;
        }
        // –ò–Ω–∞—á–µ ‚Äî —à—Ç–∞—Ç–Ω–æ–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ —é–Ω–∏—Ç–∞
        if (direction === 'N') return placeUnitWithDirection('N');
        if (direction === 'E') return placeUnitWithDirection('E');
        if (direction === 'S') return placeUnitWithDirection('S');
        if (direction === 'W') return placeUnitWithDirection('W');
      });
    });
    
    document.addEventListener('DOMContentLoaded', init);

    // ====== –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò –î–ï–ô–°–¢–í–ò–ô ======
    function showPrompt(text, onCancel) {
      const pp = document.getElementById('prompt-panel');
      const pt = document.getElementById('prompt-text');
      if (pp && pt) {
        pt.textContent = text || '';
        pp.classList.remove('hidden');
        activePrompt = { text, onCancel };
      }
    }
    function hidePrompt() {
      const pp = document.getElementById('prompt-panel');
      if (pp) pp.classList.add('hidden');
      activePrompt = null;
    }
    function rotateUnit(unitMesh, dir) {
      if (isInputLocked()) return;
      const u = unitMesh.userData.unitData;
      if (!u) return;
      if (u.owner !== gameState.active) { showNotification('–ù–µ–ª—å–∑—è –ø–æ–≤–æ—Ä–∞—á–∏–≤–∞—Ç—å —á—É–∂–æ–µ —Å—É—â–µ—Å—Ç–≤–æ', 'error'); return; }
      if (u.lastRotateTurn === gameState.turn) { showNotification('–£–∂–µ –ø–æ–≤–æ—Ä–∞—á–∏–≤–∞–ª—Å—è –≤ —ç—Ç–æ—Ç —Ö–æ–¥', 'error'); return; }
      const tpl = CARDS[u.tplId];
      const cost = attackCost(tpl);
      if (gameState.players[gameState.active].mana < cost) { showNotification(`–ù—É–∂–Ω–æ ${cost} –º–∞–Ω—ã –¥–ª—è –ø–æ–≤–æ—Ä–æ—Ç–∞`, 'error'); return; }
      gameState.players[gameState.active].mana -= cost; updateUI();
      u.facing = dir === 'cw' ? turnCW[u.facing] : turnCCW[u.facing];
      u.lastRotateTurn = gameState.turn;
      updateUnits();
      hideUnitActionPanel();
    }
    
    function performUnitAttack(unitMesh) {
      if (!unitMesh) return;
      if (isInputLocked()) return;
      const r = unitMesh.userData.row; const c = unitMesh.userData.col;
      const unit = gameState.board[r][c].unit; if (!unit) return;
      const tpl = CARDS[unit.tplId];
      const cost = attackCost(tpl);
      if (tpl.attackType === 'MAGIC') {
        if (gameState.players[gameState.active].mana < cost) { showNotification(`–ù—É–∂–Ω–æ ${cost} –º–∞–Ω—ã –¥–ª—è –∞—Ç–∞–∫–∏`, 'error'); return; }
        gameState.players[gameState.active].mana -= cost;
        updateUI();
        magicFrom = { r, c };
        addLog(`${tpl.name}: –≤—ã–±–µ—Ä–∏—Ç–µ —Ü–µ–ª—å –¥–ª—è –º–∞–≥–∏—á–µ—Å–∫–æ–π –∞—Ç–∞–∫–∏.`);
        hideUnitActionPanel();
        return;
      }
      const hits = computeHits(gameState, r, c);
      if (!hits.length) { showNotification('–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ü–µ–ª–µ–π –¥–ª—è –∞—Ç–∞–∫–∏', 'error'); hideUnitActionPanel(); return; }
      if (gameState.players[gameState.active].mana < cost) { showNotification(`–ù—É–∂–Ω–æ ${cost} –º–∞–Ω—ã –¥–ª—è –∞—Ç–∞–∫–∏`, 'error'); hideUnitActionPanel(); return; }
      gameState.players[gameState.active].mana -= cost;
      updateUI();
      performBattleSequence(r, c, true);
      hideUnitActionPanel();
    }
    
    async function performBattleSequence(r, c, markAttackTurn) {
      const staged = stagedAttack(gameState, r, c);
      if (!staged || staged.empty) return;
      // flashy –∑–∞—Å—Ç–∞–≤–∫–∞ BATTLE (—Å–æ–∫—Ä–∞—â—ë–Ω–Ω–∞—è)
      await showBattleSplash();
      // –Ω–µ–±–æ–ª—å—à–∞—è –∞–Ω–∏–º–∞—Ü–∏—è –≤—ã–ø–∞–¥–∞/—Ç–æ–ª—á–∫–∞
      const aMesh = unitMeshes.find(m => m.userData.row === r && m.userData.col === c);
      const hitsPrev = computeHits(gameState, r, c);
      const fromPos = (aMesh ? aMesh.position.clone() : tileMeshes[r][c].position.clone().add(new THREE.Vector3(0, 0.8, 0)));

      const doStep1 = () => {
        // –£–±—Ä–∞–Ω—ã –∂—ë–ª—Ç—ã–µ –ª—É—á–∏/—Å—Ç—Ä–µ–ª–∫–∏ –ø–æ–¥ –∫–∞—Ä—Ç–∞–º–∏
        // –ü—Ä–∏–º–µ–Ω—è–µ–º —É—Ä–æ–Ω (—ç—Ç–∞–ø 1) –∏ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º —é–Ω–∏—Ç—ã
        staged.step1();
        gameState = staged.n1; updateUnits();
        // –¢—Ä—è—Å–∫–∞ –∏ –≤—Å–ø–ª—ã–≤–∞—é—â–∏–π —É—Ä–æ–Ω ‚Äî —É–∂–µ –ø–æ –∞–∫—Ç—É–∞–ª—å–Ω—ã–º –º–µ—à–∞–º –ø–æ—Å–ª–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
        for (const h of hitsPrev) {
          const tMesh = unitMeshes.find(m => m.userData.row === h.r && m.userData.col === h.c);
          if (tMesh) { shakeMesh(tMesh, 6, 0.12); spawnDamageText(tMesh, `-${h.dmg}`, '#ff5555'); }
        }
        setTimeout(async () => {
          // –°–æ–∫—Ä–∞—â—ë–Ω–Ω–∞—è –ø–∞—É–∑–∞ –ø–µ—Ä–µ–¥ –∫–æ–Ω—Ç—Ä–∞—Ç–∞–∫–æ–π
          await sleep(700);
          const ret = staged.step2() || { total: 0, retaliators: [] };
          const retaliation = typeof ret === 'number' ? ret : (ret.total || 0);
          let animDelayMs = 0;
          if (retaliation > 0) {
            // –í—ã–ø–∞–¥ –≤—Å–µ—Ö –∫–æ–Ω—Ç—Ä–∞—Ç–∞–∫—É—é—â–∏—Ö
            const retaliators = (ret.retaliators || []);
            let maxDur = 0;
            for (const rrObj of retaliators) {
              const rMesh = unitMeshes.find(m => m.userData.row === rrObj.r && m.userData.col === rrObj.c);
              // –ü–µ—Ä–µ—Å—á–∏—Ç–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–π –º–µ—à –∞—Ç–∞–∫—É—é—â–µ–≥–æ –ø–æ—Å–ª–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —é–Ω–∏—Ç–æ–≤
              const aMeshLive = unitMeshes.find(m => m.userData.row === r && m.userData.col === c) || aMesh;
              if (rMesh && aMeshLive) {
                const dir2 = new THREE.Vector3().subVectors(aMeshLive.position, rMesh.position).normalize();
                const push2 = { x: dir2.x * 0.6, z: dir2.z * 0.6 };
                const tl2 = gsap.timeline();
                tl2.to(rMesh.position, { x: `+=${push2.x}`, z: `+=${push2.z}`, duration: 0.22, ease: 'power2.out' })
                   .to(rMesh.position, { x: `-=${push2.x}`, z: `-=${push2.z}`, duration: 0.30, ease: 'power2.inOut' });
                maxDur = Math.max(maxDur, 0.52);
              }
            }
            // –ü–æ—Å–ª–µ –ª—É–Ω–∂–µ–π –∫–æ–Ω—Ç—Ä–∞—Ç–∞–∫–∏ ‚Äî —Ç—Ä—è—Å–∫–∞ –∏ —á–∏—Å–ª–∞ —É—Ä–æ–Ω–∞ –ø–æ –∞—Ç–∞–∫—É—é—â–µ–º—É
            setTimeout(() => { const aLive = unitMeshes.find(m => m.userData.row === r && m.userData.col === c) || aMesh; if (aLive) { shakeMesh(aLive, 6, 0.14); spawnDamageText(aLive, `-${retaliation}`, '#ffd166'); } }, Math.max(0, maxDur * 1000 - 10));
            animDelayMs = Math.max(animDelayMs, Math.floor(maxDur * 1000) + 160);
            // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∫–æ–Ω—Ç—Ä–∞—Ç–∞–∫–∏ –¥–ª—è –Ω–∞–±–ª—é–¥–∞—Ç–µ–ª—è
            try {
              if (typeof socket !== 'undefined' && NET_ACTIVE && MY_SEAT === gameState.active) {
                socket.emit('battleRetaliation', {
                  attacker: { r, c },
                  retaliators: retaliators.map(x => ({ r: x.r, c: x.c })),
                  total: retaliation
                });
              }
            } catch {}
          }
          // –§–∏–Ω–∞–ª–∏–∑–∞—Ü–∏—è: –∞–Ω–∏–º–∞—Ü–∏—è —Å–º–µ—Ä—Ç–∏ –∏ –æ—Ä–±—ã –ø–µ—Ä–µ–¥ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏—è
          const res = staged.finish();
          if (res.deaths && res.deaths.length) {
            for (const d of res.deaths) {
              try { gameState.players[d.owner].graveyard.push(CARDS[d.tplId]); } catch {}
              const deadMesh = unitMeshes.find(m => m.userData.row === d.r && m.userData.col === d.c);
              if (deadMesh) {
                const fromMesh = aMesh || deadMesh;
                const dirUp = new THREE.Vector3().subVectors(deadMesh.position, fromMesh.position).normalize().multiplyScalar(0.4);
                dissolveAndAsh(deadMesh, dirUp, 0.9);
              }
              const p = tileMeshes[d.r][d.c].position.clone().add(new THREE.Vector3(0, 1.6, 0));
              // –ù–∞—á–∏—Å–ª—è–µ–º –≤–ª–∞–¥–µ–ª—å—Ü—É –ø–æ–≥–∏–±—à–µ–≥–æ —Å—É—â–µ—Å—Ç–≤–∞ +1 –º–∞–Ω—É –∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é —É –æ–±–æ–∏—Ö –∏–≥—Ä–æ–∫–æ–≤
              try { if (gameState && gameState.players) { gameState.players[d.owner].mana = capMana((gameState.players[d.owner].mana || 0) + 1); } } catch {}
              animateManaGainFromWorld(p, d.owner, true);
            }
            setTimeout(() => { gameState = res.n1; updateUnits(); updateUI(); for (const l of res.logLines.reverse()) addLog(l); if (markAttackTurn && gameState.board[r][c]?.unit) gameState.board[r][c].unit.lastAttackTurn = gameState.turn; try { schedulePush('battle-finish'); } catch {} }, 1000);
          } else {
            // –ï—Å–ª–∏ —Å–º–µ—Ä—Ç–µ–π –Ω–µ—Ç ‚Äî –ø–æ–¥–æ–∂–¥—ë–º, –ø–æ–∫–∞ –∞–Ω–∏–º–∞—Ü–∏—è –∫–æ–Ω—Ç—Ä–∞—Ç–∞–∫–∏ –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è, –∑–∞—Ç–µ–º –ø—Ä–∏–º–µ–Ω–∏–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
            setTimeout(() => {
              gameState = res.n1; updateUnits(); updateUI(); for (const l of res.logLines.reverse()) addLog(l); if (markAttackTurn && gameState.board[r][c]?.unit) gameState.board[r][c].unit.lastAttackTurn = gameState.turn; try { schedulePush('battle-finish'); } catch {}
            }, Math.max(0, animDelayMs));
          }
        }, 420);
      };

      // –í—ã–ø–∞–¥ –∞—Ç–∞–∫—É—é—â–µ–≥–æ –ø–µ—Ä–µ–¥ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ–º —É—Ä–æ–Ω–∞
      if (aMesh && hitsPrev.length) {
        const firstTargetMesh = unitMeshes.find(m => m.userData.row === hitsPrev[0].r && m.userData.col === hitsPrev[0].c);
        if (firstTargetMesh) {
          const dir = new THREE.Vector3().subVectors(firstTargetMesh.position, aMesh.position).normalize();
          const push = { x: dir.x * 0.6, z: dir.z * 0.6 };
          const tl = gsap.timeline({ onComplete: doStep1 });
          tl.to(aMesh.position, { x: `+=${push.x}`, z: `+=${push.z}`, duration: 0.22, ease: 'power2.out' })
            .to(aMesh.position, { x: `-=${push.x}`, z: `-=${push.z}`, duration: 0.3, ease: 'power2.inOut' });
          // –û–Ω–ª–∞–π–Ω–æ–≤–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤—ã–ø–∞–¥–æ–≤ (–∞—Ç–∞–∫—É—é—â–∏–π –∏ —Ü–µ–ª–∏)
          try {
            if (typeof socket !== 'undefined' && NET_ACTIVE && MY_SEAT === gameState.active) {
              socket.emit('battleAnim', {
                attacker: { r, c },
                targets: hitsPrev.map(h => ({ r: h.r, c: h.c }))
              });
            }
          } catch {}
        } else {
          gsap.to(aMesh.position, { y: aMesh.position.y + 0.25, yoyo: true, repeat: 1, duration: 0.2, onComplete: doStep1 });
        }
      } else {
        doStep1();
      }
    }

    function spawnDamageText(targetMesh, text, color = '#ff5555') {
      const canvas = document.createElement('canvas');
      canvas.width = 256; canvas.height = 128;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0,0,canvas.width, canvas.height);
      ctx.font = 'bold 64px Arial';
      ctx.fillStyle = color;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.lineWidth = 6;
      ctx.strokeText(text, canvas.width/2, canvas.height/2);
      ctx.fillText(text, canvas.width/2, canvas.height/2);
      const tex = new THREE.CanvasTexture(canvas);
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, opacity: 0, depthTest: false, depthWrite: false });
      const sprite = new THREE.Sprite(mat);
      sprite.scale.set(2.6, 1.4, 1);
      const pos = targetMesh.position.clone().add(new THREE.Vector3(0, 0.9, 0));
      sprite.position.copy(pos);
      sprite.renderOrder = 999;
      effectsGroup.add(sprite);
      const tl = gsap.timeline({ onComplete: () => { effectsGroup.remove(sprite); tex.dispose(); mat.dispose(); } });
      // 0.5—Å –≤—ã–ª–µ—Ç, 1—Å —Å—Ç–æ–ø, 0.5—Å –∏—Å–ø–∞—Ä–µ–Ω–∏–µ
      tl.to(sprite.material, { opacity: 1, duration: 0.05 })
        .to(sprite.position, { y: sprite.position.y + 0.8, duration: 0.5, ease: 'power1.out' })
        .to({}, { duration: 1.0 })
        .to(sprite.position, { y: sprite.position.y + 1.6, duration: 0.5, ease: 'power1.in' }, 'end')
        .to(sprite.material, { opacity: 0, duration: 0.5 }, 'end');
    }

    function shakeMesh(mesh, times = 3, duration = 0.1) {
      const tl = gsap.timeline();
      const ox = mesh.position.x; const oz = mesh.position.z;
      for (let i = 0; i < times; i++) {
        const dx = (Math.random()*0.2 - 0.1);
        const dz = (Math.random()*0.2 - 0.1);
        tl.to(mesh.position, { x: ox + dx, z: oz + dz, duration: duration/2 })
          .to(mesh.position, { x: ox, z: oz, duration: duration/2 });
      }
      return tl;
    }

    // Dissolve shader for death effect (fiery burn-away)
    function createDissolveMaterial() {
      return new THREE.ShaderMaterial({
        transparent: true,
        depthTest: true,
        depthWrite: false,
        side: THREE.DoubleSide,
        uniforms: {
          uTime:       { value: 0.0 },
          uThreshold:  { value: 0.0 },
          uEdgeWidth:  { value: 0.08 },
          uEdgeColor:  { value: new THREE.Color(0.55, 0.80, 1.0) }, // –º–∞–≥–∏—á–µ—Å–∫–∞—è –≥–æ–ª—É–±–∞—è –∫—Ä–æ–º–∫–∞
          uBaseColor:  { value: new THREE.Color(0.90, 0.95, 1.0) }, // —Ö–æ–ª–æ–¥–Ω—ã–π —Å–≤–µ—Ç–ª—ã–π
          uNoiseScale: { value: 3.0 },
          uNoiseMove:  { value: new THREE.Vector2(0.15, -0.1) },
        },
        vertexShader: `
          varying vec2 vUv;
          varying vec3 vPos;
          void main(){
            vUv = uv;
            vec4 mv = modelViewMatrix * vec4(position, 1.0);
            vPos = (modelMatrix * vec4(position, 1.0)).xyz;
            gl_Position = projectionMatrix * mv;
          }
        `,
        fragmentShader: `
          precision highp float;
          varying vec2 vUv;
          varying vec3 vPos;
          uniform float uTime;
          uniform float uThreshold;
          uniform float uEdgeWidth;
          uniform vec3  uEdgeColor;
          uniform vec3  uBaseColor;
          uniform float uNoiseScale;
          uniform vec2  uNoiseMove;
          float hash(vec2 p){
            p = fract(p * vec2(123.34, 345.45));
            p += dot(p, p + 34.345);
            return fract(p.x * p.y);
          }
          float noise(vec2 p){
            vec2 i = floor(p);
            vec2 f = fract(p);
            float a = hash(i);
            float b = hash(i + vec2(1.0, 0.0));
            float c = hash(i + vec2(0.0, 1.0));
            float d = hash(i + vec2(1.0, 1.0));
            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
          }
          float fbm(vec2 p){
            float v = 0.0;
            float a = 0.5;
            for (int i = 0; i < 5; i++){
              v += a * noise(p);
              p *= 2.02;
              a *= 0.5;
            }
            return v;
          }
          void main(){
            float heightBias = clamp((vPos.y + 0.9) * 0.2, 0.0, 1.0);
            vec2  uv = vUv * uNoiseScale + uNoiseMove * uTime;
            float n = fbm(uv) * 0.8 + heightBias * 0.2;
            float d = n - uThreshold;
            if (d < 0.0) discard;
            float edge = smoothstep(0.0, uEdgeWidth, d) - smoothstep(uEdgeWidth, uEdgeWidth * 2.0, d);
            vec3 color = mix(uBaseColor, uEdgeColor, edge);
            gl_FragColor = vec4(color, 1.0);
          }
        `
      });
    }

    function dissolveAndAsh(mesh, awayVec, durationSec = 1.0) {
      // –ö–ª–æ–Ω–∏—Ä—É–µ–º –≤–∏–∑—É–∞–ª—å–Ω—ã–π –æ–±—ä–µ–∫—Ç –∏ –∞–Ω–∏–º–∏—Ä—É–µ–º –∫–ª–æ–Ω –≤ effectsGroup, –æ—Ä–∏–≥–∏–Ω–∞–ª —Å–∫—Ä—ã–≤–∞–µ–º
      if (!mesh) return;
      try { mesh.updateWorldMatrix(true, true); } catch {}
      const worldPos = new THREE.Vector3();
      const worldQuat = new THREE.Quaternion();
      const worldScale = new THREE.Vector3();
      try { mesh.getWorldPosition(worldPos); mesh.getWorldQuaternion(worldQuat); mesh.getWorldScale(worldScale); } catch {}
      const ghost = mesh.clone(true);
      ghost.traverse(obj => { if (obj && obj.userData) obj.userData = { ...obj.userData }; });
      ghost.position.copy(worldPos);
      ghost.quaternion.copy(worldQuat);
      ghost.scale.copy(worldScale);
      ghost.renderOrder = (mesh.renderOrder || 1000) + 10;
      try { effectsGroup.add(ghost); } catch { (mesh.parent||scene).add(ghost); }
      try { mesh.visible = false; } catch {}

      // –ü–æ–¥–≥–æ—Ç–æ–≤–∏–º –º–∞—Ç–µ—Ä–∏–∞–ª—ã –Ω–∞ –∫–ª–æ–Ω–µ –∏ —Å–æ–±–µ—Ä—ë–º uniform'—ã
      const dissolveTargets = [];
      ghost.traverse(obj => {
        if (obj && obj.isMesh && obj.material) {
          const materials = Array.isArray(obj.material) ? obj.material : [obj.material];
          const newMats = [];
          for (const m of materials) {
            if (!m) { newMats.push(m); continue; }
            const matClone = m.clone();
            matClone.transparent = true;
            matClone.depthWrite = false;
            matClone.onBeforeCompile = (shader) => {
              shader.uniforms.uTime = { value: 0.0 };
              shader.uniforms.uThreshold = { value: 0.0 };
              shader.uniforms.uEdgeWidth = { value: 0.12 };
              shader.uniforms.uEdgeColor = { value: new THREE.Color(0.55, 0.80, 1.0) };
              shader.uniforms.uBaseColor = { value: new THREE.Color(0.90, 0.95, 1.0) };
              shader.uniforms.uNoiseScale = { value: 3.0 };
              shader.uniforms.uNoiseMove = { value: new THREE.Vector2(0.15, -0.1) };
              shader.vertexShader = shader.vertexShader
                .replace('#include <common>', '#include <common>\n varying vec3 dWorldPos;')
                .replace('#include <project_vertex>', '#include <project_vertex>\n dWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;');
              const header = `
                varying vec3 dWorldPos;
                uniform float uTime; uniform float uThreshold; uniform float uEdgeWidth; uniform vec3 uEdgeColor; uniform float uNoiseScale; uniform vec2 uNoiseMove;
                float dhash(vec2 p){ p = fract(p * vec2(123.34, 345.45)); p += dot(p, p + 34.345); return fract(p.x * p.y); }
                float dnoise(vec2 p){ vec2 i = floor(p); vec2 f = fract(p); float a = dhash(i); float b = dhash(i+vec2(1.0,0.0)); float c = dhash(i+vec2(0.0,1.0)); float d = dhash(i+vec2(1.0,1.0)); vec2 u = f*f*(3.0-2.0*f); return mix(a,b,u.x) + (c-a)*u.y*(1.0-u.x) + (d-b)*u.x*u.y; }
                float dfbm(vec2 p){ float v=0.0; float a=0.5; for (int i=0;i<5;i++){ v+=a*dnoise(p); p*=2.02; a*=0.5; } return v; }
                vec4 applyDissolve(vec4 baseColor){
                  vec2  uv = dWorldPos.xz * uNoiseScale + uNoiseMove * uTime;
                  float heightBias = clamp((dWorldPos.y) * 0.15, 0.0, 1.0);
                  float n = dfbm(uv) * 0.8 + heightBias * 0.2;
                  float d = n - uThreshold; if (d < 0.0) discard;
                  float edge = smoothstep(0.0, uEdgeWidth, d) - smoothstep(uEdgeWidth, uEdgeWidth*2.0, d);
                  vec3 c = mix(baseColor.rgb, uEdgeColor, edge);
                  return vec4(c, baseColor.a);
                }
              `;
              shader.fragmentShader = shader.fragmentShader.replace('#include <common>', '#include <common>\n' + header);
              try { shader.fragmentShader = shader.fragmentShader.replace(/gl_FragColor\s*=\s*([^;]+);/g, 'gl_FragColor = applyDissolve($1);'); } catch(e) {}
              shader.fragmentShader = shader.fragmentShader.replace('#include <dithering_fragment>', '#include <dithering_fragment>\n gl_FragColor = applyDissolve(gl_FragColor);');
              dissolveTargets.push(shader.uniforms);
            };
            matClone.needsUpdate = true;
            newMats.push(matClone);
          }
          obj.material = Array.isArray(obj.material) ? newMats : newMats[0];
        }
      });

      const start = performance.now();
      let rafId = 0; let alive = true;
      (function tick(){
        if (!alive) return;
        const t = (performance.now() - start) / 1000;
        for (const u of dissolveTargets) { if (u && u.uTime) u.uTime.value = t; }
        rafId = requestAnimationFrame(tick);
      })();
      const tl = gsap.timeline({ onComplete: () => {
        alive = false; try { cancelAnimationFrame(rafId); } catch {}
        try { effectsGroup.remove(ghost); } catch {}
      }});
      const dy = 1.2;
      tl.to({}, { duration: 0.0 })
        .to({ th: 0.0 }, {
          th: 1.0, duration: Math.max(0.6, durationSec), ease: 'power1.inOut',
          onUpdate: function(){ const v = this.targets()[0].th; for (const u of dissolveTargets) { if (u && u.uThreshold) u.uThreshold.value = v; } },
        }, 0)
        .to(ghost.position, { y: ghost.position.y + dy, duration: Math.max(0.6, durationSec), ease: 'power1.inOut' }, 0);
    }

    function fadeOutAndFly(mesh, awayVec) {
      awayVec = awayVec || new THREE.Vector3(0, 0, 1);
      const mats = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
      mats.forEach(m => { m.transparent = true; });
      const tl = gsap.timeline();
      tl.to(mesh.rotation, { y: mesh.rotation.y + Math.PI * 0.6, x: mesh.rotation.x - Math.PI * 0.20, duration: 1.5, ease: 'power1.inOut' }, 0)
        .to(mesh.position, { x: mesh.position.x + awayVec.x, y: mesh.position.y + 2.2, z: mesh.position.z + awayVec.z, duration: 1.5, ease: 'power2.in' }, 0)
        .to(mats, { opacity: 0, duration: 1.5 }, 0);
    }
    
    // –ü–ª–∞–≤–Ω–∞—è —à–µ–π–¥–µ—Ä–Ω–∞—è –∑–∞–º–µ–Ω–∞ –º–∞—Ç–µ—Ä–∏–∞–ª–∞ —Ç–∞–π–ª–∞ (–¥–ª—è Fissures)
    function dissolveTileSwap(tileMesh, newMaterial, durationSec = 0.9) {
      if (!tileMesh || !newMaterial) return;
      try {
        const old = tileMesh.material;
        // –û–±—ë—Ä—Ç–∫–∞ –Ω–∞–¥ onBeforeCompile –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ dissolveAndAsh, –Ω–æ –¥–ª—è –ø–ª–æ—Å–∫–æ–≥–æ —Ç–∞–π–ª–∞
        const uniforms = {
          uTime: { value: 0.0 },
          uThreshold: { value: 0.0 },
          uEdgeWidth: { value: 0.10 },
          uEdgeColor: { value: new THREE.Color(0.95, 0.85, 0.4) },
          uNoiseScale: { value: 5.0 },
          uNoiseMove: { value: new THREE.Vector2(0.2, -0.12) }
        };
        const matClone = old.clone();
        matClone.transparent = true; matClone.depthWrite = false;
        matClone.onBeforeCompile = (shader) => {
          shader.uniforms.uTime = uniforms.uTime;
          shader.uniforms.uThreshold = uniforms.uThreshold;
          shader.uniforms.uEdgeWidth = uniforms.uEdgeWidth;
          shader.uniforms.uEdgeColor = uniforms.uEdgeColor;
          shader.uniforms.uNoiseScale = uniforms.uNoiseScale;
          shader.uniforms.uNoiseMove = uniforms.uNoiseMove;
          const header = `
            uniform float uTime; uniform float uThreshold; uniform float uEdgeWidth; uniform vec3 uEdgeColor; uniform float uNoiseScale; uniform vec2 uNoiseMove;
            float hashf(vec2 p){ p = fract(p * vec2(123.34, 345.45)); p += dot(p, p + 34.345); return fract(p.x * p.y); }
            float noisef(vec2 p){ vec2 i=floor(p); vec2 f=fract(p); float a=hashf(i); float b=hashf(i+vec2(1.,0.)); float c=hashf(i+vec2(0.,1.)); float d=hashf(i+vec2(1.,1.)); vec2 u=f*f*(3.-2.*f); return mix(a,b,u.x)+(c-a)*u.y*(1.-u.x)+(d-b)*u.x*u.y; }
            float fbmf(vec2 p){ float v=0., a=0.5; for(int i=0;i<5;i++){ v+=a*noisef(p); p*=2.02; a*=0.5; } return v; }
          `;
          shader.fragmentShader = shader.fragmentShader.replace('#include <common>', '#include <common>\n'+header);
          shader.fragmentShader = shader.fragmentShader.replace('#include <dithering_fragment>', `#include <dithering_fragment>\n{
            vec2 uv = gl_FragCoord.xy * (uNoiseScale/512.0) + uNoiseMove * uTime;
            float n = fbmf(uv);
            float d = n - uThreshold; if (d < 0.0) discard; 
            float edge = smoothstep(0.0, uEdgeWidth, d) - smoothstep(uEdgeWidth, uEdgeWidth*2.0, d);
            gl_FragColor.rgb = mix(gl_FragColor.rgb, uEdgeColor, edge);
          }`);
        };
        tileMesh.material = matClone; tileMesh.material.needsUpdate = true;
        const start = performance.now(); let rafId=0, alive=true;
        (function tick(){ if(!alive) return; const t=(performance.now()-start)/1000; uniforms.uTime.value=t; rafId=requestAnimationFrame(tick); })();
        gsap.to({ th: 0.0 }, { th: 1.0, duration: Math.max(0.5, durationSec), ease: 'power1.inOut', onUpdate: function(){ uniforms.uThreshold.value=this.targets()[0].th; }, onComplete: ()=>{
          alive=false; try{ cancelAnimationFrame(rafId);}catch{}
          // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–æ–≤—ã–π –º–∞—Ç–µ—Ä–∏–∞–ª –ø–æ—Å–ª–µ —Ä–∞—Å—Ç–≤–æ—Ä–µ–Ω–∏—è —Å—Ç–∞—Ä–æ–≥–æ
          try { old.dispose && old.dispose(); } catch {}
          tileMesh.material = newMaterial; tileMesh.material.needsUpdate = true;
        }});
      } catch {
        // –§–æ–ª–ª–±–µ–∫: –º–≥–Ω–æ–≤–µ–Ω–Ω–∞—è –∑–∞–º–µ–Ω–∞
        tileMesh.material = newMaterial; tileMesh.material.needsUpdate = true;
      }
    }
    // –ö—Ä–æ—Å—Å—Ñ–µ–π–¥ –º–µ–∂–¥—É —Å—Ç–∞—Ä—ã–º –∏ –Ω–æ–≤—ã–º –º–∞—Ç–µ—Ä–∏–∞–ª–æ–º: —Å—Ç–∞—Ä–∞—è —Ç–µ–∫—Å—Ç—É—Ä–∞ –ø–ª–∞–≤–Ω–æ —Ä–∞—Å—Ç–≤–æ—Ä—è–µ—Ç—Å—è, –Ω–æ–≤–∞—è –ø—Ä–æ—è–≤–ª—è–µ—Ç—Å—è
    function dissolveTileCrossfade(tileMesh, oldMaterial, newMaterial, durationSec = 0.9) {
      try {
        if (!tileMesh || !oldMaterial || !newMaterial) return dissolveTileSwap(tileMesh, newMaterial, durationSec);
        const geom = tileMesh.geometry;
        const group = new THREE.Group();
        group.position.copy(tileMesh.position);
        group.rotation.copy(tileMesh.rotation);
        group.scale.copy(tileMesh.scale);
        const oldMesh = new THREE.Mesh(geom.clone(), oldMaterial.clone());
        const newMesh = new THREE.Mesh(geom.clone(), newMaterial.clone());
        (boardGroup || scene).add(group);
        group.add(oldMesh); group.add(newMesh);
        // –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏
        oldMesh.material.transparent = true; newMesh.material.transparent = true;
        oldMesh.material.depthWrite = false; newMesh.material.depthWrite = false;
        oldMesh.material.opacity = 1.0; newMesh.material.opacity = 0.0;
        // –∑–∞–ø—É—Å—Ç–∏—Ç—å –∞–Ω–∏–º–∞—Ü–∏—é
        const tl = gsap.timeline({ onComplete: () => {
          try { tileMesh.material = newMaterial; tileMesh.material.needsUpdate = true; } catch {}
          try { (boardGroup || scene).remove(group); } catch {}
        }});
        tl.to(oldMesh.material, { opacity: 0.0, duration: Math.max(0.4, durationSec), ease: 'power1.inOut' }, 0)
          .to(newMesh.material, { opacity: 1.0, duration: Math.max(0.4, durationSec), ease: 'power1.inOut' }, 0);
      } catch {
        dissolveTileSwap(tileMesh, newMaterial, durationSec);
      }
    }

    function performMagicAttack(from, targetMesh) {
      const tr = targetMesh.userData.row; const tc = targetMesh.userData.col;
      const res = magicAttack(gameState, from.r, from.c, tr, tc);
      if (!res) { showNotification('–¶–µ–ª—å –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞', 'error'); return; }
      // –ù–µ –æ–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ, —á—Ç–æ–±—ã –¥–∞—Ç—å –ø—Ä–æ–π—Ç–∏ –∞–Ω–∏–º–∞—Ü–∏–∏ —Å–º–µ—Ä—Ç–∏
      for (const l of res.logLines.reverse()) addLog(l);
      const aMesh = unitMeshes.find(m => m.userData.row === from.r && m.userData.col === from.c);
      if (aMesh) { gsap.fromTo(aMesh.position, { y: aMesh.position.y }, { y: aMesh.position.y + 0.3, yoyo: true, repeat: 1, duration: 0.12 }); }
      // –≤—Å–ø—ã—à–∫–∞ –ø–æ —Ü–µ–ª–∏
      const tMesh = unitMeshes.find(m => m.userData.row === tr && m.userData.col === tc);
      if (tMesh) {
        const flashGeom = new THREE.SphereGeometry(0.25, 12, 12);
        const flashMat = new THREE.MeshBasicMaterial({ color: 0xff6666, transparent: true, opacity: 0.8 });
        const flash = new THREE.Mesh(flashGeom, flashMat);
        flash.position.copy(tMesh.position).add(new THREE.Vector3(0, 0.4, 0));
        effectsGroup.add(flash);
        gsap.to(flash.scale, { x: 2, y: 2, z: 2, duration: 0.3 });
        gsap.to(flash.material, { opacity: 0, duration: 0.3, onComplete: ()=> effectsGroup.remove(flash) });
        // —Ç—Ä—è—Å–∫–∞ —Ü–µ–ª–∏ –∏ –≤—Å–ø–ª—ã–≤–∞—é—â–∏–π —É—Ä–æ–Ω –¥–ª—è –º–∞–≥–∏–∏
        shakeMesh(tMesh, 6, 0.12);
        if (typeof res.dmg === 'number' && res.dmg > 0) {
          spawnDamageText(tMesh, `-${res.dmg}`, '#ff5555');
        }
      }
      // –ú–∞–Ω–∞—Å—Ñ–µ—Ä–∞ –∏ –∫–ª–∞–¥–±–∏—â–µ –¥–ª—è –ø–æ–≥–∏–±—à–∏—Ö –æ—Ç –º–∞–≥–∏–∏; –æ—Ç–∫–ª–∞–¥—ã–≤–∞–µ–º –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∫—É –¥–æ –∫–æ–Ω—Ü–∞ –¥–∏–∑–æ–ª–≤–∞
      if (res.deaths && res.deaths.length) {
        for (const d of res.deaths) {
          try { gameState.players[d.owner].graveyard.push(CARDS[d.tplId]); } catch {}
          const deadMesh = unitMeshes.find(m => m.userData.row === d.r && m.userData.col === d.c);
          if (deadMesh) { dissolveAndAsh(deadMesh, new THREE.Vector3(0, 0, 0.6), 0.9); }
          const p = tileMeshes[d.r][d.c].position.clone().add(new THREE.Vector3(0, 1.2, 0));
          // –ù–∞—á–∏—Å–ª—è–µ–º –≤–ª–∞–¥–µ–ª—å—Ü—É –ø–æ–≥–∏–±—à–µ–≥–æ —Å—É—â–µ—Å—Ç–≤–∞ +1 –º–∞–Ω—É (–æ–Ω–ª–∞–π–Ω/–æ—Ñ–ª–∞–π–Ω –æ–¥–∏–Ω–∞–∫–æ–≤–æ)
          try { if (gameState && gameState.players) { gameState.players[d.owner].mana = capMana((gameState.players[d.owner].mana || 0) + 1); } } catch {}
          animateManaGainFromWorld(p, d.owner);
        }
        setTimeout(() => {
          gameState = res.n1; updateUnits(); updateUI();
          const attacker = gameState.board[from.r][from.c] && gameState.board[from.r][from.c].unit; if (attacker) attacker.lastAttackTurn = gameState.turn;
          try { schedulePush('magic-battle-finish'); } catch {}
        }, 1000);
      } else {
        // –ï—Å–ª–∏ —Å–º–µ—Ä—Ç–µ–π –Ω–µ—Ç ‚Äî –ø—Ä–∏–º–µ–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å—Ä–∞–∑—É
        gameState = res.n1; updateUnits(); updateUI();
        const attacker = gameState.board[from.r][from.c] && gameState.board[from.r][from.c].unit; if (attacker) attacker.lastAttackTurn = gameState.turn;
        try { schedulePush('magic-battle-finish'); } catch {}
      }
    }
    // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —É—Ç–∏–ª–∏—Ç—ã: –∑–∞–¥–µ—Ä–∂–∫–∞ –∏ —è—Ä–∫–∞—è –∑–∞—Å—Ç–∞–≤–∫–∞ BATTLE –Ω–∞ 3 —Å–µ–∫—É–Ω–¥—ã
    function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
    async function showBattleSplash() {
      splashActive = true; refreshInputLockUI();
      const bb = document.getElementById('battle-banner');
      if (!bb) { splashActive = false; refreshInputLockUI(); return; }
      bb.innerHTML = '';
      const wrap = document.createElement('div'); wrap.className = 'ts-wrap';
      const bg = document.createElement('div'); bg.className = 'ts-bg'; wrap.appendChild(bg);
      const ringOuter = document.createElement('div'); ringOuter.className = 'ts-ring thin'; wrap.appendChild(ringOuter);
      const ringInner = document.createElement('div'); ringInner.className = 'ts-ring'; wrap.appendChild(ringInner);
      const streaks = document.createElement('div'); streaks.className = 'ts-streaks'; wrap.appendChild(streaks);
      const txt = document.createElement('div'); txt.className = 'ts-title ts-title-solid text-6xl md:text-8xl'; txt.textContent = 'BATTLE'; wrap.appendChild(txt);
      const scan = document.createElement('div'); scan.className = 'ts-scan'; wrap.appendChild(scan);
      bb.appendChild(wrap);
      bb.style.display = 'flex'; bb.classList.remove('hidden'); bb.classList.add('flex');
      const tl = gsap.timeline();
      tl.set(txt, { scale: 0.65, opacity: 0 })
        .set(ringOuter, { scale: 0.8, opacity: 0 })
        .set(ringInner, { scale: 0.5, opacity: 0 })
        .fromTo(bg, { opacity: 0 }, { opacity: 0.6, duration: 0.126, ease: 'power2.out' }, 0)
        .to(ringOuter, { opacity: 1, scale: 1.0, duration: 0.196, ease: 'back.out(2.2)' }, 0.014)
        .to(ringInner, { opacity: 1, scale: 1.0, duration: 0.224, ease: 'back.out(2.2)' }, 0.042)
        .to(txt, { opacity: 1, scale: 1.08, duration: 0.252, ease: 'back.out(1.9)' }, 0.056)
        .to(txt, { scale: 1.0, duration: 0.154, ease: 'power2.out' })
        .to(scan, { yPercent: 200, duration: 0.49, ease: 'power1.inOut' }, 0.084)
        .to(streaks, { opacity: 0.25, duration: 0.35 }, 0.14)
        .to([ringOuter, ringInner], { opacity: 0.9, duration: 0.14 }, 0.315)
        .to([bg, streaks], { opacity: 0.12, duration: 0.266 }, 0.406)
        .to([txt, ringOuter, ringInner], { opacity: 0, duration: 0.196, ease: 'power2.in' }, 1.134)
        .to(bb, { opacity: 0, duration: 0.14, ease: 'power2.in' }, 1.19);
      await sleep(1330);
      bb.classList.add('hidden'); bb.classList.remove('flex'); bb.style.display = 'none';
      bb.style.opacity = '';
      bb.innerHTML = '';
      splashActive = false; refreshInputLockUI();
    }

    async function showTurnSplash(title) {
      splashActive = true; refreshInputLockUI();
      const tb = document.getElementById('turn-banner');
      if (!tb) { splashActive = false; refreshInputLockUI(); return; }
      tb.innerHTML = '';
      // –†–∞–∑–º–µ—Ç–∫–∞ –Ω–æ–≤–æ–≥–æ —ç–∫—Ä–∞–Ω–∞
      const wrap = document.createElement('div'); wrap.className = 'ts-wrap';
      const bg = document.createElement('div'); bg.className = 'ts-bg'; wrap.appendChild(bg);
      const ringOuter = document.createElement('div'); ringOuter.className = 'ts-ring thin'; wrap.appendChild(ringOuter);
      const ringInner = document.createElement('div'); ringInner.className = 'ts-ring'; wrap.appendChild(ringInner);
      const streaks = document.createElement('div'); streaks.className = 'ts-streaks'; wrap.appendChild(streaks);
      const txt = document.createElement('div'); txt.className = 'ts-title ts-title-solid text-4xl md:text-6xl'; txt.textContent = title; wrap.appendChild(txt);
      const scan = document.createElement('div'); scan.className = 'ts-scan'; wrap.appendChild(scan);
      tb.appendChild(wrap);
      tb.style.display = 'flex'; tb.classList.remove('hidden'); tb.classList.add('flex');
      // –ê–Ω–∏–º–∞—Ü–∏–∏ (—É—Å–∫–æ—Ä–µ–Ω—ã –Ω–∞ 30%)
      const tl = gsap.timeline();
      tl.set(txt, { scale: 0.65, opacity: 0 })
        .set(ringOuter, { scale: 0.8, opacity: 0 })
        .set(ringInner, { scale: 0.5, opacity: 0 })
        .fromTo(bg, { opacity: 0 }, { opacity: 0.6, duration: 0.126, ease: 'power2.out' }, 0)
        .to(ringOuter, { opacity: 1, scale: 1.0, duration: 0.196, ease: 'back.out(2.2)' }, 0.014)
        .to(ringInner, { opacity: 1, scale: 1.0, duration: 0.224, ease: 'back.out(2.2)' }, 0.042)
        .to(txt, { opacity: 1, scale: 1.08, duration: 0.252, ease: 'back.out(1.9)' }, 0.056)
        .to(txt, { scale: 1.0, duration: 0.154, ease: 'power2.out' })
        .to(scan, { yPercent: 200, duration: 0.49, ease: 'power1.inOut' }, 0.084)
        .to(streaks, { opacity: 0.25, duration: 0.35 }, 0.14)
        .to([ringOuter, ringInner], { opacity: 0.9, duration: 0.14 }, 0.315)
        .to([bg, streaks], { opacity: 0.12, duration: 0.266 }, 0.406)
        .to([txt, ringOuter, ringInner], { opacity: 0, duration: 0.196, ease: 'power2.in' }, 1.134)
        .to(tb, { opacity: 0, duration: 0.14, ease: 'power2.in' }, 1.19);
      await sleep(1330);
      tb.classList.add('hidden'); tb.classList.remove('flex'); tb.style.display = 'none';
      tb.style.opacity = '';
      tb.innerHTML = '';
      splashActive = false; refreshInputLockUI();
      try {
        lastSplashTurnShown = (gameState?.turn || lastSplashTurnShown);
      } catch {}
    }
    
    function castSpellOnUnit(cardMesh, unitMesh) {
      const idx = cardMesh.userData.handIndex;
      const pl = gameState.players[gameState.active];
      if (idx == null || idx < 0 || idx >= pl.hand.length) { resetCardSelection(); return; }
      const tpl = pl.hand[idx]; if (!tpl || tpl.type !== 'SPELL') { resetCardSelection(); return; }
      if (tpl.cost > pl.mana) { showNotification('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–∞–Ω—ã', 'error'); resetCardSelection(); return; }
      const r = unitMesh.userData.row; const c = unitMesh.userData.col; const u = gameState.board[r][c].unit;
      let delayedApply = false;
      // –ù–æ–≤—ã–µ —Å–ø–µ–ª–ª—ã
      if (tpl.id === 'SPELL_BEGUILING_FOG') {
        // –†–∞–∑—Ä–µ—à–∞–µ–º –ø–æ–≤–æ—Ä–æ—Ç –ª—é–±–æ–π —Ü–µ–ª–∏ –≤ –ª—é–±—É—é —Å—Ç–æ—Ä–æ–Ω—É ‚Äî —Å–ø—Ä–æ—Å–∏–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ –ø–∞–Ω–µ–ª—å –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏
        pendingSpellOrientation = { spellCardMesh: cardMesh, unitMesh };
        addLog(`${tpl.name}: –≤—ã–±–µ—Ä–∏—Ç–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–ª—è —Ü–µ–ª–∏.`);
        // –í—Ä–µ–º–µ–Ω–Ω–æ –ø–æ–∫–∞–∂–µ–º –ø–∞–Ω–µ–ª—å –∏ –ø–µ—Ä–µ—Ö–≤–∞—Ç–∏–º –µ—ë –∫–ª–∏–∫–∏ (—Å–º. –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∏–∂–µ)
        showOrientationPanel();
        return; // –∑–∞–≤–µ—Ä—à–∏–º, –æ—Å—Ç–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –≤—ã–ø–æ–ª–Ω–∏—Ç—Å—è –ø–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
      }
      if (tpl.id === 'SPELL_CLARE_WILS_BANNER') {
        if (!u || u.owner !== gameState.active) { showNotification('–¶–µ–ª—å: —Ç–æ–ª—å–∫–æ –¥—Ä—É–∂–µ—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å—É—â–µ—Å—Ç–≤–æ', 'error'); return; }
        // –ü—Ä–∏–º–µ–Ω—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π –±–∞—Ñ –∞—Ç–∞–∫–∏ –¥–æ –∫–æ–Ω—Ü–∞ —Ö–æ–¥–∞ –∫–∞—Å—Ç–µ—Ä–∞
        u.tempAtkBuff = (u.tempAtkBuff || 0) + 2;
        u.tempBuffOwner = gameState.active;
        addLog(`${tpl.name}: ${CARDS[u.tplId].name} –ø–æ–ª—É—á–∞–µ—Ç +2 ATK –¥–æ –∫–æ–Ω—Ü–∞ —Ö–æ–¥–∞.`);
        const tMesh = unitMeshes.find(m => m.userData.row === r && m.userData.col === c);
        if (tMesh) {
          spawnDamageText(tMesh, `+2`, '#22c55e');
          // –®–µ–π–¥–µ—Ä–Ω–∞—è –≤—Å–ø—ã—à–∫–∞ –≤–æ–∫—Ä—É–≥ —Ü–µ–ª–∏
          try {
            const ring = new THREE.Mesh(new THREE.RingGeometry(0.5, 0.8, 48), new THREE.MeshBasicMaterial({ color: 0x22c55e, transparent: true, opacity: 0.0 }));
            ring.rotation.x = -Math.PI/2; ring.position.copy(tMesh.position).add(new THREE.Vector3(0, 0.32, 0));
            effectsGroup.add(ring);
            gsap.to(ring.material, { opacity: 0.8, duration: 0.12 })
              .then(() => gsap.to(ring.scale, { x: 2.5, y: 2.5, z: 2.5, duration: 0.4, ease: 'power2.out' }))
              .then(() => gsap.to(ring.material, { opacity: 0, duration: 0.24, onComplete: ()=> effectsGroup.remove(ring) }));
          } catch {}
        }
        pl.mana -= tpl.cost; pl.discard.push(tpl); pl.hand.splice(idx, 1);
        resetCardSelection(); updateHand(); updateUnits(); updateUI();
        return;
      }
      if (tpl.id === 'SPELL_SUMMONER_MESMERS_ERRAND') {
        // –î–æ–±–æ—Ä –¥–≤—É—Ö –∫–∞—Ä—Ç —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π –∞–Ω–∏–º–∞—Ü–∏–µ–π
        if (tpl.cost > pl.mana) { showNotification('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–∞–Ω—ã', 'error'); resetCardSelection(); return; }
        pl.mana -= tpl.cost;
        (async () => {
          for (let i = 0; i < 2; i++) {
            const drawnTpl = drawOneNoAdd(gameState, gameState.active);
            if (drawnTpl) {
              refreshInputLockUI();
              await animateDrawnCardToHand(drawnTpl);
              try { gameState.players[gameState.active].hand.push(drawnTpl); } catch {}
              updateHand();
            }
          }
          addLog(`${tpl.name}: –≤—ã –¥–æ–±–∏—Ä–∞–µ—Ç–µ 2 –∫–∞—Ä—Ç—ã.`);
          pl.discard.push(tpl); pl.hand.splice(idx, 1); updateUI();
        })();
        resetCardSelection();
        return;
      }
      if (tpl.id === 'SPELL_GOGHLIE_ALTAR') {
        // –û–±–∞ –∏–≥—Ä–æ–∫–∞ –ø–æ–ª—É—á–∞—é—Ç –º–∞–Ω—É = —á–∏—Å–ª—É –≤—Ä–∞–∂–µ—Å–∫–∏—Ö —Å—É—â–µ—Å—Ç–≤ –Ω–∞ –¥–æ—Å–∫–µ
        const countUnits = (ownerIdx) => {
          let n = 0; for (let rr = 0; rr < 3; rr++) for (let cc = 0; cc < 3; cc++) {
            const un = gameState.board[rr][cc].unit; if (un && un.owner !== ownerIdx) n++;
          } return n;
        };
        const g0 = countUnits(0), g1 = countUnits(1);
        gameState.players[0].mana = capMana(gameState.players[0].mana + g0);
        gameState.players[1].mana = capMana(gameState.players[1].mana + g1);
        // –í–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç: –≤—Å–ø—ã—à–∫–∏ —ç–Ω–µ—Ä–≥–∏–∏ –æ—Ç –≤—Å–µ—Ö –≤—Ä–∞–∂–µ—Å–∫–∏—Ö —é–Ω–∏—Ç–æ–≤ –∫ –ø–∞–Ω–µ–ª–∏ –º–∞–Ω—ã –ø–æ–ª—É—á–∞—Ç–µ–ª—è
        for (let rr = 0; rr < 3; rr++) for (let cc = 0; cc < 3; cc++) {
          const un = gameState.board[rr][cc].unit; if (!un) continue;
          const pos = tileMeshes[rr][cc].position.clone().add(new THREE.Vector3(0, 1.2, 0));
          animateManaGainFromWorld(pos, (un.owner === 0 ? 1 : 0));
        }
        addLog(`${tpl.name}: –æ–±–∞ –∏–≥—Ä–æ–∫–∞ –ø–æ–ª—É—á–∞—é—Ç –º–∞–Ω—É –æ—Ç –≤—Ä–∞–∂–µ—Å–∫–∏—Ö —Å—É—â–µ—Å—Ç–≤ (P1 +${g0}, P2 +${g1}).`);
        pl.mana -= tpl.cost; pl.discard.push(tpl); pl.hand.splice(idx, 1);
        resetCardSelection(); updateHand(); updateUI();
        return;
      }
      if (tpl.id === 'SPELL_PARMTETIC_HOLY_FEAST') {
        // –†–∏—Ç—É–∞–ª: —Ç—Ä–µ–±—É–µ—Ç—Å—è —Å–±—Ä–æ—Å–∏—Ç—å —Å—É—â–µ—Å—Ç–≤–æ –∏–∑ —Ä—É–∫–∏ -> –ø—Ä–∏–º–µ–Ω–∏—Ç—å –∞–Ω–∏–º–∞—Ü–∏—é dissolve –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–π –∫–∞—Ä—Ç—ã –∏–∑ —Ä—É–∫–∏
        const handCreatures = pl.hand.filter(x => x && x.type === 'UNIT');
        if (handCreatures.length === 0) { showNotification('–ù–µ—Ç —Å—É—â–µ—Å—Ç–≤ –≤ —Ä—É–∫–µ –¥–ª—è —Ä–∏—Ç—É–∞–ª–∞', 'error'); return; }
        pendingDiscardSelection = {
          requiredType: 'UNIT',
          onPicked: (handIdx) => {
            const toDiscardTpl = pl.hand[handIdx]; if (!toDiscardTpl) return;
            // –ü–æ–¥–Ω–∏–º–µ–º 3D-–∫–∞—Ä—Ç—É –∏–∑ —Ä—É–∫–∏ –∏ –ø—Ä–æ–∂–∂—ë–º –µ—ë —á–µ—Ä–µ–∑ dissolve
            const handMesh = handCardMeshes.find(m => m.userData?.handIndex === handIdx);
            if (handMesh) {
              // –°–Ω–∏–º–µ–º –∏–∑ —Ä—É–∫–∏ –≤–∏–∑—É–∞–ª—å–Ω–æ –ø–µ—Ä–µ–¥ –∞–Ω–∏–º–∞—Ü–∏–µ–π
              try { handMesh.userData.isInHand = false; } catch {}
              dissolveAndAsh(handMesh, new THREE.Vector3(0, 0.6, 0), 0.9);
            }
            // –°–æ—Å—Ç–æ—è–Ω–∏–µ: –ø–µ—Ä–µ–Ω–æ—Å–∏–º –∫–∞—Ä—Ç—É –≤ graveyard –∏ —É–¥–∞–ª—è–µ–º –∏–∑ —Ä—É–∫–∏
            try { pl.graveyard.push(toDiscardTpl); } catch {}
            pl.hand.splice(handIdx, 1);
            updateHand();
            // –í–æ–∑–Ω–∞–≥—Ä–∞–∂–¥–µ–Ω–∏–µ —Ä–∏—Ç—É–∞–ª–∞: +2 –º–∞–Ω—ã
            const beforeM = pl.mana; pl.mana = capMana(pl.mana + 2); updateUI();
            addLog(`${tpl.name}: —Å–±—Ä–∞—Å—ã–≤–∞–µ—Ç–µ —Å—É—â–µ—Å—Ç–≤–æ –∏–∑ —Ä—É–∫–∏ –∏ –ø–æ–ª—É—á–∞–µ—Ç–µ +2 –º–∞–Ω—ã (\`${toDiscardTpl.name}\`).`);
            // –°–ø–∏—Å–∞—Ç—å —Å—Ç–æ–∏–º–æ—Å—Ç—å —Å–ø–µ–ª–ª–∞ (–µ—Å–ª–∏ –±—É–¥–µ—Ç >0 –≤ –±—É–¥—É—â–µ–º) –∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–∞–º —Å–ø–µ–ª–ª –≤ discard
            pl.mana = capMana(pl.mana - (tpl.cost || 0));
            // –£–¥–∞–ª—è–µ–º –ò–ú–ï–ù–ù–û —Ä–∞–∑—ã–≥—Ä–∞–Ω–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä —Å–ø–µ–ª–ª–∞, —Å —É—á—ë—Ç–æ–º —Å–¥–≤–∏–≥–æ–≤ –∏–Ω–¥–µ–∫—Å–æ–≤
            const spellIdx = pl.hand.indexOf(tpl);
            if (spellIdx >= 0) { pl.hand.splice(spellIdx, 1); }
            pl.discard.push(tpl);
            resetCardSelection(); updateHand(); updateUI();
            try { schedulePush('spell-holy-feast', { force: true }); } catch {}
          }
        };
        addLog(`${tpl.name}: –≤—ã–±–µ—Ä–∏—Ç–µ —Å—É—â–µ—Å—Ç–≤–æ –≤ —Ä—É–∫–µ –¥–ª—è —Ä–∏—Ç—É–∞–ª—å–Ω–æ–≥–æ —Å–±—Ä–æ—Å–∞.`);
        // –ü–æ–¥—Å–≤–µ—Ç–∏—Ç—å —Ä—É–∫—É –Ω–µ –±—É–¥–µ–º ‚Äî –≤—ã–±–æ—Ä –ø–æ –∫–ª–∏–∫—É –Ω–∞ –∫–∞—Ä—Ç–µ –∏–∑ —Ä—É–∫–∏ (—Å–º. –ø–µ—Ä–µ—Ö–≤–∞—Ç –≤ onMouseDown)
        return;
      }
      if (tpl.id === 'WIND_SHIFT') { if (u) u.facing = turnCW[u.facing]; addLog(`${tpl.name}: ${CARDS[u.tplId].name} –ø–æ–≤—ë—Ä–Ω—É—Ç.`); }
      if (tpl.id === 'FREEZE_STREAM') {
        if (u) {
          const before = u.currentHP; u.currentHP = Math.max(0, u.currentHP - 1);
          addLog(`${tpl.name}: ${CARDS[u.tplId].name} –ø–æ–ª—É—á–∞–µ—Ç 1 —É—Ä–æ–Ω–∞ (HP ${before}‚Üí${u.currentHP})`);
          try { const tMesh = unitMeshes.find(m => m.userData.row === r && m.userData.col === c); if (tMesh) spawnDamageText(tMesh, `-1`, '#ef4444'); } catch {}
          if (u.currentHP <= 0) {
            delayedApply = true;
            const owner = u.owner;
            try { gameState.players[owner].graveyard.push(CARDS[u.tplId]); } catch {}
            const pos = tileMeshes[r][c].position.clone().add(new THREE.Vector3(0,1.2,0));
            animateManaGainFromWorld(pos, owner);
            // –ó–∞–ø—É—Å–∫–∞–µ–º –¥–∏–∑–æ–ª–≤ –Ω–∞ —Ç–µ–∫—É—â–µ–º –º–µ—à–µ —Ü–µ–ª–∏
            if (unitMesh) { dissolveAndAsh(unitMesh, new THREE.Vector3(0,0,0.6), 0.9); }
            // –û—Ç–ª–æ–∂–∏–º —É–¥–∞–ª–µ–Ω–∏–µ –∏–∑ –¥–æ—Å–∫–∏ –¥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∞–Ω–∏–º–∞—Ü–∏–∏
            setTimeout(() => { gameState.board[r][c].unit = null; updateUnits(); updateUI(); }, 1000);
          }
        }
      }
      if (tpl.id === 'RAISE_STONE') {
        if (!u) { showNotification('–ù—É–∂–Ω–æ –ø–µ—Ä–µ—Ç–∞—â–∏—Ç—å –Ω–∞ —Å—É—â–µ—Å—Ç–≤–æ', 'error'); return; }
        if (u.owner !== gameState.active) { showNotification('–¢–æ–ª—å–∫–æ —Å–æ—é–∑–Ω–æ–µ —Å—É—â–µ—Å—Ç–≤–æ', 'error'); return; }
        const before = u.currentHP; u.currentHP += 2; addLog(`${tpl.name}: ${CARDS[u.tplId].name} –ø–æ–ª—É—á–∞–µ—Ç +2 HP (HP ${before}‚Üí${u.currentHP})`);
        try { const tMesh = unitMeshes.find(m => m.userData.row === r && m.userData.col === c); if (tMesh) spawnDamageText(tMesh, `+2`, '#22c55e'); } catch {}
      }
      pl.mana -= tpl.cost; pl.discard.push(tpl); pl.hand.splice(idx, 1);
      resetCardSelection(); updateHand();
      if (!delayedApply) { updateUnits(); updateUI(); }
    }

    // –ù–æ–≤—ã–π —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–∞—Å—Ç–∞ —Å–ø–µ–ª–ª–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–∏
    function castSpellByDrag(cardMesh, unitMesh, tileMesh) {
      const idx = cardMesh.userData.handIndex;
      const pl = gameState.players[gameState.active];
      if (idx == null || idx < 0 || idx >= pl.hand.length) { return; }
      const tpl = pl.hand[idx]; if (!tpl || tpl.type !== 'SPELL') { return; }
      if (tpl.cost > pl.mana) { showNotification('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–∞–Ω—ã', 'error'); return; }
      // –î–ª—è —Å–ø–µ–ª–ª–æ–≤ –±–µ–∑ —Ü–µ–ª–∏ ‚Äî –ø–æ–∑–≤–æ–ª—è–µ–º –¥—Ä–æ–ø –Ω–∞ –ª—é–±—É—é –∫–ª–µ—Ç–∫—É –ø–æ–ª—è
      const id = tpl.id;
      const requiresUnitTarget = (/*'FREEZE_STREAM' removed*/ id === 'RAISE_STONE' || /*'WIND_SHIFT' removed*/ id === 'SPELL_BEGUILING_FOG' || id === 'SPELL_CLARE_WILS_BANNER');
      if (requiresUnitTarget) {
        if (!unitMesh) { showNotification('–ù—É–∂–Ω–æ –ø–µ—Ä–µ—Ç–∞—â–∏—Ç—å –Ω–∞ —Å—É—â–µ—Å—Ç–≤–æ', 'error'); return; }
        // –°–ø–µ—Ü—ç—Ñ—Ñ–µ–∫—Ç –±–∞—Ñ—Ñ–∞/–¥–µ–±–∞—Ñ—Ñ–∞ –ø–µ—Ä–µ–¥ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ–º
        try {
          const glow = new THREE.Mesh(new THREE.RingGeometry(0.4, 0.6, 32), new THREE.MeshBasicMaterial({ color: 0x22c55e, transparent: true, opacity: 0.0 }));
          glow.rotation.x = -Math.PI/2; glow.position.copy(unitMesh.position).add(new THREE.Vector3(0, 0.3, 0));
          effectsGroup.add(glow);
          gsap.to(glow.material, { opacity: 0.8, duration: 0.12 })
            .then(() => gsap.to(glow.scale, { x: 2.2, y: 2.2, z: 2.2, duration: 0.35, ease: 'power1.out' }))
            .then(() => gsap.to(glow.material, { opacity: 0, duration: 0.28, onComplete: ()=> effectsGroup.remove(glow) }));
        } catch {}
        return castSpellOnUnit(cardMesh, unitMesh);
      }
      // –°–ø–µ–ª–ª—ã –±–µ–∑ —Ü–µ–ª–∏
      if (id === 'SPELL_SUMMONER_MESMERS_ERRAND') {
        // –î–æ–±–æ—Ä –¥–≤—É—Ö –∫–∞—Ä—Ç
        if (tpl.cost > pl.mana) { showNotification('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–∞–Ω—ã', 'error'); return; }
        pl.mana -= tpl.cost;
        // –ù–µ–º–µ–¥–ª–µ–Ω–Ω–æ ¬´—Å–æ–∂–∂—ë–º¬ª –∫–∞—Ä—Ç—É —Å–ø–µ–ª–ª–∞ –Ω–∞ –º–µ—Å—Ç–µ –±—Ä–æ—Å–∫–∞ –∏ –ø–æ–º–µ—Ç–∏–º, —á—Ç–æ –∫–∞—Ä—Ç—É –Ω–µ –Ω–∞–¥–æ –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å –≤ —Ä—É–∫—É
        try {
          const big = createCard3D(tpl, false);
          const p = tileMesh ? tileMesh.position.clone().add(new THREE.Vector3(0, 1.0, 0)) : new THREE.Vector3(0, 1.0, 0);
          big.position.copy(p);
          (boardGroup || scene).add(big);
          dissolveAndAsh(big, new THREE.Vector3(0, 0.6, 0), 0.9);
          spellDragHandled = true;
          // –°–∫—Ä—ã—Ç—å –ø–µ—Ä–µ—Ç—è–≥–∏–≤–∞–µ–º—É—é –∫–∞—Ä—Ç—É, —á—Ç–æ–±—ã –Ω–µ –º–∏–≥–∞–ª–∞
          try { cardMesh.visible = false; } catch {}
        } catch {}
        // –£–¥–∞–ª–∏—Ç—å –∏–∑ —Ä—É–∫–∏ –∏ –ø–æ–ª–æ–∂–∏—Ç—å –≤ —Å–±—Ä–æ—Å —Å—Ä–∞–∑—É, –∑–∞—Ç–µ–º –∞–Ω–∏–º–∏—Ä–æ–≤–∞—Ç—å –¥–æ–±–æ—Ä 2 –∫–∞—Ä—Ç
        pl.hand.splice(idx, 1); pl.discard.push(tpl); updateHand(); updateUI();
        (async () => {
          for (let i = 0; i < 2; i++) {
            const drawnTpl = drawOneNoAdd(gameState, gameState.active);
            if (drawnTpl) {
              refreshInputLockUI();
              await animateDrawnCardToHand(drawnTpl);
              try { gameState.players[gameState.active].hand.push(drawnTpl); } catch {}
              updateHand();
            }
          }
          addLog(`${tpl.name}: –≤—ã –¥–æ–±–∏—Ä–∞–µ—Ç–µ 2 –∫–∞—Ä—Ç—ã.`);
        })();
        return;
      }
      if (id === 'SPELL_GOGHLIE_ALTAR') {
        const countUnits = (ownerIdx) => { let n = 0; for (let rr = 0; rr < 3; rr++) for (let cc = 0; cc < 3; cc++) { const un = gameState.board[rr][cc].unit; if (un && un.owner !== ownerIdx) n++; } return n; };
        const g0 = countUnits(0), g1 = countUnits(1);
        gameState.players[0].mana = capMana(gameState.players[0].mana + g0);
        gameState.players[1].mana = capMana(gameState.players[1].mana + g1);
        for (let rr = 0; rr < 3; rr++) for (let cc = 0; cc < 3; cc++) { const un = gameState.board[rr][cc].unit; if (!un) continue; const pos = tileMeshes[rr][cc].position.clone().add(new THREE.Vector3(0, 1.2, 0)); animateManaGainFromWorld(pos, (un.owner === 0 ? 1 : 0)); }
        addLog(`${tpl.name}: –æ–±–∞ –∏–≥—Ä–æ–∫–∞ –ø–æ–ª—É—á–∞—é—Ç –º–∞–Ω—É –æ—Ç –≤—Ä–∞–∂–µ—Å–∫–∏—Ö —Å—É—â–µ—Å—Ç–≤ (P1 +${g0}, P2 +${g1}).`);
        // –í–∏–∑—É–∞–ª—å–Ω–æ —Å–æ–∂–∂—ë–º –∫–∞—Ä—Ç—É —Å–ø–µ–ª–ª–∞ –≤ —Ç–æ—á–∫–µ –¥—Ä–æ–ø–∞
        try {
          const big = createCard3D(tpl, false);
          const p = tileMesh ? tileMesh.position.clone().add(new THREE.Vector3(0, 1.0, 0)) : new THREE.Vector3(0, 1.0, 0);
          big.position.copy(p);
          (boardGroup || scene).add(big);
          dissolveAndAsh(big, new THREE.Vector3(0, 0.6, 0), 0.9);
          spellDragHandled = true;
        } catch {}
        pl.mana -= tpl.cost; pl.discard.push(tpl); pl.hand.splice(idx, 1);
        updateHand(); updateUI();
        return;
      }
      if (id === 'SPELL_FISSURES_OF_GOGHLIE') {
        if (!tileMesh) { showNotification('–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –Ω–∞ –∫–ª–µ—Ç–∫—É –ø–æ–ª—è', 'error'); return; }
        const r = tileMesh.userData.row, c = tileMesh.userData.col;
        const cell = gameState.board[r][c];
        if (!cell) return;
        if (cell.element === 'MECH') { showNotification('Mech –ø–æ–ª–µ –Ω–µ –º–µ–Ω—è–µ—Ç—Å—è', 'error'); return; }
        const oppMap = { FIRE:'WATER', WATER:'FIRE', EARTH:'FOREST', FOREST:'EARTH' };
        const prevEl = cell.element; const nextEl = oppMap[prevEl] || prevEl;
        cell.element = nextEl;
        // –í–∏–∑—É–∞–ª—å–Ω—ã–π ¬´fieldquake¬ª: —à–µ–π–¥–µ—Ä–Ω–æ–µ —Å–≥–æ—Ä–∞–Ω–∏–µ —Å—Ç–∞—Ä–æ–≥–æ —Ç–∞–π–ª–∞ –∏ –∑–∞–º–µ–Ω–∞ –º–∞—Ç–µ—Ä–∏–∞–ª–∞ –Ω–∞ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω—ã–π
        try {
          const tile = tileMeshes[r][c];
          const mat = getTileMaterial(nextEl);
          dissolveTileCrossfade(tile, getTileMaterial(prevEl), mat, 0.9);
          // –û–Ω–ª–∞–π–Ω–æ–≤–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —ç—Ñ—Ñ–µ–∫—Ç–∞
          try { if (NET_ACTIVE && MY_SEAT === gameState.active) socket.emit('tileCrossfade', { r, c, prev: prevEl, next: nextEl }); } catch {}
        } catch {}
        // –Æ–Ω–∏—Ç –Ω–∞ –∫–ª–µ—Ç–∫–µ –º–æ–∂–µ—Ç –∏–∑–º–µ–Ω–∏—Ç—å HP –∏–∑-–∑–∞ —Å–º–µ–Ω—ã —ç–ª–µ–º–µ–Ω—Ç–∞
        const u = gameState.board[r][c].unit;
        if (u) {
          const tpl = CARDS[u.tplId];
          const prevBuff = computeCellBuff(prevEl, tpl.element);
          const nextBuff = computeCellBuff(nextEl, tpl.element);
          const deltaHp = (nextBuff.hp || 0) - (prevBuff.hp || 0);
          if (deltaHp !== 0) {
            const before = u.currentHP; u.currentHP = Math.max(0, before + deltaHp);
            const tMesh = unitMeshes.find(m => m.userData.row === r && m.userData.col === c);
            if (tMesh) spawnDamageText(tMesh, `${deltaHp > 0 ? '+' : ''}${deltaHp}`, deltaHp > 0 ? '#22c55e' : '#ef4444');
            if (u.currentHP <= 0) {
              try { gameState.players[u.owner].graveyard.push(CARDS[u.tplId]); } catch {}
              const deadMesh = unitMeshes.find(m => m.userData.row === r && m.userData.col === c);
              if (deadMesh) { dissolveAndAsh(deadMesh, new THREE.Vector3(0,0,0.6), 0.9); setTimeout(()=>{ gameState.board[r][c].unit = null; updateUnits(); updateUI(); }, 1000); }
            }
          }
        }
        // –í–∏–∑—É–∞–ª—å–Ω–æ ¬´—Å–∂–µ—á—å¬ª –∫–∞—Ä—Ç—É —Å–ø–µ–ª–ª–∞ –≤ —Ç–æ—á–∫–µ –¥—Ä–æ–ø–∞ –∏ —É–±—Ä–∞—Ç—å –∏–∑ —Ä—É–∫–∏
        try {
          const big = createCard3D(tpl, false);
          const p = tileMesh.position.clone().add(new THREE.Vector3(0, 1.0, 0));
          big.position.copy(p); (boardGroup || scene).add(big); dissolveAndAsh(big, new THREE.Vector3(0,0.6,0), 0.9);
          spellDragHandled = true;
        } catch {}
        pl.mana -= tpl.cost; pl.discard.push(tpl); pl.hand.splice(idx, 1);
        updateHand(); updateUnits(); updateUI();
        return;
      }
      if (id === 'SPELL_PARMTETIC_HOLY_FEAST') {
        const handCreatures = pl.hand.filter(x => x && x.type === 'UNIT');
        if (handCreatures.length === 0) { showNotification('–ù–µ—Ç —Å—É—â–µ—Å—Ç–≤ –≤ —Ä—É–∫–µ –¥–ª—è —Ä–∏—Ç—É–∞–ª–∞', 'error'); return; }
        // –í–∏–∑—É–∞–ª—å–Ω–æ ¬´–æ—Å—Ç–∞–≤–∏–º¬ª –∫–∞—Ä—Ç—É –Ω–∞ –ø–æ–ª–µ: —Å–æ–∑–¥–∞—ë–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π –º–µ—à —Å–ø–µ–ª–ª–∞ –∏ –Ω–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–µ—Ä–µ—Ç—è–Ω—É—Ç—É—é –∫–∞—Ä—Ç—É
        try {
          const big = createCard3D(tpl, false);
          const p = tileMesh ? tileMesh.position.clone().add(new THREE.Vector3(0, 1.0, 0)) : new THREE.Vector3(0, 1.0, 0);
          big.position.copy(p);
          (boardGroup || scene).add(big);
          pendingRitualBoardMesh = big;
          spellDragHandled = true;
          // –°–ø—Ä—è—á–µ–º –ø–µ—Ä–µ—Ç—è–≥–∏–≤–∞–µ–º—É—é –∫–∞—Ä—Ç—É –Ω–∞ –≤—Ä–µ–º—è —Ä–∏—Ç—É–∞–ª–∞, —á—Ç–æ–±—ã –Ω–µ –¥—É–±–ª–∏—Ä–æ–≤–∞–ª–∞—Å—å –≤ —Ä—É–∫–µ
          try { cardMesh.visible = false; } catch {}
          // –ó–∞–ø–æ–º–Ω–∏–º –∏–Ω–¥–µ–∫—Å —Ç–µ–∫—É—â–µ–≥–æ —Å–ø–µ–ª–ª–∞ –≤ —Ä—É–∫–µ
          pendingRitualSpellHandIndex = idx;
        } catch {}
        showPrompt('–í—ã–±–µ—Ä–∏—Ç–µ —Å—É—â–µ—Å—Ç–≤–æ –∏–∑ —Ä—É–∫–∏ –¥–ª—è —Ä–∏—Ç—É–∞–ª–∞', () => {
          // –û—Ç–º–µ–Ω–∞ —Ä–∏—Ç—É–∞–ª–∞ ‚Äî —É–±—Ä–∞—Ç—å –≤—Ä–µ–º–µ–Ω–Ω—ã–π –º–µ—à –∏ –ø–æ–∫–∞–∑–∞—Ç—å –∫–∞—Ä—Ç—É-—Å–ø–µ–ª–ª, –±–µ–∑ –≤–æ–∑–≤—Ä–∞—Ç–∞ –≤ —Ä—É–∫—É
          try { if (pendingRitualBoardMesh && pendingRitualBoardMesh.parent) pendingRitualBoardMesh.parent.remove(pendingRitualBoardMesh); } catch {}
          pendingRitualBoardMesh = null;
          try { cardMesh.visible = true; } catch {}
          pendingRitualSpellHandIndex = null; updateHand();
          pendingDiscardSelection = null;
        });
        // –ï—Å–ª–∏ –∫–∞—Ä—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ ‚Äî –∂–¥—ë–º –∫–ª–∏–∫–∞ –ø–æ –∫–∞—Ä—Ç–µ –≤ —Ä—É–∫–µ
        if (handCreatures.length > 1) {
          pendingDiscardSelection = { requiredType: 'UNIT', onPicked: (handIdx) => {
            const toDiscardTpl = pl.hand[handIdx]; if (!toDiscardTpl) return;
            const handMesh = handCardMeshes.find(m => m.userData?.handIndex === handIdx);
            if (handMesh) { try { handMesh.userData.isInHand = false; } catch {} dissolveAndAsh(handMesh, new THREE.Vector3(0, 0.6, 0), 0.9); }
            try { pl.graveyard.push(toDiscardTpl); } catch {}
            pl.hand.splice(handIdx, 1); updateHand();
            pl.mana = capMana(pl.mana + 2); addLog(`${tpl.name}: —Ä–∏—Ç—É–∞–ª ‚Äî +2 –º–∞–Ω—ã.`);
            // –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∏—Ç—É–∞–ª–∞: –≤–∏–∑—É–∞–ª—å–Ω–æ —Å–∂–µ—á—å –≤—Ä–µ–º–µ–Ω–Ω—ã–π –º–µ—à —Å–ø–µ–ª–ª–∞ –∏ —É–±—Ä–∞—Ç—å –µ–≥–æ, –∑–∞—Ç–µ–º —É–¥–∞–ª–∏—Ç—å –∫–∞—Ä—Ç—É –∏–∑ —Ä—É–∫–∏ –∏ –ø–æ–ª–æ–∂–∏—Ç—å –≤ discard
            try { if (pendingRitualBoardMesh) { dissolveAndAsh(pendingRitualBoardMesh, new THREE.Vector3(0,0.6,0), 0.9); setTimeout(()=>{ try { pendingRitualBoardMesh.parent.remove(pendingRitualBoardMesh); } catch {} pendingRitualBoardMesh = null; }, 950); } } catch {}
            pl.mana = capMana(pl.mana - (tpl.cost || 0));
            // –£–¥–∞–ª—è–µ–º —Ç–µ–∫—É—â–∏–π —Ä–∞–∑—ã–≥—Ä–∞–Ω–Ω—ã–π —Å–ø–µ–ª–ª —Å –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º –∏–Ω–¥–µ–∫—Å–æ–º
            const spellIdx = (pendingRitualSpellHandIndex != null) ? pendingRitualSpellHandIndex : pl.hand.indexOf(tpl);
            if (spellIdx >= 0) { pl.hand.splice(spellIdx, 1); }
            pendingRitualSpellHandIndex = null;
            pl.discard.push(tpl); updateHand(); updateUI();
            try { schedulePush('spell-holy-feast', { force: true }); } catch {}
            hidePrompt(); pendingDiscardSelection = null;
          } }; addLog(`${tpl.name}: –≤—ã–±–µ—Ä–∏—Ç–µ —Å—É—â–µ—Å—Ç–≤–æ –≤ —Ä—É–∫–µ –¥–ª—è —Ä–∏—Ç—É–∞–ª—å–Ω–æ–≥–æ —Å–±—Ä–æ—Å–∞.`); return;
        }
        // –ï—Å–ª–∏ —Ä–æ–≤–Ω–æ –æ–¥–Ω–∞ –∫–∞—Ä—Ç–∞-—Å—É—â–Ω–æ—Å—Ç—å ‚Äî —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –µ—ë —Å—Ä–∞–∑—É
        const singleIdx = pl.hand.findIndex(x => x && x.type === 'UNIT');
        if (singleIdx >= 0) {
          const toDiscardTpl = pl.hand[singleIdx];
          const handMesh = handCardMeshes.find(m => m.userData?.handIndex === singleIdx);
          if (handMesh) { try { handMesh.userData.isInHand = false; } catch {} dissolveAndAsh(handMesh, new THREE.Vector3(0, 0.6, 0), 0.9); }
          try { pl.graveyard.push(toDiscardTpl); } catch {}
          pl.hand.splice(singleIdx, 1); updateHand();
          pl.mana = capMana(pl.mana + 2); addLog(`${tpl.name}: —Ä–∏—Ç—É–∞–ª ‚Äî +2 –º–∞–Ω—ã.`);
          try { if (pendingRitualBoardMesh) { dissolveAndAsh(pendingRitualBoardMesh, new THREE.Vector3(0,0.6,0), 0.9); setTimeout(()=>{ try { pendingRitualBoardMesh.parent.remove(pendingRitualBoardMesh); } catch {} pendingRitualBoardMesh = null; }, 950); } } catch {}
          pl.mana = capMana(pl.mana - (tpl.cost || 0));
          const spellIdx = (pendingRitualSpellHandIndex != null) ? pendingRitualSpellHandIndex : pl.hand.indexOf(tpl);
          if (spellIdx >= 0) { pl.hand.splice(spellIdx, 1); }
          pendingRitualSpellHandIndex = null;
          pl.discard.push(tpl); updateHand(); updateUI(); hidePrompt();
          try { schedulePush('spell-holy-feast', { force: true }); } catch {}
        }
        return;
      }
      // –ï—Å–ª–∏ —Å—é–¥–∞ –ø–æ–ø–∞–ª–∏ ‚Äî –Ω–µ—Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω–∞—è —Ü–µ–ª—å/—Å–ø–µ–ª–ª
      showNotification('–ù–µ–≤–µ—Ä–Ω–∞—è —Ü–µ–ª—å –¥–ª—è –∑–∞–∫–ª–∏–Ω–∞–Ω–∏—è', 'error');
    }

    // (—É–±—Ä–∞–Ω—ã –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ magic-btn –∏ draw-btn)
  </script>
<!-- —Å–µ—Ä–≤–µ—Ä–Ω—ã–π –ø–∞—Ç—á -->
<!-- === Multiplayer patch v2: sync + queue + countdown + lock input + indicator === --> 
<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
<script> 
(() => {
  // ===== 0) Config =====
  const SERVER_URL = (location.hostname === "localhost")
    ? "http://localhost:3001"
    : "https://eog-mp-server-production.up.railway.app"; // ‚Üê –¥–æ–º–µ–Ω —Å–µ—Ä–≤–µ—Ä–∞

  // ===== 1) Styles =====
  const css = `
  .mp-modal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.5);z-index:9999}
  .mp-card{min-width:280px;padding:18px 20px;border-radius:12px;background:#0f172a;color:#e5e7eb;border:1px solid #334155;box-shadow:0 10px 30px rgba(0,0,0,.35);text-align:center}
  .mp-btn{display:inline-flex;gap:8px;align-items:center;justify-content:center;padding:6px 10px;border-radius:6px;cursor:pointer;background:#475569;color:#e5e7eb;border:1px solid rgba(255,255,255,0.1);font-size:12px}
  .mp-btn:hover{background:#64748b}
  .mp-subtle{color:#94a3b8;font-size:12px;margin-top:6px}
  .mp-spinner{width:16px;height:16px;border:2px solid #64748b;border-top-color:transparent;border-radius:50%;animation:mp-spin .8s linear infinite}
  @keyframes mp-spin{to{transform:rotate(360deg)}}
  .mp-count{font-weight:800;font-size:64px;letter-spacing:.03em;margin:8px 0 10px}
  .mp-seat{font-size:14px;color:#cbd5e1}
  .mp-floater{position:fixed;right:12px;bottom:12px;z-index:9998;display:flex;gap:8px}
  .mp-ind{position:fixed;left:12px;bottom:12px;z-index:9998;display:flex;align-items:center;gap:8px;background:rgba(15,23,42,.85);color:#e5e7eb;border:1px solid #334155;padding:6px 10px;border-radius:999px;font:12px/1.2 system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
  .mp-dot{width:8px;height:8px;border-radius:50%;background:#64748b;box-shadow:0 0 0 2px rgba(0,0,0,.3) inset}
  .mp-dot.on{background:#16a34a}
  .mp-tag{padding:2px 6px;border-radius:999px;background:#1f2937;border:1px solid #334155}
  .mp-lock{position:fixed;inset:0;z-index:9997;display:none;align-items:center;justify-content:center;pointer-events:auto;background:rgba(2,6,23,.35)}
  .mp-lock.on{display:flex}
  .mp-lock .mp-card{background:#0b1224cc}
  `;
  const st = document.createElement('style'); st.textContent = css; document.head.appendChild(st);

  // ===== 2) –ö–Ω–æ–ø–∫–∞ ¬´–û–Ω–ª–∞–π–Ω-–∏–≥—Ä–∞¬ª ‚Äî –∫–∞–∫ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ overlay-–∫–Ω–æ–ø–∫–∏ —Ä—è–¥–æ–º —Å –æ—Å—Ç–∞–ª—å–Ω—ã–º–∏ =====
  function mountOnlineButton() {
    if (document.getElementById('find-match-btn')) return;
    const btn = document.createElement('button');
    btn.id = 'find-match-btn';
    btn.className = 'overlay-panel px-3 py-1.5 text-xs bg-slate-600 hover:bg-slate-700 transition-colors';
    btn.textContent = '–û–Ω–ª–∞–π–Ω-–∏–≥—Ä–∞';
    const host = document.querySelector('#corner-right .flex') || document.getElementById('corner-right');
    if (host) host.appendChild(btn);
    else {
      const wrap = document.getElementById('mp-floater') || (() => {
        const d = document.createElement('div'); d.id='mp-floater'; d.className='mp-floater'; document.body.appendChild(d); return d;
      })();
      wrap.appendChild(btn);
    }
    btn.addEventListener('click', onFindMatchClick);
  }
  mountOnlineButton();
  const mo = new MutationObserver(() => mountOnlineButton());
  mo.observe(document.body, { childList:true, subtree:true });

  // ===== 3) Queue modal + countdown =====
  let queueModal=null, startModal=null;
  function showQueueModal(){
    hideQueueModal();
    queueModal = document.createElement('div');
    queueModal.className='mp-modal';
    queueModal.innerHTML = `<div class="mp-card">
      <div style="display:flex;gap:10px;justify-content:center;align-items:center">
        <div class="mp-spinner"></div><div>–ü–æ–∏—Å–∫ –º–∞—Ç—á–∞‚Ä¶</div>
      </div><div class="mp-subtle">–ñ–¥—ë–º –≤—Ç–æ—Ä–æ–≥–æ –∏–≥—Ä–æ–∫–∞</div></div>`;
    document.body.appendChild(queueModal);
  }
  function hideQueueModal(){ queueModal?.remove(); queueModal=null; }
  function showStartCountdown(seat, secs=3){
    hideStartCountdown();
    startModal = document.createElement('div');
    startModal.className='mp-modal';
    startModal.innerHTML = `<div class="mp-card">
      <div>–ú–∞—Ç—á –Ω–∞–π–¥–µ–Ω!</div>
      <div class="mp-seat">–í—ã –∏–≥—Ä–∞–µ—Ç–µ –∑–∞: <b>${seat===0?'–ò–≥—Ä–æ–∫ 1':'–ò–≥—Ä–æ–∫ 2'}</b></div>
      <div class="mp-count" id="mp-count">${secs}</div>
      <div class="mp-subtle">–°—Ç–∞—Ä—Ç —á–µ—Ä–µ–∑ —Å–µ–∫—É–Ω–¥—ã‚Ä¶</div></div>`;
    document.body.appendChild(startModal);
    let t=secs; const el=startModal.querySelector('#mp-count');
    const timer=setInterval(()=>{ t--; if(t<=0){ clearInterval(timer); hideStartCountdown(); onCountdownFinished(seat); } else el.textContent=t; },1000);
  }
  function hideStartCountdown(){ startModal?.remove(); startModal=null; }

  // ===== 4) Socket + sync =====
  const socket = io(SERVER_URL, { transports:['websocket'] });
  try { window.socket = socket; } catch {}
  let NET_ACTIVE=false, MY_SEAT=null, APPLYING=false;

  // --- SENDING: ¬´–æ–±—ë—Ä—Ç–∫–∏¬ª + DIGEST-–ø—É–ª–ª–µ—Ä ---
  const TO_WRAP = [
    // –ø–∞—Ä—Ç–∏—è/—Ö–æ–¥
    'initGame','startGame','newGame','resetGame','endTurn','resign','setWinner',
    // –∫–æ–ª–æ–¥—ã/—Ä—É–∫–∏
    'shuffleDeck','drawOne','drawCard','drawCards','dealCard','dealCards','discardCard','discardSelectedCard',
    // –≤—ã–±–æ—Ä/–ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ/—Ü–µ–ª–∏
    'selectCard','deselectCard','resetCardSelection','onCardDropped','setTargetCell','setTargetUnit',
    // —É—Å—Ç–∞–Ω–æ–≤–∫–∞/–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
    'placeUnit','placeUnitWithDirection','rotateUnit','setFacing','setDirection',
    // –±–æ–π/—É—Ä–æ–Ω/—Å–º–µ—Ä—Ç—å
    'performBattleSequence','stagedAttack','applyDamage','killUnit','removeUnit','reviveUnit',
    // –∫–æ–Ω—Ç—Ä–æ–ª—å/–ø–æ–±–µ–¥–∞
    'captureCell','changeOwner','checkWinCondition',
    // —ç—Ñ—Ñ–µ–∫—Ç—ã/—Ä–µ—Å—É—Ä—Å—ã
    'castSpell','playSpell','applySpell','resolveSpell','applyEffect','removeEffect','spendMana','gainMana','updateMana',
    // UI —Ç—Ä–∏–≥–≥–µ—Ä—ã
    'updateUI','updateUnits','updateHand','createBoard','createMetaObjects','addLog'
  ];
  const GATED = [
    'endTurn','placeUnit','placeUnitWithDirection','rotateUnit','performBattleSequence','stagedAttack',
    'applyDamage','killUnit','onCardDropped','castSpell','playSpell','resolveSpell','setTargetCell','setTargetUnit','setFacing','setDirection'
  ];
  function wrap(name){
    const fn = window[name];
    if (typeof fn !== 'function') return;
    window[name] = function(...args){
      // –ë–ª–æ–∫–∏—Ä—É–µ–º –∫–ª—é—á–µ–≤—ã–µ –¥–µ–π—Å—Ç–≤–∏—è, –µ—Å–ª–∏ —Å–µ–π—á–∞—Å –Ω–µ –Ω–∞—à —Ö–æ–¥
      try {
        if (NET_ACTIVE && GATED.includes(name)) {
          const myTurn = (typeof gameState?.active === 'number') && (gameState.active === MY_SEAT);
          if (!myTurn) { try { typeof showNotification==='function' && showNotification('–°–µ–π—á–∞—Å —Ö–æ–¥ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞', 'error'); } catch {} return; }
        }
      } catch {}
      const r = fn.apply(this,args);
      // –ï—Å–ª–∏ —Ñ—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—Ä–æ–º–∏—Å (async) ‚Äî —à–ª—ë–º –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
      if (r && typeof r.then === 'function') {
        return r.then((val)=>{
          // –ö–ª—é—á–µ–≤—ã–µ —Å–æ–±—ã—Ç–∏—è —Ç—Ä–µ–±—É—é—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–≥–æ –ø—É—à–∞ –ø–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏
          if (name === 'endTurn' || name === 'initGame' || name === 'startGame') {
            schedulePush(name, { force: true });
          } else {
            schedulePush(name);
          }
          return val;
        });
      }
      if (name === 'endTurn' || name === 'initGame' || name === 'startGame') {
        schedulePush(name, { force: true });
      } else {
        schedulePush(name);
      }
      return r;
    };
  }
  TO_WRAP.forEach(wrap);

  // digest: –±—ã—Å—Ç—Ä—ã–π —Å–Ω–∏–º–æ–∫ –∑–Ω–∞—á–∏–º—ã—Ö –ø–æ–ª–µ–π
  function digest(state){
    try {
      if (!state) return '';
      const compact = {
        active: state.active,
        turn: state.turn,
        winner: state.winner ?? null,
        players: (state.players||[]).map(p => ({
          mana: p.mana, max: p.maxMana,
          hand: (p.hand||[]).map(c=>c.id),
          deckN: (p.deck||[]).length,
          discardN: (p.discard||[]).length
        })),
        board: (state.board||[]).map(row => row.map(cell => {
          const u = cell?.unit;
          return u ? {o:u.owner,h:u.hp,a:u.atk,f:u.facing,t:u.tplId} : null;
        }))
      };
      return JSON.stringify(compact);
    } catch { return '';}
  }

  let lastDigest = '';
  let pending = false;
  function schedulePush(reason='auto', {force=false}={}){
    if (!NET_ACTIVE || !gameState) return;
    if (APPLYING && !force) return;              // –Ω–µ —ç—Ö–æ–∏–º –ø–æ–ª—É—á–µ–Ω–Ω—ã–π —Å–Ω–∞–ø—à–æ—Ç
    const myTurn = (typeof gameState.active === 'number') && (gameState.active === MY_SEAT);
    if (!force && !myTurn) return;               // —Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–π –∏–≥—Ä–æ–∫ –ø—É—à–∏—Ç
    if (force) {
      // –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞, –∏–≥–Ω–æ—Ä–∏—Ä—É—è pending
      try { socket.emit('pushState', { state: gameState, reason }); } catch{}
      lastDigest = digest(gameState);
      pending = false;
      return;
    }
    if (pending) return;
    pending = true;
    requestAnimationFrame(()=>{
      pending = false;
      try { socket.emit('pushState', { state: gameState, reason }); } catch{}
      lastDigest = digest(gameState);
    });
  }
  // –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º –Ω–∞—Ä—É–∂—É, —á—Ç–æ–±—ã —Ä–∞–Ω–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, endTurn) –º–æ–≥–ª–∏ –≤—ã–∑–≤–∞—Ç—å schedulePush
  try { window.schedulePush = schedulePush; } catch {}

  // –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ –ø—Ä–∏ –ª—é–±–æ–º –∏–∑–º–µ–Ω–µ–Ω–∏–∏ (–ø–æ–¥—Å—Ç—Ä–∞—Ö–æ–≤–∫–∞, –µ—Å–ª–∏ –æ–±—ë—Ä—Ç–∫–∞ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª–∞)
  setInterval(()=>{
    if (!NET_ACTIVE || !gameState) return;
    // –ø—É—à–∏—Ç —Ç–æ–ª—å–∫–æ —Ç–æ—Ç, —É –∫–æ–≥–æ —Å–µ–π—á–∞—Å –•–û–î (—á—Ç–æ–±—ã –æ–±–∞ –º–æ–≥–ª–∏ –¥–µ–ª–∞—Ç—å —Å–≤–æ–∏ —Ö–æ–¥—ã)
    const myTurn = (typeof gameState.active === 'number') && (gameState.active === MY_SEAT);
    if (!myTurn) return;
    const d = digest(gameState);
    if (d && d !== lastDigest) schedulePush('digest');
  }, 250);

  // --- RECEIVING: –ø—Ä–∏–º–µ–Ω—è–µ–º —Å–Ω–∞–ø—à–æ—Ç –∏ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º ---
  socket.on('state', async (state)=>{
    if (!state) return;
    const prev = APPLYING ? null : (gameState ? JSON.parse(JSON.stringify(gameState)) : null);
    APPLYING = true;
    try {
      gameState = state;
      try { window.gameState = state; } catch {}
      lastDigest = digest(state);
      // –°–Ω–∞—á–∞–ª–∞ –ø–µ—Ä–µc–æ–±–µ—Ä—ë–º –¥–æ—Å–∫—É/–º–µ—Ç–∞-–æ–±—ä–µ–∫—Ç—ã, –∑–∞—Ç–µ–º —é–Ω–∏—Ç—ã –∏ UI (–∏—Å–ø—Ä–∞–≤–ª—è–µ—Ç –º–µ—Ä—Ü–∞–Ω–∏–µ —Ä–∞–º–æ–∫)
      try{ createBoard && createBoard(); }catch{}
      try{ createMetaObjects && createMetaObjects(); }catch{}
      try{ updateUnits(); }catch{}
      // –ü–æ–ø—Ä–æ–±—É–µ–º –¥–æ–∏–≥—Ä–∞—Ç—å –æ—Ç–ª–æ–∂–µ–Ω–Ω—ã–µ –∞–Ω–∏–º–∞—Ü–∏–∏ –Ω–∞–±–ª—é–¥–∞—Ç–µ–ª—è, –µ—Å–ª–∏ –º–µ—à–∏ —É–∂–µ –µ—Å—Ç—å
      try { flushPendingBattleQueues && flushPendingBattleQueues(); } catch {}
      try { if (prev) playDeltaAnimations(prev, state); } catch {}
      // –ï—Å–ª–∏ –ø—Ä–∏—à—ë–ª –Ω–æ–≤—ã–π —Ö–æ–¥, –∑–∞—Ä–∞–Ω–µ–µ –±–ª–æ–∫–∏—Ä—É–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –Ω–æ–≤—ã—Ö –æ—Ä–±–æ–≤ –º–∞–Ω—ã,
      // —á—Ç–æ–±—ã –ø–µ—Ä–≤–∞—è –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∫–∞ UI –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–ª–∞ –∏—Ö –¥–æ –≤—Å–ø—ã—à–∫–∏
      try {
        const isNewTurnEarly = !!(prev && typeof prev.turn === 'number' && typeof state.turn === 'number' && state.turn > prev.turn);
        if (isNewTurnEarly) {
          const ownerEarly = (typeof state.active === 'number') ? state.active : (gameState?.active ?? 0);
          const beforeMEarly = (prev?.players?.[ownerEarly]?.mana ?? 0);
          const afterMEarly = (state?.players?.[ownerEarly]?.mana ?? 0);
          PENDING_MANA_ANIM = { ownerIndex: ownerEarly, startIdx: Math.max(0, Math.min(9, beforeMEarly)), endIdx: Math.max(-1, Math.min(9, afterMEarly - 1)) };
        }
      } catch {}
      try{ updateUI(); }catch{}
      // –ï—Å–ª–∏ –Ω–∞—á–∞–ª—Å—è –Ω–æ–≤—ã–π —Ö–æ–¥ ‚Äî —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º –ø–æ—Ä—è–¥–æ–∫ –∞–Ω–∏–º–∞—Ü–∏–π –∫–∞–∫ –≤ –æ—Ñ–ª–∞–π–Ω–µ:
      // 1) –ó–∞—Å—Ç–∞–≤–∫–∞ —Ö–æ–¥–∞ —Å –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º –∑–∞–≥–æ–ª–æ–≤–∫–æ–º, 2) –ê–Ω–∏–º–∞—Ü–∏—è –º–∞–Ω—ã, 3) –î–æ–±–æ—Ä
      try {
        const isNewTurn = !!(prev && typeof prev.turn === 'number' && typeof state.turn === 'number' && state.turn > prev.turn);
        if (isNewTurn && lastSplashTurnShown < state.turn) {
          // –ó–∞—Å—Ç–∞–≤–∫–∞ (–±–ª–æ–∫–∏—Ä—É—é—â–µ)
          await forceTurnSplashWithRetry(2);
          // –ê–Ω–∏–º–∞—Ü–∏—è –º–∞–Ω—ã –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞ –¥–ª—è –æ–±–æ–∏—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤
          const owner = (typeof state.active === 'number') ? state.active : (gameState?.active ?? 0);
          const beforeM = (prev?.players?.[owner]?.mana ?? 0);
          const afterM = (state?.players?.[owner]?.mana ?? 0);
          // PENDING_MANA_ANIM —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤—ã—à–µ –ø–µ—Ä–µ–¥ –ø–µ—Ä–≤—ã–º updateUI; –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π –æ–±–Ω–æ–≤–∏–º UI
          try { updateUI(); } catch {}
          await animateTurnManaGain(owner, beforeM, afterM, 1500);
          // –ö–æ—Ä–æ—Ç–∫–∞—è –ø–∞—É–∑–∞ –ø–µ—Ä–µ–¥ –¥–æ–±–æ—Ä–æ–º –∫–∞—Ä—Ç—ã
          await sleep(80);
        }
      } catch {}
      // –ê–Ω–∏–º–∞—Ü–∏—è –¥–æ–±–æ—Ä–∞ —É –ø—Ä–∏—ë–º–Ω–∏–∫–∞ (—Ç–æ–ª—å–∫–æ –¥–ª—è —Å–≤–æ–µ–π —Ä—É–∫–∏)
      try {
        const mySeat = (typeof window !== 'undefined' && typeof window.MY_SEAT === 'number') ? window.MY_SEAT : null;
        if (mySeat !== null && prev && prev.players && state.players) {
          const prevHand = (prev.players[mySeat]?.hand) || [];
          const nextHand = (state.players[mySeat]?.hand) || [];
          const delta = Math.max(0, nextHand.length - prevHand.length);
          if (delta > 0) {
            // –°–ø—Ä—è—á–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ delta –∫–∞—Ä—Ç –Ω–∞ –≤—Ä–µ–º—è –∞–Ω–∏–º–∞—Ü–∏–∏
            pendingDrawCount = delta; updateHand();
            // –û–ø—Ä–µ–¥–µ–ª–∏–º –∫–∞–∫–∏–µ –∏–º–µ–Ω–Ω–æ —à–∞–±–ª–æ–Ω—ã –∞–Ω–∏–º–∏—Ä–æ–≤–∞—Ç—å ‚Äî –≤–æ–∑—å–º—ë–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ delta –∫–∞—Ä—Ç
            const newCards = nextHand.slice(-delta);
            for (let i = 0; i < newCards.length; i++) {
              const tpl = newCards[i];
              await animateDrawnCardToHand(tpl);
              // –ü–æ –æ–¥–Ω–æ–π –æ—Ç–∫—Ä—ã–≤–∞–µ–º –∫–∞—Ä—Ç—É –≤ —Ä—É–∫–µ
              pendingDrawCount = Math.max(0, pendingDrawCount - 1);
              updateHand();
            }
          } else {
            updateHand();
          }
        } else {
          updateHand();
        }
      } catch { updateHand(); }
      updateIndicator();
      updateInputLock();
    } finally { APPLYING=false; }
  });

  // –Ø–≤–Ω—ã–π —Å–∏–≥–Ω–∞–ª –æ —Å–º–µ–Ω–µ —Ö–æ–¥–∞ (—É—Å–∫–æ—Ä—è–µ—Ç —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫—É —É –æ–ø–ø–æ–Ω–µ–Ω—Ç–∞ –≤ –∑–∞–∞–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∫–µ–π—Å–∞—Ö)
  socket.on('turnSwitched', ({ activeSeat })=>{
    try {
      if (typeof activeSeat === 'number') {
        if (!gameState) gameState = {};
        gameState.active = activeSeat;
      }
    } catch {}
    updateIndicator();
    updateInputLock();
    // –ó–∞—Å—Ç–∞–≤–∫–∞ —Ö–æ–¥–∞ –±—É–¥–µ—Ç –ø–æ–∫–∞–∑–∞–Ω–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –Ω–æ–≤–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è (—Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º –∑–∞–≥–æ–ª–æ–≤–∫–æ–º)
  });

  // ===== 9) Battle animation sync =====
  function tryPlayBattleAnim(attacker, targets){
    try {
      if (!attacker || !Array.isArray(targets) || targets.length===0) return false;
      const aMesh = unitMeshes.find(m => m.userData.row === attacker.r && m.userData.col === attacker.c);
      const first = targets[0];
      if (!aMesh || !tileMeshes?.[first.r]?.[first.c]) return false;
      const targetPos = tileMeshes[first.r][first.c].position;
      const dir = new THREE.Vector3().subVectors(targetPos, aMesh.position).normalize();
      const push = { x: dir.x * 0.6, z: dir.z * 0.6 };
      const tl = gsap.timeline();
      tl.to(aMesh.position, { x: `+=${push.x}`, z: `+=${push.z}`, duration: 0.22, ease: 'power2.out' })
        .to(aMesh.position, { x: `-=${push.x}`, z: `-=${push.z}`, duration: 0.30, ease: 'power2.inOut' });
      return true;
    } catch { return false; }
  }
  socket.on('battleAnim', ({ attacker, targets }) => {
    if (!tryPlayBattleAnim(attacker, targets)) {
      // –æ—Ç–ª–æ–∂–∏–º –¥–æ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è —Å–Ω–∞–ø—à–æ—Ç–∞ –∏ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –º–µ—à–µ–π
      PENDING_BATTLE_ANIMS.push({ attacker, targets, ts: Date.now() });
    }
  });

  // –î–æ–ø. —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è: –∫–æ–Ω—Ç—Ä–∞—Ç–∞–∫–∞ (–≤—ã–ø–∞–¥—ã –∫–æ–Ω—Ç—Ä–∞—Ç–∞–∫—É—é—â–∏—Ö –∏ —É–¥–∞—Ä –ø–æ –∞—Ç–∞–∫—É—é—â–µ–º—É)
  function tryPlayRetaliation(attacker, retaliators, total){
    try {
      if (!attacker || !Array.isArray(retaliators)) return false;
      const aMesh = unitMeshes.find(m => m.userData.row === attacker.r && m.userData.col === attacker.c);
      if (!aMesh) return false;
      let maxDur = 0;
      for (const rrObj of retaliators) {
        const rMesh = unitMeshes.find(m => m.userData.row === rrObj.r && m.userData.col === rrObj.c);
        if (!rMesh) continue;
        const dir2 = new THREE.Vector3().subVectors(aMesh.position, rMesh.position).normalize();
        const push2 = { x: dir2.x * 0.6, z: dir2.z * 0.6 };
        const tl2 = gsap.timeline();
        tl2.to(rMesh.position, { x: `+=${push2.x}`, z: `+=${push2.z}`, duration: 0.22, ease: 'power2.out' })
           .to(rMesh.position, { x: `-=${push2.x}`, z: `-=${push2.z}`, duration: 0.30, ease: 'power2.inOut' });
        maxDur = Math.max(maxDur, 0.52);
      }
      if (typeof total === 'number' && total > 0) {
        setTimeout(() => {
          const aLive = unitMeshes.find(m => m.userData.row === attacker.r && m.userData.col === attacker.c) || aMesh;
          if (aLive) { shakeMesh(aLive, 6, 0.14); spawnDamageText(aLive, `-${total}`, '#ffd166'); }
        }, Math.max(0, maxDur * 1000 - 10));
      }
      return true;
    } catch { return false; }
  }
  socket.on('battleRetaliation', ({ attacker, retaliators, total }) => {
    // –ê–∫—Ç–∏–≤–Ω—ã–π —É–∂–µ –≤–∏–¥–µ–ª –∞–Ω–∏–º–∞—Ü–∏—é –ª–æ–∫–∞–ª—å–Ω–æ
    if (typeof MY_SEAT === 'number' && gameState && MY_SEAT === gameState.active) return;
    if (!tryPlayRetaliation(attacker, retaliators, total)) {
      PENDING_RETALIATIONS.push({ attacker, retaliators, total, ts: Date.now() });
    }
  });

  function flushPendingBattleQueues(){
    try {
      if (PENDING_BATTLE_ANIMS.length) {
        PENDING_BATTLE_ANIMS = PENDING_BATTLE_ANIMS.filter(ev => !tryPlayBattleAnim(ev.attacker, ev.targets));
      }
      if (PENDING_RETALIATIONS.length) {
        PENDING_RETALIATIONS = PENDING_RETALIATIONS.filter(ev => !tryPlayRetaliation(ev.attacker, ev.retaliators, ev.total));
      }
    } catch {}
  }

  // ===== 10) Tile crossfade sync =====
  socket.on('tileCrossfade', ({ r, c, prev, next }) => {
    try {
      const tile = tileMeshes?.[r]?.[c]; if (!tile) return;
      dissolveTileCrossfade(tile, getTileMaterial(prev), getTileMaterial(next), 0.9);
    } catch {}
  });

  // ===== 5) Queue / start =====
  function onFindMatchClick(){ showQueueModal(); socket.emit('joinQueue'); }
  socket.on('matchFound', ({ seat })=>{
    hideQueueModal();
    MY_SEAT = seat; NET_ACTIVE = true;
    try { window.MY_SEAT = seat; } catch {}
    updateIndicator(); updateInputLock();
    showStartCountdown(seat, 3);
  });

  async function onCountdownFinished(seat){
    if (seat===0){
      try{ typeof initGame==='function' && await initGame(); }catch{}
      schedulePush('init-snapshot', {force:true}); // –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–µ—Ä–≤—ã–π —Å–Ω–∞–ø—à–æ—Ç
    } else {
      socket.emit('requestState');
    }
  }

  socket.on('opponentLeft', ()=>{
    NET_ACTIVE=false; updateIndicator(); updateInputLock();
    showVictoryModal({ reason: 'opponentLeft' });
  });

  // ===== 6) Online indicator + whose turn =====
  const ind = document.createElement('div');
  ind.className='mp-ind';
  ind.innerHTML = `<span class="mp-dot" id="mp-dot"></span>
                   <span id="mp-net">offline</span>
                   <span class="mp-tag" id="mp-seat">‚Äî</span>
                   <span class="mp-turn" id="mp-turn"></span>`;
  document.body.appendChild(ind);

  // –ü–æ–ª—É—á–µ–Ω–∏–µ –≤–µ—Ä—Å–∏–∏ –±–∏–ª–¥–∞ (–≤ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–µ ‚Äî –∫–æ–º–º–∏—Ç –∫–ª–∏–µ–Ω—Ç—Å–∫–æ–≥–æ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è –∏–∑ GitHub API)
  (async function fetchBuildVersion(){
    const el = document.getElementById('build-version');
    if (!el) return;
    // 1) –ü—Ä–æ–±—É–µ–º GitHub API –ø–æ window.CLIENT_REPO = { owner, repo, ref? }
    try {
      let cfg = (typeof window !== 'undefined' && window.CLIENT_REPO) ? window.CLIENT_REPO : null;
      // –ü—Ä–æ–±—É–µ–º –ø—Ä–æ—á–∏—Ç–∞—Ç—å –∏–∑ <meta name="client-repo" content="owner/repo@ref">, –ª–∏–±–æ –∏–∑ localStorage
      if (!cfg) {
        try {
          const meta = document.querySelector('meta[name="client-repo"]');
          const val = (meta && meta.getAttribute('content')) || (localStorage.getItem('CLIENT_REPO') || '');
          if (val) {
            // –§–æ—Ä–º–∞—Ç—ã: owner/repo@ref | owner/repo
            const [full, ref] = String(val).split('@');
            const [owner, repo] = full.split('/');
            if (owner && repo) cfg = { owner, repo, ref };
          }
        } catch {}
      }
      if (cfg && cfg.owner && cfg.repo) {
        const ref = encodeURIComponent(cfg.ref || 'main');
        const headers = {};
        // –ù–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω GitHub –¥–ª—è –ø–æ–≤—ã—à–µ–Ω–Ω–æ–≥–æ –ª–∏–º–∏—Ç–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø–æ–ª–æ–∂–∏—Ç—å –≤ localStorage.GH_TOKEN)
        try { const t = localStorage.getItem('GH_TOKEN'); if (t) headers['Authorization'] = `Bearer ${t}`; } catch {}
        const gh = await fetch(`https://api.github.com/repos/${cfg.owner}/${cfg.repo}/commits/${ref}`, { headers });
        if (gh.ok) {
          const data = await gh.json();
          const shaShort = (data.sha || '').slice(0, 7);
          let msg = (data.commit && data.commit.message) ? String(data.commit.message).trim() : '';
          if (msg) { const parts = msg.split(/\s+/).slice(0, 7); msg = parts.join(' '); }
          el.textContent = shaShort ? `${shaShort}${msg ? ' ‚Äî ' + msg : ''}` : (msg || '');
          return;
        }
      }
    } catch {}
    // 2) –§–æ–ª–±—ç–∫: —Å–µ—Ä–≤–µ—Ä–Ω—ã–π /build (–ø–æ–∫–∞–∂–µ—Ç –≤–µ—Ä—Å–∏—é –∏–º–µ–Ω–Ω–æ —Å–µ—Ä–≤–µ—Ä–Ω–æ–≥–æ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è)
    try {
      const res = await fetch('/build');
      if (!res.ok) return;
      const d = await res.json();
      const shaShort = (d.sha || '').slice(0, 7);
      let msg = (d.message || '').trim();
      if (msg) { const parts = msg.split(/\s+/).slice(0, 7); msg = parts.join(' '); }
      el.textContent = shaShort ? `${shaShort}${msg ? ' ‚Äî ' + msg : ''}` : (msg || '');
    } catch {}
  })();

  function updateIndicator(){
    const dot=document.getElementById('mp-dot');
    const net=document.getElementById('mp-net');
    const seat=document.getElementById('mp-seat');
    const turn=document.getElementById('mp-turn');

    const online = socket.connected && NET_ACTIVE;
    dot.classList.toggle('on', online);
    net.textContent = online ? 'online' : 'offline';
    seat.textContent = (MY_SEAT===0)?'–ò–≥—Ä–æ–∫ 1':(MY_SEAT===1)?'–ò–≥—Ä–æ–∫ 2':'‚Äî';

    if (gameState && (MY_SEAT===0 || MY_SEAT===1)){
      turn.textContent = (gameState.active===MY_SEAT) ? '–≤–∞—à —Ö–æ–¥' : '—Ö–æ–¥ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞';
    } else turn.textContent='';
  }
  socket.on('connect', updateIndicator);
  socket.on('disconnect', updateIndicator);
  socket.on('matchFound', updateIndicator);
  setInterval(updateIndicator, 500);
  updateIndicator();

  // ===== 7) Input lock: –∫–æ–≥–¥–∞ –Ω–µ —Ç–≤–æ–π —Ö–æ–¥ ‚Äî –±–ª–æ–∫–∏—Ä—É–µ–º –∫–ª–∏–∫–∏ –ø–æ —Å—Ü–µ–Ω–µ =====
  const lock = document.createElement('div');
  lock.className = 'mp-lock';
  lock.innerHTML = `<div class="mp-card">–•–æ–¥ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞‚Ä¶</div>`;
  document.body.appendChild(lock);

  function updateInputLock(){
    const shouldLock = NET_ACTIVE && gameState && (gameState.active !== MY_SEAT);
    lock.classList.toggle('on', !!shouldLock);
  }

  // –°–µ—Ä–≤–µ—Ä–Ω—ã–π —Ç–∞–π–º–µ—Ä —Ö–æ–¥–∞: —Ç–æ–ª—å–∫–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏ –ª–æ–∫–∞–ª—å–Ω–∞—è –∞–Ω–∏–º–∞—Ü–∏—è –∫–Ω–æ–ø–∫–∏
  socket.on('turnTimer', ({ seconds, activeSeat })=>{
    try { window.__turnTimerSeconds = seconds; } catch {}
    try { if (gameState && typeof activeSeat === 'number') gameState.active = activeSeat; } catch {}
    try {
      const btn = document.getElementById('end-turn-btn');
      if (btn) {
        const fill = btn.querySelector('.time-fill');
        const txt = btn.querySelector('.sec-text');
        if (txt) txt.textContent = `${Math.max(0, Math.min(100, seconds))}`;
        const percent = Math.max(0, Math.min(100, seconds)) / 100;
        if (fill) fill.style.top = `${Math.round((1 - percent) * 100)}%`;
        if (seconds <= 10) { btn.classList.add('urgent'); } else { btn.classList.remove('urgent'); }
      }
    } catch {}
  });

  // ===== 8) –ü–æ–±–µ–¥–∞/–ø–æ—Ä–∞–∂–µ–Ω–∏–µ –∏ –º–µ–Ω—é –ø–æ—Å–ª–µ –º–∞—Ç—á–∞ =====
  function showVictoryModal({ reason, winnerSeat }={}){
    hideQueueModal(); hideStartCountdown();
    const m = document.createElement('div');
    m.className = 'mp-modal';
    const title = reason==='opponentLeft' ? '–ü—Ä–æ—Ç–∏–≤–Ω–∏–∫ –æ—Ç–∫–ª—é—á–∏–ª—Å—è' : winnerSeat===MY_SEAT ? '–ü–æ–±–µ–¥–∞!' : '–ü–æ—Ä–∞–∂–µ–Ω–∏–µ';
    m.innerHTML = `<div class="mp-card" style="min-width:320px">
      <div style="font-size:18px;margin-bottom:6px">${title}</div>
      <div class="mp-subtle" style="margin-bottom:12px">–ú–∞—Ç—á –∑–∞–≤–µ—Ä—à—ë–Ω</div>
      <div style="display:flex;gap:8px;justify-content:center">
        <button id="mp-offline" class="mp-btn">–û—Ñ—Ñ–ª–∞–π–Ω-–∏–≥—Ä–∞</button>
        <button id="mp-online" class="mp-btn">–í –Ω–æ–≤—ã–π –æ–Ω–ª–∞–π–Ω-–º–∞—Ç—á</button>
      </div>
    </div>`;
    document.body.appendChild(m);
    m.querySelector('#mp-offline').addEventListener('click', ()=>{ try{ location.reload(); }catch{} });
    m.querySelector('#mp-online').addEventListener('click', ()=>{
      try{ m.remove(); }catch{}
      NET_ACTIVE=false; updateIndicator(); updateInputLock();
      onFindMatchClick();
    });
  }

  // –ö–Ω–æ–ø–∫–∞ ¬´–°–¥–∞—Ç—å—Å—è¬ª —Ä—è–¥–æ–º —Å –æ—Å—Ç–∞–ª—å–Ω—ã–º–∏
  function mountResignButton(){
    if (document.getElementById('resign-btn')) return;
    const host = document.querySelector('#corner-right .flex') || document.getElementById('corner-right');
    if (!host) return;
    const btn = document.createElement('button');
    btn.id = 'resign-btn';
    btn.className = 'overlay-panel px-3 py-1.5 text-xs bg-red-600 hover:bg-red-700 transition-colors';
    btn.textContent = '–°–¥–∞—Ç—å—Å—è';
    host.appendChild(btn);
    btn.addEventListener('click', ()=>{
      const confirmModal = document.createElement('div');
      confirmModal.className = 'mp-modal';
      confirmModal.innerHTML = `<div class="mp-card">
        <div>–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —Å–¥–∞—Ç—å—Å—è?</div>
        <div style="display:flex;gap:8px;justify-content:center;margin-top:10px">
          <button id="r-yes" class="mp-btn">–î–∞</button>
          <button id="r-no" class="mp-btn">–ù–µ—Ç</button>
        </div>
      </div>`;
      document.body.appendChild(confirmModal);
      confirmModal.querySelector('#r-no').addEventListener('click', ()=> confirmModal.remove());
      confirmModal.querySelector('#r-yes').addEventListener('click', ()=>{
        try { socket.emit('resign'); } catch {}
        try { confirmModal.remove(); } catch {}
      });
    });
  }
  mountResignButton();
  setInterval(mountResignButton, 1000);

  socket.on('matchEnded', ({ winnerSeat })=>{
    NET_ACTIVE=false; updateIndicator(); updateInputLock();
    showVictoryModal({ winnerSeat });
  });

})();
</script>
</body>
</html>