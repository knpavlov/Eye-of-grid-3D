<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="client-repo" content="knpavlov/Eye-of-grid-3D@main"> 
  <title>Eye of Grid — Complete 3D</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="styles/main.css">
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
  <script type="module" src="./src/main.js"></script>
  </head>
<body>
  <canvas id="three-canvas"></canvas>
  
  <!-- MODULE: UI layout (static) - consider extracting to templates/components -->
  <div id="ui">
    <!-- Боковые панели: слева — игрок A, справа — игрок B -->
    <div id="left-side" class="ui-panel fixed left-4 top-1/2 -translate-y-1/2 space-y-3 z-20 flex flex-col items-center">
      <div id="player-title-0" class="text-2xl md:text-3xl font-semibold text-center w-full">Игрок 1</div>
      <div class="overlay-panel px-4 py-2">
        <div class="text-sm mb-1">Mana</div>
        <div class="mana-bar" id="mana-display-0"></div>
      </div>
      <div class="overlay-panel px-4 py-2 text-sm" id="control-info-0">Controlled cells: 0</div>
    </div>

    <div id="right-side" class="ui-panel fixed right-4 top-1/2 -translate-y-1/2 space-y-3 z-20 flex flex-col items-center">
      <div id="player-title-1" class="text-2xl md:text-3xl font-semibold text-center w-full">Игрок 2</div>
      <div class="overlay-panel px-4 py-2">
        <div class="text-sm mb-1">Mana</div>
        <div class="mana-bar" id="mana-display-1"></div>
      </div>
      <div class="overlay-panel px-4 py-2 text-sm" id="control-info-1">Controlled cells: 0</div>
    </div>

    <!-- Верхний центр: номер хода и круглая кнопка с таймером -->
    <div id="top-center" class="ui-panel fixed top-3 left-1/2 -translate-x-1/2 z-20 flex flex-col items-center">
      <div class="overlay-panel px-4 py-2 flex flex-col items-center gap-1">
        <div id="summon-lock" class="w-6 h-6">🔒</div>
        <div id="turn-info" class="text-sm tracking-wide">Turn: 1</div>
        <button id="end-turn-btn" class="end-turn-btn" aria-label="End Turn">
          <span class="time-fill"></span>
          <span class="label-text">End Turn</span>
          <span class="sec-text">100</span>
        </button>
      </div>
      <div id="opponent-hand-count" title="Opponent has 0 cards"></div>
    </div>

    <!-- Правая верхняя область для вспомогательных кнопок -->
    <div id="top-right" class="ui-panel fixed top-3 right-3 z-50">
      <button id="cancel-play-btn" class="overlay-panel px-4 py-2 bg-red-600 hover:bg-red-700 hidden">Отмена</button>
    </div>

    <!-- Левый нижний угол: отладочные действия -->
    <div id="corner-left" class="ui-panel fixed left-4 bottom-24 z-30">
      <button id="debug-mana-btn" class="overlay-panel px-3 py-1.5 text-xs bg-emerald-700 hover:bg-emerald-600 transition-colors">+10 маны всем</button>
    </div>

    <!-- Правый нижний угол: сервисные кнопки -->
    <div id="corner-right" class="ui-panel fixed right-4 bottom-4 z-20">
      <div class="flex gap-2 opacity-90">
        <button id="log-btn" class="overlay-panel px-3 py-1.5 text-xs bg-slate-600 hover:bg-slate-700 transition-colors">Log</button>
        <button id="help-btn" class="overlay-panel px-3 py-1.5 text-xs bg-slate-600 hover:bg-slate-700 transition-colors">Help</button>
        <button id="menu-btn" class="overlay-panel px-3 py-1.5 text-xs bg-slate-600 hover:bg-slate-700 transition-colors">Menu</button>
      </div>
    </div>
    
    <!-- Панель логов -->
    <div id="log-panel" class="ui-panel fixed right-4 bottom-20 w-96 h-80 overlay-panel p-4 hidden z-30">
      <div class="flex justify-between items-center mb-3">
        <h3 class="text-lg font-semibold">Log</h3>
        <button id="close-log-btn" class="text-xl">&times;</button>
      </div>
      <div id="log-content" class="h-full overflow-y-auto text-sm space-y-1"></div>
    </div>
    
    <!-- Панель помощи -->
    <div id="help-panel" class="ui-panel fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden z-40">
      <div class="overlay-panel p-6 max-w-lg">
        <div class="flex justify-between items-center mb-4">
          <h3 class="text-xl font-semibold">How to play</h3>
          <button id="close-help-btn" class="text-xl">&times;</button>
        </div>
        <div class="space-y-3 text-sm">
          <p>• Перетаскивайте карты существ на игровое поле</p>
          <p>• Выбирайте направление после размещения</p>
          <p>• Кликайте по своим существам для атаки или поворота</p>
          <p>• Используйте заклинания, перетаскивая их на цель или на поле</p>
          <p>• Победа: контролируйте 5+ клеток в конце хода</p>
        </div>
      </div>
    </div>
    
    <!-- Панель выбора направления -->
    <div id="orientation-panel" class="ui-panel fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden z-40">
      <div class="overlay-panel p-6">
        <div class="text-center mb-4">Chose direction</div>
        <div class="grid grid-cols-3 gap-2 w-48 mx-auto">
          <div></div>
          <button data-dir="N" class="overlay-panel px-4 py-2 hover:bg-slate-700">↑</button>
          <div></div>
          <button data-dir="W" class="overlay-panel px-4 py-2 hover:bg-slate-700">←</button>
          <div class="overlay-panel px-4 py-2 text-center">•</div>
          <button data-dir="E" class="overlay-panel px-4 py-2 hover:bg-slate-700">→</button>
          <div></div>
          <button data-dir="S" class="overlay-panel px-4 py-2 hover:bg-slate-700">↓</button>
          <div></div>
        </div>
      </div>
    </div>
    
    <!-- Панель действий с существом -->
    <div id="unit-action-panel" class="ui-panel fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden z-40">
      <div class="overlay-panel p-6 space-y-3">
        <div id="unit-info" class="text-center mb-4"></div>
        <button id="attack-btn" class="w-full overlay-panel px-4 py-2 bg-red-600 hover:bg-red-700">Attack</button>
        <div id="unit-extra-actions" class="space-y-2"></div>
        <div class="grid grid-cols-2 gap-2">
          <button id="rotate-cw-btn" class="overlay-panel px-4 py-2 hover:bg-slate-700">Rotate ↻</button>
          <button id="rotate-ccw-btn" class="overlay-panel px-4 py-2 hover:bg-slate-700">Rotate ↺</button>
        </div>
        <button id="cancel-action-btn" class="w-full overlay-panel px-4 py-2 bg-gray-600 hover:bg-gray-700">Cancel</button>
      </div>
    </div>

    <!-- Постоянная панель подсказок/промптов -->
    <div id="prompt-panel" class="ui-panel fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden z-40">
      <div class="overlay-panel p-6 space-y-4">
        <div id="prompt-text" class="text-center"></div>
        <div class="text-center">
          <button id="cancel-prompt-btn" class="overlay-panel px-4 py-2 bg-gray-600 hover:bg-gray-700">Cancel</button>
        </div>
      </div>
    </div>
    
    <!-- Уведомленчиния -->
    <div id="notifications" class="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-50 pointer-events-none"></div>

    <!-- Баннеры: Turn и Battle -->
    <div id="turn-banner" class="banner fixed inset-0 hidden items-center justify-center z-40"></div>
    <div id="battle-banner" class="banner fixed inset-0 hidden items-center justify-center z-40">
      <div class="battlePop text-5xl font-extrabold bg-gradient-to-br from-red-600/80 to-yellow-500/80 px-10 py-5 rounded-3xl shadow-2xl ring-4 ring-yellow-400/40">BATTLE</div>
    </div>
    <!-- Tooltip -->
    <div id="hover-tooltip" class="hidden overlay-panel px-2 py-1 text-xs"></div>
  </div>

  <!-- Версия билда (сверху слева) -->
  <div id="build-version" class="fixed left-0 top-0 z-20 text-xs text-slate-300 opacity-80 p-1.5"></div>

  <script>
      /* MODULE: runtime globals
         Purpose: multiplayer state shared across modules
         Extracted to src/core/netState.js */
      // ====== ИГРОВАЯ ЛОГИКА (полная версия из 2D) ======
    
    let DIR_VECTORS, OPPOSITE_ELEMENT, elementEmoji, turnCW, turnCCW;
    // Переопределяем ориентации: N должен смотреть к верхнему краю (−Z), S — к нижнему (+Z)
    // В three.js «вперёд» меша по умолчанию это +Z (0°), поэтому:
    // S: 0°, E: -90°, W: 90°, N: 180°
    // Исправление: N (стрелка вверх) = 0°, S (стрелка вниз) = 180°; E/W оставляем как есть
    let facingDeg;
    
    let uid, inBounds, capMana, attackCost, rotateCost;
    
    // Карты и наборы колод
    let CARDS, DECKS;
    
    // Функции игровой логики (полные реализации находятся в core/*)
    let computeCellBuff, effectiveStats;

    let shuffle;

    let drawOne;

    // Специальная версия: вынуть верхнюю карту, но НЕ класть в руку (для эффектной анимации)
    let drawOneNoAdd;

    let countControlled;

    let startGame;
      // ====== БОЕВАЯ СИСТЕМА (порт из 2D) ======
      let hasAdjacentGuard;
      let computeHits;

    let stagedAttack;
    let magicAttack;
    
      /* MODULE: 3D scene setup and rendering
         Target module: src/scene/*.js (board, cards, units). Inline code below
         duplicates logic already present in modules; keep until migration
         complete. */
      // ====== THREE.JS СЦЕНА ======

      let scene, camera, renderer, raycaster, mouse;
      let boardGroup, cardGroup, effectsGroup, metaGroup;
      let tileMeshes = [];    // 2D массив мешей клеток игрового поля
      let tileFrames = [];    // рамки подсветки/выделения клеток
    let unitMeshes = [];      // текущие меши юнитов на поле
    let handCardMeshes = [];  // меши карт в руке игрока
      let gameState = null;
      // Позволяем модулям (например, applyGameState) синхронизировать локальную копию состояния
      try { window.setGameState = (s) => { gameState = s; }; } catch {}
      // Tile textures are now managed by scene/board module
    // Настройки показа большой карты при доборе — можно править из консоли
    window.DRAW_CARD_TUNE = {
      posY: 8.5,   // высота
      posZ: 2.4,    // дистанция к камере (чем меньше, тем ближе)
      scale: 1.7,   // масштаб
      // Ручная довращалка (в градусах):
      pitchDeg: 45,  // наклон вперёд/назад (ось X)
      yawDeg: 0,    // поворот влево/вправо (ось Y)
      rollDeg: 0    // крен (ось Z)
    };
    // Очереди догоняющих анимаций боя для наблюдателя
    let PENDING_BATTLE_ANIMS = [];
    let PENDING_RETALIATIONS = [];
    // Recently shown remote damage (to avoid duplicate delta popups)
    let RECENT_REMOTE_DAMAGE = new Map();
    try { window.RECENT_REMOTE_DAMAGE = RECENT_REMOTE_DAMAGE; } catch {}
    // Pending HP popups scheduled by playDeltaAnimations, so we can cancel if battleAnim shows earlier
    // HP popup scheduling moved to src/scene/effects.js
    let PENDING_HIDE_HAND_CARDS = [];
    // Управление анимациями заставки хода и добора карты
    // Перенесено в ui/banner.js

      var manaGainActive = false;
      try { window.manaGainActive = manaGainActive; } catch {}
      var PENDING_MANA_ANIM = null; // { ownerIndex, startIdx, endIdx }
      var PENDING_MANA_BLOCK = [0,0]; // by player index
// Ожидаемая анимация маны: диапазон новых орбов, которые должны появиться синхронно со вспышкой
        try { window.PENDING_MANA_ANIM = PENDING_MANA_ANIM; } catch {}
    // Блокировка появления N последних орбов маны на панели до завершения «полетевших» визуальных орбов (смерть/эффекты)
        try { window.PENDING_MANA_BLOCK = PENDING_MANA_BLOCK; } catch {}
    // Прячет один экземпляр ритуального спелла в руке активного игрока, пока ждём выбора жертвы
    let pendingRitualSpellHandIndex = null;
    let pendingRitualSpellCard = null; // ссылка на сам объект карты-спелла, чтобы скрывать по идентичности
    let pendingRitualOrigin = null;
    // Сколько последних добранных карт временно скрывать из моей руки (для красивой анимации влёта)
    let pendingDrawCount = 0;
    // Блокировка ввода теперь в ui/inputLock.js
    // Отступ руки по оси Z (положительное — дальше от камеры)
    const HAND_Z_OFFSET = 1.0;
    // Смещение колод/кладбищ от камеры вдоль оси Z (положительное значение — дальше от камеры)
      const META_Z_AWAY = 1.5;
      try { window.META_Z_AWAY = META_Z_AWAY; } catch {}
      // 3D объекты справа (колоды/кладбища) создаются модулем scene/meta.js

    // === THREE.JS SCENE INITIALIZATION ===
    function initThreeJS() {
      if (window.__scene && typeof window.__scene.initThreeJS === 'function') {
        const ctx = window.__scene.initThreeJS({ canvasId: 'three-canvas', clearColor: 0x0b1220 });
        renderer = ctx.renderer;
        scene = ctx.scene;
        camera = ctx.camera;
        raycaster = ctx.raycaster;
        mouse = ctx.mouse;
        boardGroup = ctx.boardGroup;
        cardGroup = ctx.cardGroup;
        effectsGroup = ctx.effectsGroup;
        metaGroup = ctx.metaGroup;
        try { window.renderer = renderer; window.scene = scene; window.camera = camera; window.boardGroup = boardGroup; } catch {}
      } else {
        throw new Error('Scene module not available');
      }
    }
    // preloadCardImages removed (module handles lazy loading)

    // Request deferred redraw of units and hand after state mutations.
    function requestCardsRedraw() {
      clearTimeout(window.__cardsRedrawT);
      window.__cardsRedrawT = setTimeout(() => { updateUnits(); updateHand(); }, 10);
    }

    // Возврат материала тайла по его элементу; делегируется модулю доски
    function getTileMaterial(element) {
      if (window.__board && window.__board.getTileMaterial) {
        return window.__board.getTileMaterial(element);
      }
      return null;
    }

    function updateTileMaterialsFor(elementKey) {
      if (window.__board && window.__board.updateTileMaterialsFor) {
        window.__board.updateTileMaterialsFor(elementKey);
      }
    }

    // Build or rebuild the 3D board tiles.
    function createBoard() {
      try { window.__cards.preloadCardTextures(); } catch {}
      if (window.__board && window.__scene) {
        window.__board.createBoard(gameState);
        const ctx = window.__scene.getCtx();
        tileMeshes = ctx.tileMeshes || [];
        tileFrames = ctx.tileFrames || [];
        try { window.tileMeshes = tileMeshes; window.tileFrames = tileFrames; } catch {}
      }
    }
    
    // Delegator: module cards implementation
    function createCard3D(cardData, isInHand = false, hpOverride = null, atkOverride = null) {
      if (window.__cards && typeof window.__cards.createCard3D === 'function') {
        return window.__cards.createCard3D(cardData, isInHand, hpOverride, atkOverride);
      }
      throw new Error('[bridge] __cards.createCard3D not available; modules must be loaded.');
    }
    // Delegator: module cards implementation
    function drawCardFace(ctx, cardData, width, height, hpOverride = null, atkOverride = null) {
      if (window.__cards && typeof window.__cards.drawCardFace === 'function') {
        return window.__cards.drawCardFace(ctx, cardData, width, height, hpOverride, atkOverride);
      }
      throw new Error('[bridge] __cards.drawCardFace not available; modules must be loaded.');
    }
    

    
    // ====== HAND RENDERING AND LAYOUT ======
    function updateHand() {
      if (window.__hand && typeof window.__hand.updateHand === 'function') {
        window.__hand.updateHand(gameState);
        const ctx = window.__scene && typeof window.__scene.getCtx === 'function'
          ? window.__scene.getCtx() : null;
        if (ctx && ctx.handCardMeshes) {
          handCardMeshes = ctx.handCardMeshes;
        }
      }
      hoveredHandCard = null;
    }

    function setHandCardHoverVisual(mesh, hovered) {
      if (window.__hand && typeof window.__hand.setHandCardHoverVisual === 'function') {
        window.__hand.setHandCardHoverVisual(mesh, hovered);
      }
    }

    async function animateDrawnCardToHand(cardTpl) {
      if (window.__hand && typeof window.__hand.animateDrawnCardToHand === 'function') {
        return window.__hand.animateDrawnCardToHand(cardTpl);
      }
    }

    // Синхронизирует 3D-модели юнитов с текущим состоянием gameState
    function updateUnits(stateOverride = null) {
      const stateToRender = stateOverride || gameState;
      if (!stateToRender) return;
      if (window.__units && typeof window.__units.updateUnits === 'function') {
        window.__units.updateUnits(stateToRender);
        const ctx = window.__scene && typeof window.__scene.getCtx === 'function'
          ? window.__scene.getCtx() : null;
        if (ctx && ctx.unitMeshes) {
          unitMeshes = ctx.unitMeshes;
          try { window.unitMeshes = unitMeshes; } catch {}
        }
      }
    }
    try { window.updateUnits = updateUnits; } catch {}

    // Визуализировать изменения между предыдущим и новым состоянием (для наблюдателя/оппонента)
    // Показывает визуальные различия на поле между предыдущим и новым состоянием
      // Анимации различий между состояниями вынесены в scene/delta.js

        // Взаимодействия с 3D-сценой вынесены в модуль src/scene/interactions.js
    
    async function initGame() {
      const decks = window.DECKS || [];
      let chosen = window.__selectedDeckObj;
      if (!chosen) {
        try {
          const id = localStorage.getItem('selectedDeckId');
          chosen = decks.find(d => d.id === id) || decks[0];
        } catch {
          chosen = decks[0];
        }
      }
      const myDeck = chosen ? chosen.cards : (decks[0]?.cards || []);
      let oppDeck = myDeck;
      try {
        const oppId = window.__opponentDeckId;
        if (oppId) {
          const found = decks.find(d => d.id === oppId);
          if (found) oppDeck = found.cards;
        }
      } catch {}
      const fallbackSeatName = (seat) => `Player ${seat + 1}`;
      const matchPlayersSnapshot = Array.isArray(window.__matchPlayers) ? window.__matchPlayers : [];
      let playerProfiles;
      if (matchPlayersSnapshot.length >= 2) {
        playerProfiles = [0, 1].map(index => {
          const entry = matchPlayersSnapshot[index] || {};
          const displayName = typeof entry.displayName === 'string' && entry.displayName.trim()
            ? entry.displayName.trim()
            : null;
          const nickname = typeof entry.nickname === 'string' && entry.nickname.trim()
            ? entry.nickname.trim()
            : null;
          const explicitName = typeof entry.name === 'string' && entry.name.trim()
            ? entry.name.trim()
            : null;
          const resolvedName = displayName || nickname || explicitName || fallbackSeatName(index);
          const id = typeof entry.id === 'string' && entry.id.trim() ? entry.id.trim() : null;
          return { id, name: resolvedName, nickname };
        });
      } else {
        const activeUser = (window.__auth && typeof window.__auth.getActiveUser === 'function')
          ? window.__auth.getActiveUser()
          : null;
        const rawNickname = activeUser?.nickname && activeUser.nickname.trim() ? activeUser.nickname.trim() : null;
        const rawEmail = activeUser?.email && activeUser.email.trim() ? activeUser.email.trim() : null;
        const myName = rawNickname || rawEmail || fallbackSeatName(0);
        playerProfiles = [
          { id: activeUser?.id || null, name: myName, nickname: rawNickname },
          { id: null, name: fallbackSeatName(1), nickname: null },
        ];
      }
      try { window.__net?.setMatchPlayers?.(playerProfiles); } catch {}
      try { window.__matchPlayers = playerProfiles.map(p => ({ ...p })); } catch {}
      gameState = startGame(myDeck, oppDeck, { players: playerProfiles });
      try { window.applyGameState(gameState); } catch {}
      
      // Сразу строим сцену и мета-объекты, без задержки появления
      createBoard();
      createMetaObjects(gameState);
      updateUnits();
      updateHand();
      updateUI();
      // Заставка хода при старте игры с резервом (ускорена)
        try {
          if (window.__ui && window.__ui.banner) {
            const b = window.__ui.banner; const t = gameState?.turn;
            const fn = (typeof b.ensureTurnSplashVisible === 'function') ? b.ensureTurnSplashVisible : b.forceTurnSplashWithRetry;
            await fn.call(b, 2, t);
          }
        } catch {}
      // Запуск таймера на первом ходу
      try { if (window.__turnTimerId) clearInterval(window.__turnTimerId); } catch {}
      window.__turnTimerSeconds = 100;
      (function syncBtn(){ try {
        const btn = document.getElementById('end-turn-btn');
        if (btn) {
          const fill = btn.querySelector('.time-fill');
          const txt = btn.querySelector('.sec-text');
          if (txt) txt.textContent = `${window.__turnTimerSeconds}`;
          if (fill) fill.style.top = `0%`;
        }
      } catch {} })();
      try {
        if (window.__ui && window.__ui.turnTimer) {
          const tt = window.__ui.turnTimer.attach('end-turn-btn');
          const online = (typeof NET_ON === 'function') ? NET_ON() : !!(typeof NET_ACTIVE !== 'undefined' && NET_ACTIVE);
          if (online) { tt.stop(); } else { tt.reset(100).start(); }
        }
      } catch {}
      
      const firstPlayerName = playerProfiles[0]?.name || 'Player 1';
      addLog(`The game has begun! ${firstPlayerName} goes first.`);
      addLog('Drag units to the field, use spells by clicking.');
    }
    
    // endTurn перенесён в ui/actions.js
    
    function animate() {
      if (window.__scene && typeof window.__scene.animate === 'function') {
        window.__scene.animate();
      }
    }

    function wireModules() {
      try {
        DIR_VECTORS = window.DIR_VECTORS; OPPOSITE_ELEMENT = window.OPPOSITE_ELEMENT; elementEmoji = window.elementEmoji;
        turnCW = window.turnCW; turnCCW = window.turnCCW; facingDeg = window.facingDeg;
        uid = window.uid; inBounds = window.inBounds; capMana = window.capMana; attackCost = window.attackCost; rotateCost = window.rotateCost;
        CARDS = window.CARDS; DECKS = window.DECKS || [];
        computeCellBuff = window.computeCellBuff; effectiveStats = window.effectiveStats;
        hasAdjacentGuard = window.hasAdjacentGuard; computeHits = window.computeHits; stagedAttack = window.stagedAttack; magicAttack = window.magicAttack;
        shuffle = window.shuffle; drawOne = window.drawOne; drawOneNoAdd = window.drawOneNoAdd; countControlled = window.countControlled; startGame = window.startGame;
      } catch {}
    }

      function init() {
        wireModules();
        initThreeJS();
        // Запускаем рендер заранее, но игру инициализируем позже,
        // когда игрок выберет режим и колоду
        animate();
        // Привязка обработчиков взаимодействия теперь в модуле interactions
        window.__interactions.setupInteractions();
        try { window.attachUIEvents && window.attachUIEvents(); } catch {}
      }
    try { window.init = init; window.initThreeJS = initThreeJS; window.initGame = initGame; window.animate = animate; } catch {}

    // UI wrappers: use modules only
    try { showNotification = (message, type) => window.__ui.notifications.show(message, type); } catch {}
    try { addLog = (message) => window.__ui.log.add(message); } catch {}
    try { animateManaGainFromWorld = (pos, ownerIndex, visualOnly) => window.__ui.mana.animateManaGainFromWorld(pos, ownerIndex, visualOnly); } catch {}
    // animateTurnManaGain теперь вызывается напрямую через модуль
      

    // Создание колод и кладбищ вынесено в scene/meta.js

    // Обработчики UI перенесены в ui/domEvents.js
    document.addEventListener('DOMContentLoaded', init);

      /* UI action helpers moved to src/ui/actions.js */
    
    /* MODULE: core/battleSequence
       Combines combat resolution, animations and network sync.
       Split into logic (src/core/battle.js), FX (src/scene/battleFx.js)
       and net sync (src/net/battleSync.js). */
    async function performBattleSequence(r, c, markAttackTurn, opts = {}) {
      const unitBefore = gameState.board?.[r]?.[c]?.unit;
      const tplBefore = unitBefore ? CARDS[unitBefore.tplId] : null;
      const attackerName = tplBefore?.name || 'Существо';
      const staged = stagedAttack(gameState, r, c, opts);
      if (!staged || staged.empty) return;
      // flashy заставка BATTLE (сокращённая)
      await showBattleSplash();

      let aMesh = unitMeshes.find(m => m.userData.row === r && m.userData.col === c);
      if (staged.quickRetaliation > 0) {
        const quickers = staged.quickRetaliators || [];
        let maxQ = 0;
        for (const qr of quickers) {
          const rMesh = unitMeshes.find(m => m.userData.row === qr.r && m.userData.col === qr.c);
          const aMeshLive = unitMeshes.find(m => m.userData.row === r && m.userData.col === c);
          if (rMesh && aMeshLive) {
            const dirQ = new THREE.Vector3().subVectors(aMeshLive.position, rMesh.position).normalize();
            const pushQ = { x: dirQ.x * 0.6, z: dirQ.z * 0.6 };
            const tlQ = gsap.timeline();
            tlQ.to(rMesh.position, { x: `+=${pushQ.x}`, z: `+=${pushQ.z}`, duration: 0.22, ease: 'power2.out' })
               .to(rMesh.position, { x: `-=${pushQ.x}`, z: `-=${pushQ.z}`, duration: 0.30, ease: 'power2.inOut' });
            maxQ = Math.max(maxQ, 0.52);
          }
        }
        await sleep(Math.max(0, maxQ * 1000 + 160));
        staged.stepQuick();
        if (aMesh) {
          window.__fx.shakeMesh(aMesh, 6, 0.14);
          window.__fx.spawnDamageText(aMesh, `-${staged.quickRetaliation}`, '#ffd166');
        }
        gameState = staged.nQuick;
        try { window.applyGameState(gameState); } catch {}
        updateUnits();
        aMesh = unitMeshes.find(m => m.userData.row === r && m.userData.col === c);
        try {
          const shouldSend = (typeof window !== 'undefined' && window.socket && (typeof NET_ACTIVE !== 'undefined' ? NET_ACTIVE : false) && (typeof MY_SEAT !== 'undefined' ? MY_SEAT : null) === gameState.active);
          if (shouldSend) {
            window.socket.emit('battleRetaliation', {
              attacker: { r, c },
              retaliators: quickers.map(q => ({ r: q.r, c: q.c })),
              total: staged.quickRetaliation,
              bySeat: typeof window.MY_SEAT === 'number' ? window.MY_SEAT : null
            });
          }
        } catch (e) { console.error('[battleQuick] Error sending battleRetaliation:', e); }
      }

      const hitsPrev = (staged.targetsPreview || computeHits(gameState, r, c, opts));
      if (!staged.attackerQuick) {
        const A = gameState.board?.[r]?.[c]?.unit;
        const tplA = A ? CARDS[A.tplId] : null;
        const hpA = A ? (A.currentHP ?? tplA.hp) : 0;
        if (hpA <= 0) hitsPrev.length = 0;
      }
      const fromPos = (aMesh ? aMesh.position.clone() : tileMeshes[r][c].position.clone().add(new THREE.Vector3(0, 0.8, 0)));
      const tplAttacker = gameState.board?.[r]?.[c]?.unit ? CARDS[gameState.board[r][c].unit.tplId] : null;
      const attackerDouble = tplAttacker && tplAttacker.doubleAttack;

      const doStep1 = () => {
        // Убраны жёлтые лучи/стрелки под картами
        // Применяем урон (этап 1) и перерисовываем юниты
        staged.step1();
        gameState = staged.n1;
        try { window.applyGameState(gameState); } catch {}
        updateUnits();
        // Тряска и всплывающий урон — уже по актуальным мешам после обновления
        for (const h of hitsPrev) {
          const tMesh = unitMeshes.find(m => m.userData.row === h.r && m.userData.col === h.c);
          if (tMesh) {
            window.__fx.shakeMesh(tMesh, 6, 0.12);
            window.__fx.spawnDamageText(tMesh, `-${h.dmg}`, '#ff5555');
            if (attackerDouble) {
              setTimeout(() => {
                window.__fx.shakeMesh(tMesh, 6, 0.12);
                window.__fx.spawnDamageText(tMesh, `-${h.dmg}`, '#ff5555');
              }, 300);
            }
          }
        }
        setTimeout(async () => {
          // Сокращённая пауза перед контратакой
          await sleep(700);
          const ret = staged.step2() || { total: 0, retaliators: [] };
          const retaliation = typeof ret === 'number' ? ret : (ret.total || 0);
          const retaliators = Array.isArray(ret?.retaliators) ? ret.retaliators : [];
          const shouldAnimateRetaliation = retaliators.length > 0;
          let animDelayMs = 0;
          if (shouldAnimateRetaliation) {
            // Выпад всех контратакующих
            let maxDur = 0;
            for (const rrObj of retaliators) {
              const rMesh = unitMeshes.find(m => m.userData.row === rrObj.r && m.userData.col === rrObj.c);
              // Пересчитаем актуальный меш атакующего после обновления юнитов
              const aMeshLive = unitMeshes.find(m => m.userData.row === r && m.userData.col === c) || aMesh;
              if (rMesh && aMeshLive) {
                const dir2 = new THREE.Vector3().subVectors(aMeshLive.position, rMesh.position).normalize();
                const push2 = { x: dir2.x * 0.6, z: dir2.z * 0.6 };
                const tl2 = gsap.timeline();
                tl2.to(rMesh.position, { x: `+=${push2.x}`, z: `+=${push2.z}`, duration: 0.22, ease: 'power2.out' })
                   .to(rMesh.position, { x: `-=${push2.x}`, z: `-=${push2.z}`, duration: 0.30, ease: 'power2.inOut' });
                maxDur = Math.max(maxDur, 0.52);
              }
            }
            // После лунжей контратаки — тряска и числа урона по атакующему
            setTimeout(() => {
              const aLive = unitMeshes.find(m => m.userData.row === r && m.userData.col === c) || aMesh;
              if (aLive) {
                window.__fx.shakeMesh(aLive, 6, 0.14);
                window.__fx.spawnDamageText(aLive, `-${retaliation}`, '#ffd166');
              }
            }, Math.max(0, maxDur * 1000 - 10));
            animDelayMs = Math.max(animDelayMs, Math.floor(maxDur * 1000) + 160);
            // Синхронизация контратаки для наблюдателя
            try {
              const shouldSend = (typeof window !== 'undefined' && window.socket && (typeof NET_ACTIVE !== 'undefined' ? NET_ACTIVE : false) && (typeof MY_SEAT !== 'undefined' ? MY_SEAT : null) === gameState.active);
              console.log('[battleRetaliation] Checking if should send:', {
                hasWindow: typeof window !== 'undefined',
                hasSocket: !!(typeof window !== 'undefined' && window.socket),
                NET_ACTIVE: typeof NET_ACTIVE !== 'undefined' ? NET_ACTIVE : 'undefined',
                MY_SEAT: typeof MY_SEAT !== 'undefined' ? MY_SEAT : 'undefined',
                gameStateActive: gameState.active,
                seatMatches: (typeof MY_SEAT !== 'undefined' ? MY_SEAT : null) === gameState.active,
                shouldSend,
                retaliation
              });
              if (shouldSend) {
                window.socket.emit('battleRetaliation', {
                  attacker: { r, c },
                  retaliators: retaliators.map(x => ({ r: x.r, c: x.c })),
                  total: retaliation,
                  bySeat: typeof window.MY_SEAT === 'number' ? window.MY_SEAT : null
                });
                console.log('[battleRetaliation] Sent battleRetaliation event', { attacker: { r, c }, retaliators: retaliators.length, total: retaliation });
              }
            } catch (e) {
              console.error('[battleRetaliation] Error sending battleRetaliation:', e);
            }
          }
          // Финализация: анимация смерти и орбы перед применением состояния
          const stateBeforeFinish = gameState ? JSON.parse(JSON.stringify(gameState)) : null;
          const res = staged.finish();
          const manaPlan = window.__scene?.manaFx?.buildManaGainPlan?.({
            playersBefore: stateBeforeFinish?.players || gameState.players,
            deaths: res.deaths || [],
            manaGainEntries: res.manaGainEvents || [],
            tileMeshes,
            THREE: window.THREE,
          });
          const attackerPos = res.attackerPosUpdate || { r, c };
          const pendingFieldquakes = Array.isArray(res.fieldquakes) ? res.fieldquakes.slice() : [];
          if (pendingFieldquakes.length) {
            const nextActive = typeof res?.n1?.active === 'number' ? res.n1.active : gameState?.active;
            const broadcastFx = (typeof NET_ON === 'function' ? NET_ON() : false)
              && typeof MY_SEAT === 'number'
              && typeof nextActive === 'number'
              && MY_SEAT === nextActive;
            try {
              const batchFn = window.playFieldquakeFxBatch
                || ((events, options) => {
                  for (const fq of events) {
                    if (!fq) continue;
                    window.playFieldquakeFx?.(
                      { r: fq.r, c: fq.c, prevElement: fq.prevElement, nextElement: fq.nextElement },
                      options,
                    );
                  }
                });
              batchFn(pendingFieldquakes, { broadcast: broadcastFx });
            } catch {}
          }
          gameState = res.n1;
          const finalState = gameState;
          try { window.applyGameState(finalState); } catch {}
          if (Array.isArray(res.dodgeUpdates) && res.dodgeUpdates.length) {
            try { window.__interactions?.logDodgeUpdates?.(res.dodgeUpdates, finalState, attackerName); } catch {}
          }
          try {
            if (typeof window.playDeltaAnimations === 'function') {
              window.playDeltaAnimations(stateBeforeFinish, finalState, { includeActive: true, skipDeathFx: true });
            }
          } catch {}
          if (res.deaths && res.deaths.length) {
            for (const d of res.deaths) {
              try { gameState.players[d.owner].graveyard.push(CARDS[d.tplId]); } catch {}
              const deadMesh = unitMeshes.find(m => m.userData.row === d.r && m.userData.col === d.c);
              if (deadMesh) {
                const fromMesh = aMesh || deadMesh;
                const dirUp = new THREE.Vector3().subVectors(deadMesh.position, fromMesh.position).normalize().multiplyScalar(0.4);
                window.__fx.dissolveAndAsh(deadMesh, dirUp, 0.9);
              }
              const tplDead = CARDS[d.tplId];
              if (tplDead?.onDeathAddHPAll) {
                window.__interactions?.showOracleDeathBuff?.(d.owner, tplDead.onDeathAddHPAll);
              }
            }
            try { manaPlan?.schedule?.(); } catch {}
            const pos = attackerPos;
            if (markAttackTurn && gameState.board[pos.r]?.[pos.c]?.unit) {
              gameState.board[pos.r][pos.c].unit.lastAttackTurn = gameState.turn;
            }
            setTimeout(() => {
              updateUnits(finalState); updateUI();
              for (const l of res.logLines.reverse()) addLog(l);
              try { schedulePush('battle-finish', { force: true }); } catch {}
              if (window.__interactions?.interactionState?.autoEndTurnAfterAttack) {
                window.__interactions.interactionState.autoEndTurnAfterAttack = false;
                try {
                  if (window.__interactions?.requestAutoEndTurn) {
                    window.__interactions.requestAutoEndTurn();
                  } else {
                    endTurn();
                  }
                } catch {}
              }
            }, 1000);
            setTimeout(() => {
              try { updateUnits(finalState); } catch {}
            }, 1400);
          } else {
            // Если смертей нет — подождём, пока анимация контратаки завершится, затем обновим визуально
        setTimeout(() => {
          updateUnits(finalState); updateUI(); for (const l of res.logLines.reverse()) addLog(l);
          const pos2 = attackerPos;
          if (markAttackTurn && gameState.board[pos2.r]?.[pos2.c]?.unit) {
            gameState.board[pos2.r][pos2.c].unit.lastAttackTurn = gameState.turn;
          }
          try { schedulePush('battle-finish', { force: true }); } catch {}
          if (window.__interactions?.interactionState?.autoEndTurnAfterAttack) {
            window.__interactions.interactionState.autoEndTurnAfterAttack = false;
            try {
              if (window.__interactions?.requestAutoEndTurn) {
                window.__interactions.requestAutoEndTurn();
              } else {
                endTurn();
              }
            } catch {}
          }
            }, Math.max(0, animDelayMs));
            setTimeout(() => {
              try { updateUnits(finalState); } catch {}
            }, Math.max(0, animDelayMs) + 420);
          }
        }, 420);
      };

      // Выпад атакующего перед применением урона
      if (aMesh && hitsPrev.length) {
        const firstTargetMesh = unitMeshes.find(m => m.userData.row === hitsPrev[0].r && m.userData.col === hitsPrev[0].c);
        if (firstTargetMesh) {
          const dir = new THREE.Vector3().subVectors(firstTargetMesh.position, aMesh.position).normalize();
          const push = { x: dir.x * 0.6, z: dir.z * 0.6 };
          const tplA = CARDS[gameState.board[r][c]?.unit?.tplId];
          const isDouble = tplA && tplA.doubleAttack;
          const tl = gsap.timeline({ onComplete: doStep1 });
          tl.to(aMesh.position, { x: `+=${push.x}`, z: `+=${push.z}`, duration: 0.22, ease: 'power2.out' })
            .to(aMesh.position, { x: `-=${push.x}`, z: `-=${push.z}`, duration: 0.3, ease: 'power2.inOut' });
          if (isDouble) {
            tl.to(aMesh.position, { x: `+=${push.x}`, z: `+=${push.z}`, duration: 0.22, ease: 'power2.out' })
              .to(aMesh.position, { x: `-=${push.x}`, z: `-=${push.z}`, duration: 0.3, ease: 'power2.inOut' });
          }
          // Онлайновая синхронизация выпадов (атакующий и цели)
          try {
            const shouldSend = (typeof window !== 'undefined' && window.socket && (typeof NET_ACTIVE !== 'undefined' ? NET_ACTIVE : false) && (typeof MY_SEAT !== 'undefined' ? MY_SEAT : null) === gameState.active);
            console.log('[battleAnim] Checking if should send:', {
              hasWindow: typeof window !== 'undefined',
              hasSocket: !!(typeof window !== 'undefined' && window.socket),
              NET_ACTIVE: typeof NET_ACTIVE !== 'undefined' ? NET_ACTIVE : 'undefined',
              MY_SEAT: typeof MY_SEAT !== 'undefined' ? MY_SEAT : 'undefined',
              gameStateActive: gameState.active,
              seatMatches: (typeof MY_SEAT !== 'undefined' ? MY_SEAT : null) === gameState.active,
              shouldSend
            });
            if (shouldSend) {
              window.socket.emit('battleAnim', {
                attacker: { r, c },
                targets: hitsPrev.map(h => ({ r: h.r, c: h.c, dmg: h.dmg })),
                bySeat: typeof window.MY_SEAT === 'number' ? window.MY_SEAT : null
              });
              console.log('[battleAnim] Sent battleAnim event', { attacker: { r, c }, targets: hitsPrev.length });
            }
          } catch (e) {
            console.error('[battleAnim] Error sending battleAnim:', e);
          }
        } else {
          gsap.to(aMesh.position, { y: aMesh.position.y + 0.25, yoyo: true, repeat: 1, duration: 0.2, onComplete: doStep1 });
        }
      } else {
        doStep1();
      }
    }

    /* Scene effects moved to src/scene/effects.js */
    function performMagicAttack(from, targetMesh) {
      const tr = targetMesh.userData.row; const tc = targetMesh.userData.col;
      const attacker = gameState.board?.[from.r]?.[from.c]?.unit;
      if (!attacker || attacker.lastAttackTurn === gameState.turn) { showNotification('Incorrect target', 'error'); return; }
      const attackerName = CARDS[attacker.tplId]?.name || 'Существо';
      const res = magicAttack(gameState, from.r, from.c, tr, tc);
      if (!res) { showNotification('Incorrect target', 'error'); return; }
      const attackerPosMagic = res.attackerPosUpdate || from;
      for (const l of res.logLines.reverse()) addLog(l);
      const aMesh = unitMeshes.find(m => m.userData.row === from.r && m.userData.col === from.c);
      if (aMesh) { gsap.fromTo(aMesh.position, { y: aMesh.position.y }, { y: aMesh.position.y + 0.3, yoyo: true, repeat: 1, duration: 0.12 }); }
      // вспышка по цели
      const tMesh = unitMeshes.find(m => m.userData.row === tr && m.userData.col === tc);
      if (tMesh) {
        const flashGeom = new THREE.SphereGeometry(0.25, 12, 12);
        const flashMat = new THREE.MeshBasicMaterial({ color: 0xff6666, transparent: true, opacity: 0.8 });
        const flash = new THREE.Mesh(flashGeom, flashMat);
        flash.position.copy(tMesh.position).add(new THREE.Vector3(0, 0.4, 0));
        effectsGroup.add(flash);
        gsap.to(flash.scale, { x: 2, y: 2, z: 2, duration: 0.3 });
        gsap.to(flash.material, { opacity: 0, duration: 0.3, onComplete: ()=> effectsGroup.remove(flash) });
        // тряска цели и всплывающий урон для магии
        window.__fx.shakeMesh(tMesh, 6, 0.12);
        if (typeof res.dmg === 'number' && res.dmg > 0) {
          window.__fx.spawnDamageText(tMesh, `-${res.dmg}`, '#ff5555');
        }
      }
      // Манасфера и кладбище для погибших от магии; обновляем состояние сразу
      if (res.deaths && res.deaths.length) {
        for (const d of res.deaths) {
          try { gameState.players[d.owner].graveyard.push(CARDS[d.tplId]); } catch {}
          const deadMesh = unitMeshes.find(m => m.userData.row === d.r && m.userData.col === d.c);
          if (deadMesh) { window.__fx.dissolveAndAsh(deadMesh, new THREE.Vector3(0, 0, 0.6), 0.9); }
          setTimeout(() => {
            const p = tileMeshes[d.r][d.c].position.clone().add(new THREE.Vector3(0, 1.2, 0));
            // Только визуальный орб; фактическое начисление — в res.n1
            animateManaGainFromWorld(p, d.owner, true);
          }, 400);
          const tplDead = CARDS[d.tplId];
          if (tplDead?.onDeathAddHPAll) {
            window.__interactions?.showOracleDeathBuff?.(d.owner, tplDead.onDeathAddHPAll);
          }
        }
        const pendingFieldquakes = Array.isArray(res.fieldquakes) ? res.fieldquakes.slice() : [];
        if (pendingFieldquakes.length) {
          const nextActive = typeof res?.n1?.active === 'number' ? res.n1.active : gameState?.active;
          const broadcastFx = (typeof NET_ON === 'function' ? NET_ON() : false)
            && typeof MY_SEAT === 'number'
            && typeof nextActive === 'number'
            && MY_SEAT === nextActive;
          try {
            const batchFn = window.playFieldquakeFxBatch
              || ((events, options) => {
                for (const fq of events) {
                  if (!fq) continue;
                  window.playFieldquakeFx?.(
                    { r: fq.r, c: fq.c, prevElement: fq.prevElement, nextElement: fq.nextElement },
                    options,
                  );
                }
              });
            batchFn(pendingFieldquakes, { broadcast: broadcastFx });
          } catch {}
        }
        gameState = res.n1;
        try { window.applyGameState(gameState); } catch {}
        if (Array.isArray(res.dodgeUpdates) && res.dodgeUpdates.length) {
          try { window.__interactions?.logDodgeUpdates?.(res.dodgeUpdates, gameState, attackerName); } catch {}
        }
        const attackerCell = window.gameState?.board?.[attackerPosMagic.r]?.[attackerPosMagic.c];
        const attackerUnit = attackerCell?.unit;
        if (attackerUnit) attackerUnit.lastAttackTurn = window.gameState.turn;
        setTimeout(() => {
          updateUnits(); updateUI();
          try { schedulePush('magic-battle-finish', { force: true }); } catch {}
          if (window.__interactions?.interactionState?.autoEndTurnAfterAttack) {
            window.__interactions.interactionState.autoEndTurnAfterAttack = false;
            try {
              if (window.__interactions?.requestAutoEndTurn) {
                window.__interactions.requestAutoEndTurn();
              } else {
                endTurn();
              }
            } catch {}
          }
        }, 1000);
      } else {
        // Если смертей нет — применяем состояние сразу
        const pendingFieldquakes = Array.isArray(res.fieldquakes) ? res.fieldquakes.slice() : [];
        if (pendingFieldquakes.length) {
          const nextActive = typeof res?.n1?.active === 'number' ? res.n1.active : gameState?.active;
          const broadcastFx = (typeof NET_ON === 'function' ? NET_ON() : false)
            && typeof MY_SEAT === 'number'
            && typeof nextActive === 'number'
            && MY_SEAT === nextActive;
          try {
            const batchFn = window.playFieldquakeFxBatch
              || ((events, options) => {
                for (const fq of events) {
                  if (!fq) continue;
                  window.playFieldquakeFx?.(
                    { r: fq.r, c: fq.c, prevElement: fq.prevElement, nextElement: fq.nextElement },
                    options,
                  );
                }
              });
            batchFn(pendingFieldquakes, { broadcast: broadcastFx });
          } catch {}
        }
        gameState = res.n1; try { window.applyGameState(gameState); } catch {}
        if (Array.isArray(res.dodgeUpdates) && res.dodgeUpdates.length) {
          try { window.__interactions?.logDodgeUpdates?.(res.dodgeUpdates, gameState, attackerName); } catch {}
        }
        updateUnits(); updateUI();
        const attackerCell2 = gameState.board?.[attackerPosMagic.r]?.[attackerPosMagic.c];
        const attackerUnit2 = attackerCell2?.unit;
        if (attackerUnit2) attackerUnit2.lastAttackTurn = gameState.turn;
        try { schedulePush('magic-battle-finish', { force: true }); } catch {}
        if (window.__interactions?.interactionState?.autoEndTurnAfterAttack) {
          window.__interactions.interactionState.autoEndTurnAfterAttack = false;
          try {
            if (window.__interactions?.requestAutoEndTurn) {
              window.__interactions.requestAutoEndTurn();
            } else {
              endTurn();
            }
          } catch {}
        }
      }
    }
    // Вспомогательные утилиты: задержка и яркая заставка BATTLE на 3 секунды
    function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
    // Заставки боя и хода перенесены в ui/battleSplash.js и ui/banner.js
    // (убраны несуществующие обработчики magic-btn и draw-btn)
    </script>
<!-- MODULE: network/multiplayer (socket.io sync, queue, indicator) -->
<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
<script type="module" src="./src/net/client.js"></script>
</body>
</html>
