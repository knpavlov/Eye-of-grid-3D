        gameState.players[gameState.active].mana -= cost;
        updateUI();
        magicFrom = { r, c };
        addLog(`${tpl.name}: select a target for the magical attack.`);
         return;
      }
      const hits = computeHits(gameState, r, c);
      if (!hits.length) { showNotification('No available targets for attack', 'error');  return; }
      if (gameState.players[gameState.active].mana < cost) { showNotification(`${cost} mana is required to attack`, 'error');  return; }
      gameState.players[gameState.active].mana -= cost;
      updateUI();
      performBattleSequence(r, c, true);
       }
    
    async function performBattleSequence(r, c, markAttackTurn) {
      const staged = stagedAttack(gameState, r, c);
      if (!staged || staged.empty) return;
      // flashy заставка BATTLE (сокращённая)
      await showBattleSplash();
      // небольшая анимация выпада/толчка
      const aMesh = unitMeshes.find(m => m.userData.row === r && m.userData.col === c);
      const hitsPrev = (staged.targetsPreview || computeHits(gameState, r, c));
      const fromPos = (aMesh ? aMesh.position.clone() : tileMeshes[r][c].position.clone().add(new THREE.Vector3(0, 0.8, 0)));

      const doStep1 = () => {
        // Убраны жёлтые лучи/стрелки под картами
        // Применяем урон (этап 1) и перерисовываем юниты
        staged.step1();
        gameState = staged.n1; updateUnits();
        // Тряска и всплывающий урон — уже по актуальным мешам после обновления
        for (const h of hitsPrev) {
          const tMesh = unitMeshes.find(m => m.userData.row === h.r && m.userData.col === h.c);
          if (tMesh) { 
            shakeMesh(tMesh, 6, 0.12); 
            spawnDamageText(tMesh, `-${h.dmg}`, '#ff5555');
          }
        }
        setTimeout(async () => {
          // Сокращённая пауза перед контратакой
          await sleep(700);
          const ret = staged.step2() || { total: 0, retaliators: [] };
          const retaliation = typeof ret === 'number' ? ret : (ret.total || 0);
          let animDelayMs = 0;
          if (retaliation > 0) {
            // Выпад всех контратакующих
            const retaliators = (ret.retaliators || []);
            let maxDur = 0;
            for (const rrObj of retaliators) {
              const rMesh = unitMeshes.find(m => m.userData.row === rrObj.r && m.userData.col === rrObj.c);
              // Пересчитаем актуальный меш атакующего после обновления юнитов
              const aMeshLive = unitMeshes.find(m => m.userData.row === r && m.userData.col === c) || aMesh;
              if (rMesh && aMeshLive) {
                const dir2 = new THREE.Vector3().subVectors(aMeshLive.position, rMesh.position).normalize();
                const push2 = { x: dir2.x * 0.6, z: dir2.z * 0.6 };
                const tl2 = gsap.timeline();
                tl2.to(rMesh.position, { x: `+=${push2.x}`, z: `+=${push2.z}`, duration: 0.22, ease: 'power2.out' })
                   .to(rMesh.position, { x: `-=${push2.x}`, z: `-=${push2.z}`, duration: 0.30, ease: 'power2.inOut' });
                maxDur = Math.max(maxDur, 0.52);
              }
            }
            // После лунжей контратаки — тряска и числа урона по атакующему
            setTimeout(() => { 
              const aLive = unitMeshes.find(m => m.userData.row === r && m.userData.col === c) || aMesh; 
              if (aLive) { 
                shakeMesh(aLive, 6, 0.14); 
                spawnDamageText(aLive, `-${retaliation}`, '#ffd166');
              } 
            }, Math.max(0, maxDur * 1000 - 10));
            animDelayMs = Math.max(animDelayMs, Math.floor(maxDur * 1000) + 160);
            // Синхронизация контратаки для наблюдателя
            try {
              const shouldSend = (typeof window !== 'undefined' && window.socket && (typeof NET_ACTIVE !== 'undefined' ? NET_ACTIVE : false) && (typeof MY_SEAT !== 'undefined' ? MY_SEAT : null) === gameState.active);
              console.log('[battleRetaliation] Checking if should send:', {
                hasWindow: typeof window !== 'undefined',
                hasSocket: !!(typeof window !== 'undefined' && window.socket),
                NET_ACTIVE: typeof NET_ACTIVE !== 'undefined' ? NET_ACTIVE : 'undefined',
                MY_SEAT: typeof MY_SEAT !== 'undefined' ? MY_SEAT : 'undefined',
                gameStateActive: gameState.active,
                seatMatches: (typeof MY_SEAT !== 'undefined' ? MY_SEAT : null) === gameState.active,
                shouldSend,
                retaliation
              });
              if (shouldSend) {
                window.socket.emit('battleRetaliation', {
                  attacker: { r, c },
                  retaliators: retaliators.map(x => ({ r: x.r, c: x.c })),
                  total: retaliation,
                  bySeat: typeof window.MY_SEAT === 'number' ? window.MY_SEAT : null
                });
                console.log('[battleRetaliation] Sent battleRetaliation event', { attacker: { r, c }, retaliators: retaliators.length, total: retaliation });
              }
            } catch (e) {
              console.error('[battleRetaliation] Error sending battleRetaliation:', e);
            }
          }
          // Финализация: анимация смерти и орбы перед применением состояния
          const res = staged.finish();
          if (res.deaths && res.deaths.length) {
            for (const d of res.deaths) {
              try { gameState.players[d.owner].graveyard.push(CARDS[d.tplId]); } catch {}
              const deadMesh = unitMeshes.find(m => m.userData.row === d.r && m.userData.col === d.c);
              if (deadMesh) {
                const fromMesh = aMesh || deadMesh;
                const dirUp = new THREE.Vector3().subVectors(deadMesh.position, fromMesh.position).normalize().multiplyScalar(0.4);
                dissolveAndAsh(deadMesh, dirUp, 0.9);
              }
              // Орб маны появляется с задержкой 400мс после начала анимации смерти
              setTimeout(() => {
                const p = tileMeshes[d.r][d.c].position.clone().add(new THREE.Vector3(0, 1.6, 0));
                // Показать визуальный орб у обоих игроков; фактическое начисление маны уже в res.n1
                animateManaGainFromWorld(p, d.owner, true);
              }, 400);
            }
            setTimeout(() => { gameState = res.n1; updateUnits(); updateUI(); for (const l of res.logLines.reverse()) addLog(l); if (markAttackTurn && gameState.board[r][c]?.unit) gameState.board[r][c].unit.lastAttackTurn = gameState.turn; try { schedulePush('battle-finish'); } catch {} }, 1000);
          } else {
            // Если смертей нет — подождём, пока анимация контратаки завершится, затем применим состояние
            setTimeout(() => {
              gameState = res.n1; updateUnits(); updateUI(); for (const l of res.logLines.reverse()) addLog(l); if (markAttackTurn && gameState.board[r][c]?.unit) gameState.board[r][c].unit.lastAttackTurn = gameState.turn; try { schedulePush('battle-finish'); } catch {}
            }, Math.max(0, animDelayMs));
          }
        }, 420);
      };

      // Выпад атакующего перед применением урона
      if (aMesh && hitsPrev.length) {
        const firstTargetMesh = unitMeshes.find(m => m.userData.row === hitsPrev[0].r && m.userData.col === hitsPrev[0].c);
        if (firstTargetMesh) {
          const dir = new THREE.Vector3().subVectors(firstTargetMesh.position, aMesh.position).normalize();
          const push = { x: dir.x * 0.6, z: dir.z * 0.6 };
          const tl = gsap.timeline({ onComplete: doStep1 });
          tl.to(aMesh.position, { x: `+=${push.x}`, z: `+=${push.z}`, duration: 0.22, ease: 'power2.out' })
            .to(aMesh.position, { x: `-=${push.x}`, z: `-=${push.z}`, duration: 0.3, ease: 'power2.inOut' });
          // Онлайновая синхронизация выпадов (атакующий и цели)
          try {
            const shouldSend = (typeof window !== 'undefined' && window.socket && (typeof NET_ACTIVE !== 'undefined' ? NET_ACTIVE : false) && (typeof MY_SEAT !== 'undefined' ? MY_SEAT : null) === gameState.active);
            console.log('[battleAnim] Checking if should send:', {
              hasWindow: typeof window !== 'undefined',
              hasSocket: !!(typeof window !== 'undefined' && window.socket),
              NET_ACTIVE: typeof NET_ACTIVE !== 'undefined' ? NET_ACTIVE : 'undefined',
              MY_SEAT: typeof MY_SEAT !== 'undefined' ? MY_SEAT : 'undefined',
              gameStateActive: gameState.active,
              seatMatches: (typeof MY_SEAT !== 'undefined' ? MY_SEAT : null) === gameState.active,
              shouldSend
            });
            if (shouldSend) {
              window.socket.emit('battleAnim', {
                attacker: { r, c },
                targets: hitsPrev.map(h => ({ r: h.r, c: h.c, dmg: h.dmg })),
                bySeat: typeof window.MY_SEAT === 'number' ? window.MY_SEAT : null
              });
              console.log('[battleAnim] Sent battleAnim event', { attacker: { r, c }, targets: hitsPrev.length });
            }
          } catch (e) {
            console.error('[battleAnim] Error sending battleAnim:', e);
          }
        } else {
          gsap.to(aMesh.position, { y: aMesh.position.y + 0.25, yoyo: true, repeat: 1, duration: 0.2, onComplete: doStep1 });
        }
      } else {
        doStep1();
      }
    }

    function spawnDamageText(targetMesh, text, color = '#ff5555') {
      const canvas = document.createElement('canvas');
      canvas.width = 256; canvas.height = 128;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0,0,canvas.width, canvas.height);
      ctx.font = 'bold 64px Arial';
      ctx.fillStyle = color;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.lineWidth = 6;
      ctx.strokeText(text, canvas.width/2, canvas.height/2);
      ctx.fillText(text, canvas.width/2, canvas.height/2);
      const tex = new THREE.CanvasTexture(canvas);
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, opacity: 0, depthTest: false, depthWrite: false });
      const sprite = new THREE.Sprite(mat);
      sprite.scale.set(2.6, 1.4, 1);
      const pos = targetMesh.position.clone().add(new THREE.Vector3(0, 0.9, 0));
      sprite.position.copy(pos);
      sprite.renderOrder = 999;
      effectsGroup.add(sprite);
      const tl = gsap.timeline({ onComplete: () => { effectsGroup.remove(sprite); tex.dispose(); mat.dispose(); } });
      // 0.5с вылет, 1с стоп, 0.5с испарение
      tl.to(sprite.material, { opacity: 1, duration: 0.05 })
        .to(sprite.position, { y: sprite.position.y + 0.8, duration: 0.5, ease: 'power1.out' })
        .to({}, { duration: 1.0 })
        .to(sprite.position, { y: sprite.position.y + 1.6, duration: 0.5, ease: 'power1.in' }, 'end')
        .to(sprite.material, { opacity: 0, duration: 0.5 }, 'end');
    }

    function shakeMesh(mesh, times = 3, duration = 0.1) {
      const tl = gsap.timeline();
      const ox = mesh.position.x; const oz = mesh.position.z;
      for (let i = 0; i < times; i++) {
        const dx = (Math.random()*0.2 - 0.1);
        const dz = (Math.random()*0.2 - 0.1);
        tl.to(mesh.position, { x: ox + dx, z: oz + dz, duration: duration/2 })
          .to(mesh.position, { x: ox, z: oz, duration: duration/2 });
      }
      return tl;
    }
