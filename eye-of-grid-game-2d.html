<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Eye of Grid ‚Äî 3D –ö–∞—Ä—Ç–æ—á–Ω–∞—è –ò–≥—Ä–∞</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, Fragment } = React;
    // –•—Ä–∞–Ω–∏–ª–∏—â–µ –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã—Ö —Ç–µ–∫—Å—Ç—É—Ä –≤ –ø–∞–º—è—Ç–∏/LocalStorage
    window.TILE_DATAURL = window.TILE_DATAURL || {};
    function preferStoredOrLoad(key, candidates) {
      const lsKey = 'TILE_'+key;
      const fromLS = localStorage.getItem(lsKey);
      if (fromLS && typeof fromLS === 'string' && fromLS.startsWith('data:')) {
        window.TILE_DATAURL[key] = fromLS;
        return Promise.resolve(fromLS);
      }
      // –ø—Ä–æ–±—É–µ–º –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑ —Ñ–∞–π–ª–æ–≤ (png –∑–∞—Ç–µ–º jpg), –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ dataURL –∏ –∫–µ—à–∏—Ä—É–µ–º
      return new Promise((resolve) => {
        const tryNext = (i) => {
          if (i >= candidates.length) { resolve(''); return; }
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => {
            try {
              const canvas = document.createElement('canvas');
              canvas.width = img.naturalWidth; canvas.height = img.naturalHeight;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0);
              const data = canvas.toDataURL('image/png');
              window.TILE_DATAURL[key] = data;
              try { localStorage.setItem(lsKey, data); } catch { /* ignore */ }
              resolve(data);
            } catch { resolve(''); }
          };
          img.onerror = () => tryNext(i+1);
          img.src = candidates[i];
        };
        tryNext(0);
      });
    }

    // –¢–∏–ø—ã –∏ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã
    const DIR_VECTORS = { N: [-1, 0], E: [0, 1], S: [1, 0], W: [0, -1] };
    const OPPOSITE_ELEMENT = { FIRE: "WATER", WATER: "FIRE", EARTH: "FOREST", FOREST: "EARTH" };
    const dirIcon = { N: "‚Üë", E: "‚Üí", S: "‚Üì", W: "‚Üê" };
    const elementEmoji = { FIRE: "üî•", WATER: "üíß", EARTH: "ü™®", FOREST: "üå≤" };
    const uid = () => Math.random().toString(36).slice(2, 9);
    const turnCW = { N: "E", E: "S", S: "W", W: "N" };
    const turnCCW = { N: "W", W: "S", S: "E", E: "N" };
    const facingDeg = { N: 0, E: 90, S: 180, W: 270 };

    const CARDS = {
      SALAMANDER: { id: "SALAMANDER", name: "–°–∞–ª–∞–º–∞–Ω–¥—Ä–∞ –ö–æ–ø–µ–π—â–∏—Ü–∞", type: "UNIT", cost: 2, element: "FIRE", atk: 2, hp: 2, pattern: "FRONT", keywords: [] },
      PYROMANCER: { id: "PYROMANCER", name: "–ü–∏—Ä–æ–º–∞–Ω—Ç", type: "UNIT", cost: 3, element: "FIRE", atk: 2, hp: 3, pattern: "FRONT_SIDES", keywords: [] },
      NAIAD: { id: "NAIAD", name: "–ù–∞—è–¥–∞-–õ–µ–∫–∞—Ä—å", type: "UNIT", cost: 2, element: "WATER", atk: 1, hp: 3, pattern: "SIDES", keywords: [] },
      GOLEM: { id: "GOLEM", name: "–ì–æ–ª–µ–º-–ë–∞—Å—Ç–∏–æ–Ω", type: "UNIT", cost: 4, element: "EARTH", atk: 2, hp: 5, pattern: "FRONT_SIDES", keywords: ["GUARD"] },
      DRYAD: { id: "DRYAD", name: "–î—Ä–∏–∞–¥–∞", type: "UNIT", cost: 3, element: "FOREST", atk: 3, hp: 2, pattern: "SIDES", keywords: [] },
      FREEZE_STREAM: { id: "FREEZE_STREAM", name: "–°—Ç—ã–ª—ã–π –ø–æ—Ç–æ–∫", type: "SPELL", cost: 2, element: "WATER", text: "–ù–∞–Ω–æ—Å–∏—Ç 1 —É—Ä–æ–Ω–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–º—É —é–Ω–∏—Ç—É." },
      RAISE_STONE: { id: "RAISE_STONE", name: "–ü–æ–¥—ä—ë–º –ø–æ—Ä–æ–¥—ã", type: "SPELL", cost: 2, element: "EARTH", text: "+2 HP –¥—Ä—É–∂–µ—Å—Ç–≤–µ–Ω–Ω–æ–º—É —é–Ω–∏—Ç—É." },
      WIND_SHIFT: { id: "WIND_SHIFT", name: "–õ–µ—Å–Ω–æ–π –ø–æ—Ä—ã–≤", type: "SPELL", cost: 2, element: "FOREST", text: "–ü–æ–≤–µ—Ä–Ω—É—Ç—å –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —é–Ω–∏—Ç–∞ –ø–æ —á–∞—Å–æ–≤–æ–π —Å—Ç—Ä–µ–ª–∫–µ." },
      // FIRE SET
      FIRE_FLAME_MAGUS: { id:'FIRE_FLAME_MAGUS', name:'Flame Magus', type:'UNIT', cost:1, activation:1, element:'FIRE', atk:1, hp:1, pattern:'FRONT', range:3, attackType:'MAGIC', blindspots:['N','E','S','W'], desc:'Magic Attack: target any creature; no retaliation.' },
      FIRE_HELLFIRE_SPITTER: { id:'FIRE_HELLFIRE_SPITTER', name:'Hellfire Spitter', type:'UNIT', cost:1, activation:1, element:'FIRE', atk:1, hp:1, pattern:'ALL', range:1, firstStrike:true, blindspots:[], desc:'Quickness: always strikes first.' },
      FIRE_FREEDONIAN: { id:'FIRE_FREEDONIAN', name:'Freedonian Wanderer', type:'UNIT', cost:2, activation:1, element:'FIRE', atk:1, hp:2, pattern:'FRONT', range:1, blindspots:['S'], auraGainManaOnSummon:true, desc:'While not on Fire tile, you gain 1 mana on allied summon.' },
      FIRE_FLAME_LIZARD: { id:'FIRE_FLAME_LIZARD', name:'Partmole Flame Lizard', type:'UNIT', cost:2, activation:1, element:'FIRE', atk:2, hp:2, pattern:'FRONT', range:1, blindspots:['S'], firstStrike:true, desc:'Quickness.' },
      FIRE_GREAT_MINOS: { id:'FIRE_GREAT_MINOS', name:'Great Minos of Sciondar', type:'UNIT', cost:3, activation:2, element:'FIRE', atk:2, hp:1, pattern:'FRONT', range:2, blindspots:['S'], dodge50:true, diesOffElement:'FIRE', desc:'Dodge 50% (non-magic). Destroy if not on Fire tile.' },
      FIRE_FLAME_ASCETIC: { id:'FIRE_FLAME_ASCETIC', name:'Flame Ascetic', type:'UNIT', cost:3, activation:2, element:'FIRE', atk:2, hp:3, pattern:'FRONT', range:1, blindspots:['S'], randomPlus2:true, desc:'Attack +2 half the time.' },
      FIRE_TRICEPTAUR: { id:'FIRE_TRICEPTAUR', name:'Triceptaur Behemoth', type:'UNIT', cost:5, activation:4, element:'FIRE', atk:5, hp:4, pattern:'FRONT_SIDES', range:1, blindspots:['S'], penaltyByTargets:true, desc:'If attacks 2 creatures, -2 ATK; if 3 creatures, -4 ATK.' },
      FIRE_PURSUER: { id:'FIRE_PURSUER', name:'Pursuer of Saint Dhees', type:'UNIT', cost:6, activation:3, element:'FIRE', atk:5, hp:4, pattern:'FRONT', range:1, blindspots:['S'], dynamicAtk:'OTHERS_ON_BOARD', desc:'ATK = 5 + number of other creatures on board.' },
    };

    const STARTER_TEMPO = [
      CARDS.SALAMANDER, CARDS.SALAMANDER, CARDS.SALAMANDER,
      CARDS.PYROMANCER, CARDS.PYROMANCER, CARDS.PYROMANCER,
      CARDS.DRYAD, CARDS.DRYAD, CARDS.DRYAD,
      CARDS.GOLEM,
      CARDS.NAIAD, CARDS.NAIAD,
      CARDS.FREEZE_STREAM, CARDS.FREEZE_STREAM,
      CARDS.WIND_SHIFT, CARDS.WIND_SHIFT,
      CARDS.RAISE_STONE, CARDS.RAISE_STONE,
      CARDS.SALAMANDER, CARDS.PYROMANCER, CARDS.DRYAD,
    ];

    const STARTER_CONTROL = [
      CARDS.GOLEM, CARDS.GOLEM,
      CARDS.NAIAD, CARDS.NAIAD, CARDS.NAIAD,
      CARDS.SALAMANDER, CARDS.SALAMANDER,
      CARDS.DRYAD, CARDS.DRYAD,
      CARDS.RAISE_STONE, CARDS.RAISE_STONE, CARDS.RAISE_STONE,
      CARDS.FREEZE_STREAM, CARDS.FREEZE_STREAM,
      CARDS.WIND_SHIFT, CARDS.WIND_SHIFT,
      CARDS.PYROMANCER, CARDS.SALAMANDER, CARDS.NAIAD,
    ];

    // –ù–æ–≤–∞—è –æ–≥–Ω–µ–Ω–Ω–∞—è –∫–æ–ª–æ–¥–∞
    const STARTER_FIRESET = [
      // 001 Flame Magus ‚Äî –º–∞–≥–∏—á–µ—Å–∫–∞—è –∞—Ç–∞–∫–∞ –ø–æ –ª—é–±–æ–π —Ü–µ–ª–∏; blindspots –≤—Å–µ —Å—Ç–æ—Ä–æ–Ω—ã
      { id:'FIRE_FLAME_MAGUS', name:'Flame Magus', type:'UNIT', cost:1, activation:1, element:'FIRE', atk:1, hp:1, pattern:'FRONT', range:1, attackType:'MAGIC', blindspots:['N','E','S','W'], keywords:['Magic'] },
      // 002 Hellfire Spitter ‚Äî melee all sides, Quickness, –±–µ–∑ blindspot
      { id:'FIRE_HELLFIRE_SPITTER', name:'Hellfire Spitter', type:'UNIT', cost:1, activation:1, element:'FIRE', atk:1, hp:1, pattern:'ALL', range:1, firstStrike:true, blindspots:[] , keywords:['Quickness']},
      // 003 Freedonian Wanderer ‚Äî —Ñ—Ä–æ–Ω—Ç, –∞—É—Ä–∞ +1 –º–∞–Ω–∞ –ø—Ä–∏ –ø—Ä–∏–∑—ã–≤–µ –µ—Å–ª–∏ Wanderer –Ω–µ –Ω–∞ –æ–≥–Ω–µ
      { id:'FIRE_FREEDONIAN', name:'Freedonian Wanderer', type:'UNIT', cost:2, activation:1, element:'FIRE', atk:1, hp:2, pattern:'FRONT', range:1, blindspots:['S'], auraGainManaOnSummon:true, keywords:['Aura'] },
      // 004 Partmole Flame Lizard ‚Äî —Ñ—Ä–æ–Ω—Ç, dmg 2, Quickness
      { id:'FIRE_FLAME_LIZARD', name:'Partmole Flame Lizard', type:'UNIT', cost:2, activation:1, element:'FIRE', atk:2, hp:2, pattern:'FRONT', range:1, blindspots:['S'], firstStrike:true, keywords:['Quickness'] },
      // 006 Great Minos of Sciondar ‚Äî —Ñ—Ä–æ–Ω—Ç –Ω–∞ 2 –∫–ª–µ—Ç–∫–∏, Dodge 50%, —É–º–∏—Ä–∞–µ—Ç –µ—Å–ª–∏ –Ω–µ –Ω–∞ –æ–≥–Ω–µ
      { id:'FIRE_GREAT_MINOS', name:'Great Minos of Sciondar', type:'UNIT', cost:3, activation:2, element:'FIRE', atk:2, hp:1, pattern:'FRONT', range:2, blindspots:['S'], dodge50:true, diesOffElement:'FIRE', keywords:['Dodge'] },
      // 007 Flame Ascetic ‚Äî –∞—Ç–∞–∫–∞ 2+, 50% —à–∞–Ω—Å +2
      { id:'FIRE_FLAME_ASCETIC', name:'Flame Ascetic', type:'UNIT', cost:3, activation:2, element:'FIRE', atk:2, hp:3, pattern:'FRONT', range:1, blindspots:['S'], randomPlus2:true, keywords:['2+'] },
      // 011 Triceptaur Behemoth ‚Äî —Ñ—Ä–æ–Ω—Ç –∏ —Å—Ç–æ—Ä–æ–Ω—ã, —à—Ç—Ä–∞—Ñ –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É —Ü–µ–ª–µ–π
      { id:'FIRE_TRICEPTAUR', name:'Triceptaur Behemoth', type:'UNIT', cost:5, activation:4, element:'FIRE', atk:5, hp:4, pattern:'FRONT_SIDES', range:1, blindspots:['S'], penaltyByTargets:true, keywords:['Heavy'] },
      // 012 Pursuer of Saint Dhees ‚Äî 5 + –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥—Ä—É–≥–∏—Ö —Å—É—â–µ—Å—Ç–≤ –Ω–∞ –ø–æ–ª–µ
      { id:'FIRE_PURSUER', name:'Pursuer of Saint Dhees', type:'UNIT', cost:6, activation:3, element:'FIRE', atk:5, hp:4, pattern:'FRONT', range:1, blindspots:['S'], dynamicAtk:'OTHERS_ON_BOARD', keywords:['Scaling'] },
    ];

    // –£—Ç–∏–ª–∏—Ç—ã
    const dirsForPattern = (facing, p) => {
      const f = facing, l = turnCCW[f], r = turnCW[f];
      if (p === "FRONT") return [f];
      if (p === "SIDES") return [l, r];
      if (p === "ALL") return ["N", "E", "S", "W"];
      return [f, l, r];
    };

    const computeCellBuff = (cell, unit) => {
      if (cell === unit) return { atk: 0, hp: 2 };
      const opp = OPPOSITE_ELEMENT[unit];
      if (cell === opp) return { atk: 0, hp: -2 };
      return { atk: 0, hp: 0 };
    };

    const effectiveStats = (cell, u) => {
      const tpl = CARDS[u.tplId];
      const b = computeCellBuff(cell.element, tpl.element);
      return { atk: (tpl.atk || 0) + b.atk, hp: (tpl.hp || 0) + b.hp };
    };

    const randomBoard = () => {
      const pool = ["FIRE", "WATER", "EARTH", "FOREST"];
      return Array.from({ length: 3 }, () => 
        Array.from({ length: 3 }, () => ({ 
          element: pool[Math.floor(Math.random() * pool.length)] 
        }))
      );
    };

    const inBounds = (r, c) => r >= 0 && r < 3 && c >= 0 && c < 3;
    const capMana = (m) => Math.min(10, m);
    const attackCost = (tpl) => (tpl.activation != null ? tpl.activation : Math.max(0, (tpl.cost || 0) - 1));

    const sanitizeDeck = (d) => d.filter((x) => !!x && typeof x.id === "string");
    const countControlled = (gs, p) => {
      let n = 0;
      for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 3; c++) {
          if (gs.board[r][c].unit?.owner === p) n++;
        }
      }
      return n;
    };

    const drawOne = (gs, p) => {
      if (!gs.players[p].deck.length) return;
      const top = gs.players[p].deck.shift();
      if (top) gs.players[p].hand.push(top);
    };

    const shuffle = (a) => {
      const r = [...a];
      for (let i = r.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [r[i], r[j]] = [r[j], r[i]];
      }
      return r;
    };

    const startGame = (d0, d1) => {
      const gs = {
        board: randomBoard(),
        players: [
          { name: "–ò–≥—Ä–æ–∫ A", deck: sanitizeDeck(shuffle(d0)), hand: [], discard: [], mana: 2 },
          { name: "–ò–≥—Ä–æ–∫ B", deck: sanitizeDeck(shuffle(d1)), hand: [], discard: [], mana: 0 }
        ],
        active: 0,
        turn: 1,
        selectedCard: null,
        pending: null,
        winner: null
      };
      for (let i = 0; i < 5; i++) {
        drawOne(gs, 0);
        drawOne(gs, 1);
      }
      return gs;
    };

    const hasAdjacentGuard = (gs, r, c) => {
      const target = gs.board[r][c].unit;
      if (!target) return false;
      for (const [dr, dc] of Object.values(DIR_VECTORS)) {
        const nr = r + dr, nc = c + dc;
        if (!inBounds(nr, nc)) continue;
        const u = gs.board[nr][nc].unit;
        if (u && u.owner === target.owner && CARDS[u.tplId].keywords?.includes("GUARD")) return true;
      }
      return false;
    };

    const computeHits = (gs, r, c) => {
      const attacker = gs.board[r][c].unit;
      const tplA = CARDS[attacker.tplId];
      const dirs = dirsForPattern(attacker.facing, tplA.pattern || "FRONT");
      const { atk } = effectiveStats(gs.board[r][c], attacker, gs);
      const hits = [];
      
      for (const d of dirs) {
        const [dr, dc] = DIR_VECTORS[d];
        const maxRange = Math.max(1, CARDS[attacker.tplId].range || 1);
        for (let step=1; step<=maxRange; step++) {
          const nr = r + dr*step, nc = c + dc*step;
          if (!inBounds(nr, nc)) break;
          const B = gs.board[nr][nc].unit;
          if (!B) continue; // –ø—É—Å—Ç–æ ‚Äî —Å–º–æ—Ç—Ä–∏–º –¥–∞–ª—å—à–µ
          if (B.owner === attacker.owner) break;
          const aFlying = tplA.keywords?.includes("FLYING");
          if (!aFlying && hasAdjacentGuard(gs, nr, nc) && !CARDS[B.tplId].keywords?.includes("GUARD")) { break; }
          const backDir = turnCW[turnCW[B.facing]];
          const [bdr, bdc] = DIR_VECTORS[backDir];
          const isBack = (nr + bdr === r && nc + bdc === c);
          let extra = 0;
          const blind = (CARDS[B.tplId].blindspots || ['S']);
          const dirFromBtoA = (()=>{ if (r===nr-1 && c===nc) return 'N'; if (r===nr+1 && c===nc) return 'S'; if (r===nr && c===nc-1) return 'W'; return 'E'; })();
          if (blind.includes(dirFromBtoA)) extra += 1;
          const dmg = Math.max(0, atk + (isBack ? 1 : 0) + extra);
          hits.push({ br: nr, bc: nc, dmg, backstab: isBack });
          break; // –ø–µ—Ä–≤–∞—è —Ü–µ–ª—å –ø–æ –ª—É—á—É
        }
      }
      return hits;
    };

    const stagedAttack = (gs, r, c) => {
      const n1 = structuredClone(gs);
      const attacker = n1.board[r][c].unit;
      if (!attacker) return null;
      const tplA = CARDS[attacker.tplId];
      const hits = computeHits(n1, r, c);
      if (!hits.length) return { empty: true };
      
      const logLines = [];
      const deaths = [];

      const applyDeaths = () => {
        for (let rr = 0; rr < 3; rr++) {
          for (let cc = 0; cc < 3; cc++) {
            const u = n1.board[rr][cc].unit;
            if (u && u.currentHP <= 0) {
              deaths.push({ r: rr, c: cc, name: CARDS[u.tplId].name });
              n1.board[rr][cc].unit = undefined;
            }
          }
        }
      };

      const step1 = () => {
        for (const h of hits) {
          const B = n1.board[h.br][h.bc].unit;
          if (!B) continue;
          const before = B.currentHP;
          // Dodge 50%: –µ—Å–ª–∏ —É —Ü–µ–ª–∏ –µ—Å—Ç—å dodge50 –∏ –∞—Ç–∞–∫–∞ –Ω–µ –º–∞–≥–∏—á–µ—Å–∫–∞—è
          const attackerTpl = CARDS[attacker.tplId];
          const isMagic = attackerTpl.attackType === 'MAGIC';
          const dodge = CARDS[B.tplId].dodge50 && !isMagic && Math.random() < 0.5;
          const dealt = dodge ? 0 : h.dmg;
          B.currentHP -= dealt;
          const afterHP = Math.max(0, B.currentHP);
          logLines.push(`${CARDS[attacker.tplId].name} ‚Üí ${CARDS[B.tplId].name}: ${dealt} —É—Ä–æ–Ω–∞${h.backstab ? " (+1 –≤ —Å–ø–∏–Ω—É)" : ""}${dodge?" (—É–∫–ª–æ–Ω–µ–Ω–∏–µ)":""} (HP ${before}‚Üí${afterHP})`);
        }
      };

      const step2 = () => {
        const still = hits.map(h => ({ h, B: n1.board[h.br][h.bc].unit })).filter(x => x.B && x.B.currentHP > 0);
        if (!still.length) return 0;
        
        let totalRetaliation = 0;
        for (const { h, B } of still) {
          const tplB = CARDS[B.tplId];
          const dirsB = dirsForPattern(B.facing, tplB.pattern || "FRONT");
          let retaliates = false;
          for (const d of dirsB) {
            const [dr, dc] = DIR_VECTORS[d];
            if (h.br + dr === r && h.bc + dc === c) {
              retaliates = true;
              break;
            }
          }
          if (retaliates) {
            const { atk: batk } = effectiveStats(n1.board[h.br][h.bc], B);
            totalRetaliation += Math.max(0, batk);
          }
        }
        // Magic attack –ª–∏—à–∞–µ—Ç –∫–æ–Ω—Ç—Ä–∞—Ç–∞–∫–∏
        const attackerTpl = CARDS[attacker.tplId];
        const preventRetaliation = attackerTpl.attackType === 'MAGIC';
        if (!preventRetaliation && totalRetaliation > 0 && n1.board[r][c].unit) {
          const A = n1.board[r][c].unit;
          const before = A.currentHP;
          A.currentHP -= totalRetaliation;
          const afterHP = Math.max(0, A.currentHP);
          logLines.push(`–û—Ç–≤–µ—Ç–Ω—ã–π —É—Ä–æ–Ω –ø–æ ${CARDS[A.tplId].name}: ${totalRetaliation} (HP ${before}‚Üí${afterHP})`);
        }
        return totalRetaliation;
      };

      const finish = () => {
        applyDeaths();
        return { n1, deaths, logLines, targets: hits.map(h => ({ r: h.br, c: h.bc, dmg: h.dmg })) };
      };

      return { step1, step2, finish, n1, attackerTpl: tplA, targets: hits.map(h => ({ r: h.br, c: h.bc, dmg: h.dmg })) };
    };

    // Magic single-target attack: choose any enemy unit; no retaliation
    const magicAttack = (gs, fr, fc, tr, tc) => {
      const n1 = structuredClone(gs);
      const attacker = n1.board[fr][fc].unit;
      const target = n1.board[tr][tc].unit;
      if (!attacker || !target || target.owner === attacker.owner) return null;
      const atkStats = effectiveStats(n1.board[fr][fc], attacker, n1);
      const tplA = CARDS[attacker.tplId];
      const dmg = Math.max(0, atkStats.atk + (tplA.randomPlus2 && Math.random()<0.5 ? 2:0));
      const before = target.currentHP;
      target.currentHP = Math.max(0, target.currentHP - dmg);
      const afterHP = target.currentHP;
      const logLines = [`${CARDS[attacker.tplId].name} (Magic) ‚Üí ${CARDS[target.tplId].name}: ${dmg} dmg (HP ${before}‚Üí${afterHP})`];
      // deaths cleanup
      for (let rr=0; rr<3; rr++) for (let cc=0; cc<3; cc++) {
        const u = n1.board[rr][cc].unit; if (u && u.currentHP<=0) n1.board[rr][cc].unit = undefined;
      }
      const died = afterHP <= 0;
      return { n1, logLines, dmg, died };
    };

    // –ö–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
     function ManaBar({ mana, gain, onGainShown }) {
      const [anim, setAnim] = useState(0);
      const [displayed, setDisplayed] = useState(mana);
      // –ü—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –º–∞–Ω—ã —Å –ø—Ä–∏—Ä–æ—Å—Ç–æ–º ‚Äî —Å–Ω–∞—á–∞–ª–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç–∞—Ä–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –ø–æ—Ç–æ–º –ø–æ—Å–ª–µ –∞–Ω–∏–º–∞—Ü–∏–∏ ‚Äî –Ω–æ–≤–æ–µ
      useEffect(() => {
        if (gain > 0) {
          const base = Math.max(0, Math.min(10, mana - gain));
          setDisplayed(base);
          let i = 0;
          const id = window.setInterval(() => {
            i++;
            setAnim(i);
            if (i >= gain) {
              window.clearInterval(id);
              setTimeout(() => {
                setAnim(0);
                setDisplayed(Math.min(10, mana));
                onGainShown();
              }, 400);
            }
          }, 220);
          return () => window.clearInterval(id);
        } else {
          setDisplayed(Math.min(10, mana));
        }
      }, [mana, gain, onGainShown]);

      const filled = Array.from({ length: Math.min(10, displayed) }).map((_, i) => (
        <div key={`f${i}`} className="mana-orb" />
      ));
      const empty = Array.from({ length: Math.max(0, 10 - displayed) }).map((_, i) => (
        <div key={`e${i}`} className="mana-slot" />
      ));

      return (
        <div className="px-3 py-2 rounded-xl bg-slate-800 border border-slate-700 flex items-center gap-3 relative overflow-visible">
          <b>–ú–∞–Ω–∞:</b>
          <div className="mana-bar">{filled}{empty}</div>
          {gain > 0 && Array.from({ length: anim }).map((_, i) => (
            <div key={i} className="mana-gain-orb" style={{ left: `${-22 - i * 6}px` }} />
          ))}
        </div>
      );
    }

    function labelElement(e) {
      switch (e) {
        case "FIRE": return "–û–≥–æ–Ω—å";
        case "WATER": return "–í–æ–¥–∞";
        case "EARTH": return "–ó–µ–º–ª—è";
        case "FOREST": return "–õ–µ—Å";
      }
    }

    function cellTexture(e) {
      const data = window.TILE_DATAURL?.[e];
      if (data) return `url('${data}')`;
      // –§–æ–ª–±—ç–∫ –Ω–∞ —Ñ–∞–π–ª—ã, –µ—Å–ª–∏ dataURI –µ—â—ë –Ω–µ –≥–æ—Ç–æ–≤—ã
      const fallback = {
        FIRE: 'tile-fire.png', WATER: 'tile-water.png', EARTH: 'tile-earth.png', FOREST: 'tile-forest.png'
      };
      const alt = {
        FIRE: 'tile-fire.jpg', WATER: 'tile-water.jpg', EARTH: 'tile-earth.jpg', FOREST: 'tile-forest.jpg'
      };
      return `url('${fallback[e] || alt[e] || 'tile-earth.png'}')`;
    }

    function DeckChoice({ value, onChange }) {
      return (
        <div className="space-y-2">
          <button
            onClick={() => onChange("TEMPO")}
            className={`w-full p-3 rounded-xl border ${value === "TEMPO" ? "border-blue-400" : "border-slate-700"} bg-slate-800 hover:bg-slate-700 text-left`}
          >
            <div className="font-semibold">–¢–µ–º–ø–æ (–û–≥–æ–Ω—å/–õ–µ—Å)</div>
            <div className="text-sm opacity-80">–î–∞–≤–ª–µ–Ω–∏–µ –∏ –º–æ–±–∏–ª—å–Ω–æ—Å—Ç—å</div>
          </button>
          <button
            onClick={() => onChange("CONTROL")}
            className={`w-full p-3 rounded-xl border ${value === "CONTROL" ? "border-blue-400" : "border-slate-700"} bg-slate-800 hover:bg-slate-700 text-left`}
          >
            <div className="font-semibold">–ö–æ–Ω—Ç—Ä–æ–ª—å (–ó–µ–º–ª—è/–í–æ–¥–∞)</div>
            <div className="text-sm opacity-80">–°—Ç–æ–π–∫–æ—Å—Ç—å –∏ –∑–∞—á–∏—Å—Ç–∫–∞</div>
          </button>
          <button
            onClick={() => onChange("FIRESET")}
            className={`w-full p-3 rounded-xl border ${value === "FIRESET" ? "border-blue-400" : "border-slate-700"} bg-slate-800 hover:bg-slate-700 text-left`}
          >
            <div className="font-semibold">Fire Set</div>
            <div className="text-sm opacity-80">–ù–æ–≤–∞—è –æ–≥–Ω–µ–Ω–Ω–∞—è –∫–æ–ª–æ–¥–∞</div>
          </button>
        </div>
      );
    }

    function formatBlindspot(arr){
      const map = { N:'‚Üë', E:'‚Üí', S:'‚Üì', W:'‚Üê' };
      const bs = (arr && arr.length ? arr : ['S']);
      return bs.map(b => map[b] || b).join(' ');
    }

    // –û—Ç–¥–µ–ª—å–Ω–∞—è –ª–∏—Ü–µ–≤–∞—è —Å—Ç–æ—Ä–æ–Ω–∞ –∫–∞—Ä—Ç—ã –¥–ª—è —Ä—É–∫–∏ (–µ–¥–∏–Ω—ã–π –º–∞–∫–µ—Ç)
      function CardFace({ card }) {
      const isUnit = card.type === 'UNIT';
      const pattern = card.pattern || 'FRONT';
        const descText = card.text || card.desc || (isUnit && card.keywords && card.keywords.length ? card.keywords.join(', ') : '');
      return (
        <div className={`relative overflow-hidden w-[210px] h-[300px] rounded-xl bg-slate-950/95 border border-slate-600 p-1 flex flex-col`}>
          <div className="absolute inset-0 rounded-xl opacity-20" style={{ background: "radial-gradient(120px 80px at 30% 10%,rgba(255,255,255,.35),transparent)" }} />
          <div className="glint"/>
          <div className="relative z-10">
            <div className="w-full flex items-center justify-between text-xs opacity-90 mb-1"><span className="text-lg">{elementEmoji[card.element]}</span><span className="text-[10px] truncate max-w-[120px] text-right">{card.keywords?.join(', ')}</span></div>
            <div className="text-base font-bold text-center leading-tight mb-1 truncate drop-shadow">{card.name}</div>
          </div>
          <div className="relative z-0 rounded-lg bg-slate-800/60 border border-slate-700 h-[170px] mb-2 flex items-center justify-center text-xs opacity-60">Illustration</div>
          <div className="text-[11px] mb-2 bg-black/30 rounded px-2 py-1 min-h-[42px] leading-4 overflow-hidden">{descText}</div>
          {isUnit ? (
            <div className="flex items-start justify-center gap-3 mb-2">
              {/* Attack pattern */}
              <div className="grid grid-cols-3 gap-[2px]" style={{width:'30px'}}>
                {Array.from({length:9}).map((_,i)=>{
                  const rr=Math.floor(i/3), cc=i%3; const base=dirsForPattern('N', pattern);
                  const center=rr===1&&cc===1; const hl=(base.includes('N')&&rr===0&&cc===1)||(base.includes('E')&&rr===1&&cc===2)||(base.includes('S')&&rr===2&&cc===1)||(base.includes('W')&&rr===1&&cc===0);
                  const pushDown = (card.range||1)>1 && center;
                  return (<div key={`atk-${i}`} className={`h-[10px] w-[10px] rounded ${center?'bg-yellow-400/70':'bg-slate-700/60'} ${hl?'ring-[1.5px] ring-red-400':''}`} style={pushDown?{transform:'translateY(2px)'}:undefined}></div>);
                })}
              </div>
              {/* Blindspot map */}
              <div className="grid grid-cols-3 gap-[2px]" style={{width:'30px'}}>
                {Array.from({length:9}).map((_,i)=>{
                  const rr=Math.floor(i/3), cc=i%3; const center=rr===1&&cc===1;
                  const bs = (card.blindspots && card.blindspots.length? card.blindspots : ['S']);
                  const isBS = (rr===0&&cc===1&&bs.includes('N'))||(rr===1&&cc===2&&bs.includes('E'))||(rr===2&&cc===1&&bs.includes('S'))||(rr===1&&cc===0&&bs.includes('W'));
                  return (<div key={`bs-${i}`} className={`h-[10px] w-[10px] rounded ${center?'bg-yellow-400/70':'bg-slate-700/60'} ${isBS?'ring-[1.5px] ring-sky-400':''}`}></div>);
                })}
              </div>
            </div>
          ) : (<div className="text-xs opacity-80 mb-2 px-2">{card.text}</div>)}
          <div className="w-full flex items-center justify-between text-[11px] mb-1 bg-black/20 rounded px-2 py-1">
            <div className="flex items-center gap-2">
              <span className="flex items-center gap-1" title="Summoning Cost"><span className="icon-orb"></span> {card.cost}</span>
              {isUnit && (<span className="flex items-center gap-1" title="Action Cost"><span className="icon-action">‚ñ∂</span> {attackCost(card)}</span>)}
            </div>
            {isUnit && (
              <div className="flex items-center gap-3 font-bold">
                <span className="flex items-center gap-1 text-rose-300" title="Attack"><span className="icon-sword">üó°Ô∏è</span>{card.atk}</span>
                <span className="flex items-center gap-1 text-green-300" title="Health"><span className="icon-heart">‚ù§Ô∏è</span>{card.hp}</span>
              </div>
            )}
          </div>
        </div>
      );
    }
      function UnitCard({ unit, cell, rotateDeg = 0, highlightDmg, dying, compact }) {
      const tpl = CARDS[unit.tplId];
      const eff = effectiveStats(cell, unit);
      const frame = unit.owner === 0 ? "ring-2 ring-emerald-400" : "ring-2 ring-rose-500";
      const dirs = dirsForPattern("N", tpl.pattern || "FRONT");
      const hpCls = highlightDmg && highlightDmg > 0 ? "hp-pulse" : "";
      const deathCls = dying ? "fly-away" : "";

      return (
        <div
          className={`relative overflow-hidden ${compact? 'w-[180px] h-[260px]' : 'w-[210px] h-[300px]'} rounded-xl bg-slate-950/95 border border-slate-600 p-1 flex flex-col items-stretch justify-start ${frame} card3d ${deathCls}`}
          style={{ transformStyle: "preserve-3d", transform: `translateZ(10px) rotateZ(${rotateDeg}deg)` }}
        >
          <div className="absolute inset-0 rounded-xl opacity-20" style={{ background: "radial-gradient(120px 80px at 30% 10%,rgba(255,255,255,.35),transparent)" }} />
          <div className="glint" />
          
          {/* –®–∞–ø–∫–∞ –∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –Ω–∞–¥ –∏–ª–ª—é—Å—Ç—Ä–∞—Ü–∏–µ–π */}
          <div className="relative z-10">
          <div className="w-full flex items-center justify-between text-xs opacity-90 token3d mb-1">
            <span className="text-lg">{elementEmoji[tpl.element]}</span>
            {/* Keywords –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω—ã –≤ –æ–ø–∏—Å–∞–Ω–∏–µ –Ω–∏–∂–µ */}
            <span className="text-[10px] truncate max-w-[120px] text-right"></span>
          </div>
            <div className="text-base font-bold text-center leading-tight token3d mb-1 truncate drop-shadow">{tpl.name}</div>
          </div>
          {/* –ó–æ–Ω–∞ –∏–ª–ª—é—Å—Ç—Ä–∞—Ü–∏–∏ */}
          <div className={`relative z-0 rounded-lg bg-slate-800/60 border border-slate-700 ${compact? 'h-[130px]' : 'h-[180px]'} mb-2 token3d flex items-center justify-center text-xs opacity-60`}>Illustration</div>
          {/* –û–ø–∏—Å–∞–Ω–∏–µ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π */}
          <div className="text-[11px] token3d mb-2 bg-black/30 rounded px-2 py-1 min-h-[36px] leading-4 overflow-hidden">
            {(CARDS[unit.tplId].desc || CARDS[unit.tplId].keywords?.join(', ') || '')}
          </div>
          {/* –°—Ö–µ–º—ã 3x3: –∞—Ç–∞–∫–∞ –∏ blindspot */}
          <div className="flex items-start justify-center gap-3 mb-2 chip3d">
            <div className="grid grid-cols-3 gap-[2px]" style={{width: '30px'}}>
              {Array.from({length:9}).map((_,i)=>{
                const rr=Math.floor(i/3), cc=i%3;
                const center=rr===1&&cc===1;
                const pushDown = (CARDS[unit.tplId].range||1) > 1 && center;
                const baseDirs=dirsForPattern('N', tpl.pattern||'FRONT');
                const highlight = (
                  (baseDirs.includes('N') && rr===0 && cc===1) ||
                  (baseDirs.includes('E') && rr===1 && cc===2) ||
                  (baseDirs.includes('S') && rr===2 && cc===1) ||
                  (baseDirs.includes('W') && rr===1 && cc===0)
                );
                return (<div key={`atk-${i}`} className={`h-[10px] w-[10px] rounded ${center? 'bg-yellow-400/70':'bg-slate-700/60'} ${highlight? 'ring-[1.5px] ring-red-400':''}`} style={pushDown?{transform:'translateY(2px)'}:undefined}></div>);
              })}
            </div>
            <div className="grid grid-cols-3 gap-[2px]" style={{width: '30px'}}>
              {Array.from({length:9}).map((_,i)=>{
                const rr=Math.floor(i/3), cc=i%3; const center=rr===1&&cc===1;
                const bs = (CARDS[unit.tplId].blindspots && CARDS[unit.tplId].blindspots.length? CARDS[unit.tplId].blindspots : ['S']);
                const isBS = (rr===0&&cc===1&&bs.includes('N'))||(rr===1&&cc===2&&bs.includes('E'))||(rr===2&&cc===1&&bs.includes('S'))||(rr===1&&cc===0&&bs.includes('W'));
                return (<div key={`bs-${i}`} className={`h-[10px] w-[10px] rounded ${center? 'bg-yellow-400/70':'bg-slate-700/60'} ${isBS?'ring-[1.5px] ring-sky-400':''}`}></div>);
              })}
            </div>
          </div>
          
          {/* –£—Ä–æ–Ω (–µ—Å–ª–∏ –µ—Å—Ç—å) */}
          {highlightDmg && highlightDmg > 0 ? <div className="dmg-float text-sm">-{highlightDmg}</div> : null}
          
          {/* –°—Ç–æ–∏–º–æ—Å—Ç–∏ –∏ —Å—Ç–∞—Ç—ã ‚Äî –∏–∫–æ–Ω–∫–∏ */}
          <div className="w-full flex items-center justify-between text-[11px] token3d mb-1 bg-black/20 rounded px-2 py-1">
            <div className="flex items-center gap-2">
              <span title="Summoning Cost" className="flex items-center gap-1"><span className="icon-orb"></span> {tpl.cost}</span>
              <span title="Action Cost" className="flex items-center gap-1"><span className="icon-action">‚ñ∂</span> {attackCost(tpl)}</span>
            </div>
            <div className="flex items-center gap-3 font-bold">
              <span className={`flex items-center gap-1 text-rose-300 ${hpCls}`} title="Attack"><span className="icon-sword">üó°Ô∏è</span>{eff.atk}</span>
              <span className={`flex items-center gap-1 text-green-300 ${hpCls}`} title="Health"><span className="icon-heart">‚ù§Ô∏è</span>{unit.currentHP}</span>
            </div>
          </div>
        </div>
      );
    }

    // –ì–ª–∞–≤–Ω—ã–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
    function App() {
      const [pre, setPre] = useState({ d0: null, d1: null });
      const [gs, setGs] = useState(null);
      const [log, setLog] = useState([]);
      const [dragIdx, setDragIdx] = useState(null);
      const [dropSpot, setDropSpot] = useState(null);
      const [battle, setBattle] = useState({ show: false, text: "" });
      const [turnBanner, setTurnBanner] = useState(null); // { turn, playerName }
      const [unitAction, setUnitAction] = useState(null);
      const [magicTarget, setMagicTarget] = useState(null); // {from:{r,c}}
      const [tilt, setTilt] = useState({ rx: 0, ry: 0 });
      const [fx, setFx] = useState(null);
      const [showLog, setShowLog] = useState(false);
      const [preview, setPreview] = useState({ show: false, x: 0, y: 0, tpl: null });
      const [pvTimer, setPvTimer] = useState(null);
      const [manaGain, setManaGain] = useState(null);
      const [showHelp, setShowHelp] = useState(false);
      const [showLegendPanel, setShowLegendPanel] = useState(false);
      const [handHover, setHandHover] = useState(null);
      const [dropAnim, setDropAnim] = useState(null);
      const dragGhostRef = React.useRef(null);
      const [dragOverlay, setDragOverlay] = useState(null); // { card, x, y, tiltX, tiltY, angle }
      const dragPrevRef = React.useRef({ x: 0, y: 0, t: 0 });
      const [boardY, setBoardY] = useState(-160);

      const addLog = (s) => setLog((x) => [s, ...x].slice(0, 500));
      useEffect(()=>{
        const updateOffset=()=>{
          const h = window.innerHeight || 900;
          let y = -160;
          if (h <= 720) y = -110; else if (h <= 800) y = -130; else if (h <= 900) y = -150; else if (h <= 980) y = -170; else y = -190;
          setBoardY(y);
        };
        updateOffset();
        window.addEventListener('resize', updateOffset);
        return ()=> window.removeEventListener('resize', updateOffset);
      },[]);

      const start = () => {
        if (!pre.d0 || !pre.d1) return;
        const mapDeck = (v)=> v === 'TEMPO' ? STARTER_TEMPO : (v==='FIRESET'? STARTER_FIRESET : STARTER_CONTROL);
        const d0 = mapDeck(pre.d0);
        const d1 = mapDeck(pre.d1);
        const g = startGame(d0, d1);
        setGs(g);
        setLog(["–ò–≥—Ä–∞ –Ω–∞—á–∞—Ç–∞. –ò–≥—Ä–æ–∫ A —Ö–æ–¥–∏—Ç –ø–µ—Ä–≤—ã–º.", "–ö–∞–∂–¥—ã–π —Ö–æ–¥: –¥–æ–±–æ—Ä 1, +2 –º–∞–Ω—ã (–∫–∞–ø 10).", "–ò–≥—Ä–æ–∫ A —Å—Ç–∞—Ä—Ç—É–µ—Ç —Å 2 –º–∞–Ω–æ–π."]);
        setManaGain({ player: 0, count: 0 });
        setTurnBanner({ turn: g.turn, playerName: g.players[g.active].name });
        setTimeout(()=>setTurnBanner(null), 2600);
      };

      const endTurn = () => {
        if (!gs) return;
        const n = structuredClone(gs);
        const cnt = countControlled(n, n.active);
        if (cnt >= 5) {
          n.winner = n.active;
          setGs(n);
          addLog(`${n.players[n.active].name} –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–µ—Ç ${cnt} –∫–ª–µ—Ç–æ–∫ –∏ –ø–æ–±–µ–∂–¥–∞–µ—Ç!`);
          return;
        }
        n.active = n.active === 0 ? 1 : 0;
        n.turn += 1;
        const pl = n.players[n.active];
        const gain = Math.max(0, Math.min(2, 10 - pl.mana));
        pl.mana = capMana(pl.mana + 2);
        drawOne(n, n.active);
        n.selectedCard = null;
        n.pending = null;
        setGs(n);
        setDropSpot(null);
        setUnitAction(null);
        setManaGain({ player: n.active, count: gain });
        addLog(`–•–æ–¥ ${n.turn}. ${pl.name} –ø–æ–ª—É—á–∞–µ—Ç +2 –º–∞–Ω—ã –∏ —Ç—è–Ω–µ—Ç –∫–∞—Ä—Ç—É.`);
        // –ü–æ–∫–∞–∑–∞—Ç—å –±–∞–Ω–Ω–µ—Ä –Ω–∞—á–∞–ª–∞ —Ö–æ–¥–∞
        setTurnBanner({ turn: n.turn, playerName: pl.name });
        setTimeout(()=>setTurnBanner(null), 2600);
      };

      const reset = () => {
        setGs(null);
        setPre({ d0: null, d1: null });
        setLog([]);
        setDropSpot(null);
        setUnitAction(null);
        setFx(null);
        setPreview({ show: false, x: 0, y: 0, tpl: null });
        if (pvTimer) {
          window.clearTimeout(pvTimer);
          setPvTimer(null);
        }
      };

       const beginBattleSequenceAt = (state, r, c, markAttackTurn) => {
        if (!state) return;
        const snapshot = structuredClone(state);
        const staged = stagedAttack(snapshot, r, c);
         if (!staged || staged.empty) return;
        setBattle({ show: true, text: "BATTLE" });
        setTimeout(() => {
          const { step1, step2, finish, n1, targets } = staged;
          step1();
          setGs(n1);
          setFx({ attack: { a: { r, c }, targets, deaths: [] } });
          setTimeout(() => {
            const ret = step2();
            setGs(n1);
            setFx(s => s && s.attack ? { attack: { ...s.attack, retaliation: ret || 0 } } : s);
            setTimeout(() => {
              const res = finish();
              if (markAttackTurn && n1.board[r][c].unit) n1.board[r][c].unit.lastAttackTurn = n1.turn;
              setGs(res.n1);
              setBattle({ show: false, text: "" });
              setFx({ attack: { a: { r, c }, targets: res.targets, retaliation: (ret || 0), deaths: res.deaths.map(d => ({ r: d.r, c: d.c })) } });
              for (const line of res.logLines.reverse()) addLog(line);
              setTimeout(() => { setFx(null); }, 1000);
            }, 1000);
          }, 1000);
        }, 1500);
      };
      const beginBattleSequence = (r, c, markAttackTurn) => beginBattleSequenceAt(gs, r, c, markAttackTurn);

       const placeUnitWithFacing = (r, c, idx, facing) => {
        if (!gs) return;
        const n = structuredClone(gs);
        const pl = n.players[n.active];
        const tpl = pl.hand[idx];
        if (!tpl || tpl.type !== "UNIT") return;
        if (tpl.cost > pl.mana) {
          addLog("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–∞–Ω—ã");
          setDropSpot(null);
          return;
        }
        if (n.board[r][c].unit) {
          addLog("–ö–ª–µ—Ç–∫–∞ –∑–∞–Ω—è—Ç–∞");
          setDropSpot(null);
          return;
        }
        const inst = { uid: uid(), owner: n.active, tplId: tpl.id, currentHP: tpl.hp, facing };
        n.board[r][c].unit = inst;
        pl.mana -= tpl.cost;
        pl.discard.push(tpl);
        pl.hand.splice(idx, 1);
        // –≠–ª–µ–º–µ–Ω—Ç–∞–ª—å–Ω—ã–µ –±–∞—Ñ—Ñ—ã/–¥–µ–±–∞—Ñ—Ñ—ã –ø—Ä–∏–º–µ–Ω—è—é—Ç—Å—è —Å—Ä–∞–∑—É –∫ –∑–¥–æ—Ä–æ–≤—å—é (–º–æ–≥—É—Ç —É–±–∏—Ç—å —é–Ω–∏—Ç–∞)
        const cellEl = n.board[r][c].element;
        const buff = computeCellBuff(cellEl, CARDS[inst.tplId].element);
        if (buff.hp !== 0) {
          const before = inst.currentHP;
          inst.currentHP = Math.max(0, inst.currentHP + buff.hp);
          if (buff.hp > 0) addLog(`–≠–ª–µ–º–µ–Ω—Ç ${labelElement(cellEl)} —É—Å–∏–ª–∏–≤–∞–µ—Ç ${CARDS[inst.tplId].name}: HP ${before}‚Üí${inst.currentHP}`);
          if (buff.hp < 0) addLog(`–≠–ª–µ–º–µ–Ω—Ç ${labelElement(cellEl)} –æ—Å–ª–∞–±–ª—è–µ—Ç ${CARDS[inst.tplId].name}: HP ${before}‚Üí${inst.currentHP}`);
        }
        if (inst.currentHP <= 0) {
          addLog(`${CARDS[inst.tplId].name} –ø–æ–≥–∏–±–∞–µ—Ç –æ—Ç –Ω–µ–±–ª–∞–≥–æ–ø—Ä–∏—è—Ç–Ω–æ–π —Å—Ç–∏—Ö–∏–∏ –ø—Ä–∏ –ø—Ä–∏–∑—ã–≤–µ.`);
          n.board[r][c].unit = undefined;
          setDropSpot(null);
          setGs(n);
          return;
        }
        // –ê—É—Ä–∞: Freedonian Wanderer –¥–∞—ë—Ç +1 –º–∞–Ω—É –∑–∞ –ª—é–±–æ–π –¥—Ä—É–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–π –ø—Ä–∏–∑—ã–≤, –µ—Å–ª–∏ —Å—Ç–æ–∏—Ç –Ω–µ –Ω–∞ –æ–≥–Ω–µ
        if (CARDS[inst.tplId].auraGainManaOnSummon && n.board[r][c].element !== 'FIRE') {
          n.players[n.active].mana = capMana(n.players[n.active].mana + 1);
          addLog(`Aura: ${CARDS[inst.tplId].name} –¥–∞—ë—Ç +1 –º–∞–Ω—É –∑–∞ –ø—Ä–∏–∑—ã–≤.`);
        }
        setDropSpot(null);
        setGs(n);
        setDropAnim({ r, c });
        setTimeout(() => setDropAnim(null), 400);
        addLog(`${n.players[n.active].name} –ø—Ä–∏–∑—ã–≤–∞–µ—Ç ${tpl.name} –Ω–∞ ${r + 1},${c + 1}.`);
         const hits = computeHits(n, r, c);
         if (hits.length > 0) beginBattleSequenceAt(n, r, c, true);
      };

      const castSpellOnCell = (r, c, cardId) => {
        if (!gs) return;
        const n = structuredClone(gs);
        const pl = n.players[n.active];
        if (!n.selectedCard) {
          setGs(n);
          return;
        }
        const idx = n.selectedCard.index;
        if (idx < 0 || idx >= pl.hand.length) {
          n.selectedCard = null;
          setGs(n);
          return;
        }
        const tpl = pl.hand[idx];
        if (!tpl || tpl.id !== cardId || tpl.type !== "SPELL") {
          setGs(n);
          return;
        }
        if (tpl.cost > pl.mana) {
          addLog("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–∞–Ω—ã");
          return;
        }
        pl.mana -= tpl.cost;
        pl.discard.push(tpl);
        pl.hand.splice(idx, 1);
        n.selectedCard = null;
        n.pending = null;
        setGs(n);
      };

      const castSpellOnUnit = (r, c, cardId) => {
        if (!gs) return;
        const n = structuredClone(gs);
        const pl = n.players[n.active];
        if (!n.selectedCard) {
          setGs(n);
          return;
        }
        const idx = n.selectedCard.index;
        if (idx < 0 || idx >= pl.hand.length) {
          n.selectedCard = null;
          setGs(n);
          return;
        }
        const tpl = pl.hand[idx];
        if (!tpl || tpl.id !== cardId || tpl.type !== "SPELL") {
          setGs(n);
          return;
        }
        if (tpl.cost > pl.mana) {
          addLog("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–∞–Ω—ã");
          return;
        }
        if (tpl.id === "WIND_SHIFT") {
          const u = n.board[r][c].unit;
          if (u) u.facing = turnCW[u.facing];
        }
        if (tpl.id === "FREEZE_STREAM") {
          const u = n.board[r][c].unit;
          if (u) {
            const before = u.currentHP;
            u.currentHP = Math.max(0, u.currentHP - 1);
            addLog(`${tpl.name}: ${CARDS[u.tplId].name} –ø–æ–ª—É—á–∞–µ—Ç 1 —É—Ä–æ–Ω–∞ (HP ${before}‚Üí${u.currentHP})`);
          }
        }
        if (tpl.id === "RAISE_STONE") {
          const u = n.board[r][c].unit;
          if (u && u.owner === n.active) {
            const before = u.currentHP;
            u.currentHP += 2;
            addLog(`${tpl.name}: ${CARDS[u.tplId].name} –ø–æ–ª—É—á–∞–µ—Ç +2 HP (HP ${before}‚Üí${u.currentHP})`);
          }
        }
        pl.mana -= tpl.cost;
        pl.discard.push(tpl);
        pl.hand.splice(idx, 1);
        n.selectedCard = null;
        n.pending = null;
        setGs(n);
      };

      const onCellDrop = (e, r, c) => {
        e.preventDefault();
        if (dragIdx == null || !gs) return;
        const tpl = gs.players[gs.active].hand[dragIdx];
        if (!tpl || tpl.type !== "UNIT") return;
        setDropSpot({ r, c, idx: dragIdx });
      };

      const clickCell = (r, c) => {
        if (!gs || gs.winner != null) return;
        // If in MAGIC targeting mode
        if (magicTarget) {
          const { from } = magicTarget;
          const res = magicAttack(gs, from.r, from.c, r, c);
        if (res) {
            const n1 = structuredClone(res.n1);
            if (n1.board[from.r][from.c]?.unit) {
              n1.board[from.r][from.c].unit.lastAttackTurn = n1.turn;
            }
            setGs(n1);
          for (const l of res.logLines.reverse()) addLog(l);
          // –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏ –∞–Ω–∏–º–∞—Ü–∏–∏ –∞—Ç–∞–∫–∏/—É—Ä–æ–Ω–∞ –∫–∞–∫ —É –æ–±—ã—á–Ω–æ–π
          const deaths = res.died ? [{ r, c }] : [];
          setFx({ attack: { a: { r: from.r, c: from.c }, targets: [{ r, c, dmg: res.dmg }], retaliation: 0, deaths } });
          setTimeout(() => setFx(null), 1000);
            setMagicTarget(null);
          }
          return;
        }
        const n = structuredClone(gs);
        const pl = n.players[n.active];
        if (n.selectedCard) {
          const idx = n.selectedCard.index;
          if (idx < 0 || idx >= pl.hand.length) {
            n.selectedCard = null;
            setGs(n);
            return;
          }
          const card = pl.hand[idx];
          if (!card) {
            setGs(n);
            return;
          }
          if (card.type === "SPELL") {
            if (card.id === "WIND_SHIFT" || card.id === "FREEZE_STREAM" || card.id === "RAISE_STONE") {
              n.pending = { mode: "TARGET_UNIT", cardId: card.id };
              setGs(n);
              castSpellOnUnit(r, c, card.id);
              return;
            }
            n.pending = { mode: "TARGET_CELL", cardId: card.id };
            setGs(n);
            castSpellOnCell(r, c, card.id);
            return;
          }
          return;
        }
        const u = n.board[r][c].unit;
        if (u && u.owner === n.active) { setUnitAction({ r, c }); setGs(n); }
      };

      const onSceneMove = (e) => {
        const rect = e.currentTarget.getBoundingClientRect();
        const cx = rect.left + rect.width / 2, cy = rect.top + rect.height / 2;
        const dx = (e.clientX - cx) / rect.width, dy = (e.clientY - cy) / rect.height;
        setTilt({ rx: -dy * 10, ry: dx * 10 });
      };

      const onSceneLeave = () => setTilt({ rx: 0, ry: 0 });

      const isTarget = (r, c) => !!fx?.attack?.targets.find(t => t.r === r && t.c === c);
      const targetDmg = (r, c) => fx?.attack?.targets.find(t => t.r === r && t.c === c)?.dmg || 0;
      const isAttacker = (r, c) => fx?.attack?.a.r === r && fx?.attack?.a.c === c;
      const isDeathCell = (r, c) => !!fx?.attack?.deaths.find(d => d.r === r && d.c === c);

      const planPreview = (tpl, x, y) => {
        if (pvTimer) window.clearTimeout(pvTimer);
        const id = window.setTimeout(() => {
          setPreview({ show: true, x: x + 16, y: y + 16, tpl });
        }, 1000);
        setPvTimer(id);
      };

      const cancelPreview = () => {
        if (pvTimer) window.clearTimeout(pvTimer);
        setPvTimer(null);
        setPreview({ show: false, x: 0, y: 0, tpl: null });
      };

      const renderCell = (r, c) => {
        if (!gs) return null;
        const cell = gs.board[r][c];
        const u = cell.unit;
        const borderColor = u ? (u.owner === 0 ? "border-emerald-400" : "border-rose-500") : "border-slate-700";
        const atkCls = isAttacker(r, c) ? "animate-lunge-slow" : "";
        const tgtCls = isTarget(r, c) ? "animate-shake-slow" : "";
        const deathFlash = isDeathCell(r, c) ? "death-flash" : "";
        const onEnter = (e) => {
          if (!u) return;
          planPreview(CARDS[u.tplId], e.clientX, e.clientY);
        };
        const onMove = (e) => {
          if (!u) return;
          if (preview.show) setPreview(p => ({ ...p, x: e.clientX + 16, y: e.clientY + 16 }));
        };
        const onLeave = () => cancelPreview();
        const rot = u ? facingDeg[u.facing] : 0;
        const dmgFloat = targetDmg(r, c);

        return (
          <div
            key={`${r}-${c}`}
            onClick={() => clickCell(r, c)}
            onDragOver={(e) => { e.preventDefault(); if (dragIdx!=null) e.currentTarget.classList.add('drop-hover'); }}
            onDrop={(e) => onCellDrop(e, r, c)}
            onDragLeave={(e)=> e.currentTarget.classList.remove('drop-hover')}
            className={`relative aspect-square rounded-2xl flex items-center justify-center cursor-pointer border-2 ${borderColor} shadow-2xl p-2 select-none cell3d ${tgtCls} ${deathFlash}`}
              style={{ 
              backgroundImage: cellTexture(cell.element),
              backgroundSize: 'cover',
              backgroundPosition: 'center',
              backgroundRepeat: 'no-repeat',
              transformStyle: 'preserve-3d',
              minHeight: '230px',
              minWidth: '230px'
            }}
            onMouseEnter={onEnter}
            onMouseMove={onMove}
            onMouseLeave={onLeave}
          >
            {/* –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã */}
            <div className="absolute top-1 left-1 text-xs opacity-60 bg-black/30 px-1 rounded">{r + 1},{c + 1}</div>
            
            {/* –ò–∫–æ–Ω–∫–∞ —ç–ª–µ–º–µ–Ω—Ç–∞ */}
            <div className="absolute top-1 right-1 text-lg opacity-90 bg-black/30 px-1 rounded">{elementEmoji[cell.element]}</div>
            
            {/* –Æ–Ω–∏—Ç –∏–ª–∏ –ø—É—Å—Ç–∞—è —è—á–µ–π–∫–∞ */}
            {u ? (
              <div className={`${atkCls} ${dropAnim && dropAnim.r===r && dropAnim.c===c ? 'slam' : ''}`} style={{ transformStyle: 'preserve-3d', width: '100%', height: '100%', display:'flex', alignItems:'center', justifyContent:'center' }}>
                <UnitCard unit={u} cell={cell} rotateDeg={rot} highlightDmg={dmgFloat} dying={isDeathCell(r, c)} compact />
              </div>
            ) : (
              <div className="text-xs opacity-40 bg-black/20 px-2 py-1 rounded">–ø—É—Å—Ç–æ</div>
            )}
          </div>
        );
      };

      return (
        <div className="min-h-screen w-full bg-slate-900 text-slate-100 p-2 md:p-4 overflow-hidden" onDragOver={(e)=>{ if(dragOverlay){ const cx=e.clientX||e.pageX; const cy=e.clientY||e.pageY; const now=performance.now(); const dt=Math.max(1, now - dragPrevRef.current.t); const vx=(cx - dragPrevRef.current.x)/dt; const vy=(cy - dragPrevRef.current.y)/dt; const clamp=(v,a)=>Math.max(-a, Math.min(a,v)); const tiltX=clamp(-vy*120,10); const tiltY=clamp(vx*120,10); const angle=clamp(vx*-30,8); setDragOverlay(s=> s ? ({...s, x:cx, y:cy, tiltX, tiltY, angle}) : s); dragPrevRef.current={x:cx,y:cy,t:now}; } }}>
          <style>{`
             html, body { height:100%; overflow:hidden }
             .scene{perspective:1400px}
            .board3d{transform-style:preserve-3d}
            .cell3d:hover .card3d{transform:translateZ(22px) rotateX(2deg) rotateY(2deg)}
            .card3d{transform:translateZ(12px); transition:transform .35s ease, box-shadow .35s ease; box-shadow:0 12px 34px rgba(0,0,0,.38)}
            .token3d{transform:translateZ(30px)}
            .chip3d{transform:translateZ(44px)}
            .battlePop{animation:pop 1.2s ease both; transform:translateZ(90px)}
            .glint{position:absolute; inset:-10%; background:linear-gradient(75deg, rgba(255,255,255,0) 0%, rgba(255,255,255,.35) 45%, rgba(255,255,255,0) 60%); mix-blend-mode:screen; animation:glintmove 2.6s linear infinite; pointer-events:none}
            .animate-lunge-slow{animation:lunge .8s ease both}
            .animate-shake-slow{animation:shake 1.1s ease both}
            .death-flash::after{content:""; position:absolute; inset:0; background:radial-gradient(circle, rgba(255,60,60,.45) 0, rgba(255,60,60,0) 60%); animation:flash 1.2s ease both}
            @keyframes pop{0%{transform:translateZ(0) scale(.6); opacity:0}40%{transform:translateZ(70px) scale(1.06); opacity:1}100%{transform:translateZ(90px) scale(1); opacity:.95}}
            @keyframes glintmove{0%{transform:translateX(-140%) rotate(10deg)}100%{transform:translateX(140%) rotate(10deg)}}
            @keyframes lunge{0%{transform:translateZ(0) scale(1)}50%{transform:translateZ(60px) scale(1.12)}100%{transform:translateZ(0) scale(1)}}
            @keyframes shake{0%{transform:translateX(0)}20%{transform:translateX(-10px)}40%{transform:translateX(10px)}60%{transform:translateX(-6px)}80%{transform:translateX(6px)}100%{transform:translateX(0)}}
            @keyframes flash{0%{opacity:.98}100%{opacity:0}}
            .dmg-float{position:absolute; top:12px; right:12px; font-weight:800; font-size:22px; color:#ff6464; text-shadow:0 2px 8px rgba(0,0,0,.6); animation:dmg 1.1s ease both}
            @keyframes dmg{0%{opacity:0; transform:translateY(10px) scale(.8)}30%{opacity:1; transform:translateY(0) scale(1)}100%{opacity:0; transform:translateY(-18px) scale(1.05)}}
            .hp-pulse{animation:hppulse 1s ease both}
            @keyframes hppulse{0%{transform:scale(1)}25%{transform:scale(1.25)}100%{transform:scale(1)}}
            .fly-away{animation:fly 1.2s ease both}
            @keyframes fly{0%{opacity:1; transform:translateZ(10px) scale(1)}60%{opacity:.9; transform:translate(30px,-40px) rotate(12deg) scale(.9)}100%{opacity:0; transform:translate(90px,-120px) rotate(28deg) scale(.7)}}
            .mana-bar{display:flex; gap:6px; align-items:center}
            .mana-slot{width:18px; height:18px; border-radius:999px; border:1px solid rgba(255,255,255,.25); background:rgba(255,255,255,.06); box-shadow:inset 0 2px 6px rgba(0,0,0,.5)}
            .mana-orb{width:18px; height:18px; border-radius:999px; background:radial-gradient(circle at 30% 30%, #fff, #8bd5ff 30%, #1ea0ff 70%, #0a67b7); box-shadow:0 0 10px rgba(30,160,255,.8); transform:scale(0); animation:orbpop .5s ease forwards}
            @keyframes orbpop{to{transform:scale(1)}}
             .mana-gain-orb{position:absolute; width:14px; height:14px; border-radius:999px; background:radial-gradient(circle at 30% 30%, #fff, #8bd5ff 30%, #1ea0ff 70%, #0a67b7); box-shadow:0 0 10px rgba(30,160,255,.9); left:-22px; top:50%; transform:translate(-10px,-50%) scale(.7); animation:orbflyleft 700ms cubic-bezier(.2,.7,.15,1) forwards}
            @keyframes orbflyleft{0%{opacity:0; transform:translate(-40px,-50%) scale(.7)}40%{opacity:1}70%{transform:translate(-6px,-52%) scale(1.06)}100%{opacity:0; transform:translate(0,-50%) scale(1)}}
            /* –†—É–∫–∞ –∫–∞—Ä—Ç ‚Äî –≤–µ–µ—Ä–æ–º */
             .hand{position:fixed; left:50%; bottom:-8px; transform:translateX(-50%); height:170px; width:100%; max-width:1100px; pointer-events:none}
            .hand-card{position:absolute; bottom:0; transform-origin:50% 120px; pointer-events:auto}
             .hand-card.dragging{transform:translateX(-50%) rotate(0deg) translateZ(40px) scale(1.12)!important; box-shadow:0 30px 60px rgba(0,0,0,.6)!important}
            .drop-hover{outline:3px dashed rgba(255,255,255,.4); outline-offset: -6px}
             .slam{animation:dropslam 420ms cubic-bezier(.25,.9,.2,1.1) both}
             @keyframes dropslam{0%{transform:translateY(-120px) rotateX(8deg) scale(.94)}70%{transform:translateY(6px) rotateX(0deg) scale(1.06)}100%{transform:translateY(0) scale(1)}}
             .icon-action{width:16px; height:16px; border-radius:4px; background:linear-gradient(135deg,#4ade80,#059669); display:inline-flex; align-items:center; justify-content:center; color:#022c22; font-size:12px; box-shadow:0 0 6px rgba(34,197,94,.6)}
            /* –ò–∫–æ–Ω–∫–∏ */
            .icon-orb{width:16px; height:16px; border-radius:999px; background:radial-gradient(circle at 30% 30%, #fff, #8bd5ff 30%, #1ea0ff 70%, #0a67b7); box-shadow:0 0 6px rgba(30,160,255,.8)}
            .icon-sword{font-size:14px}
             .icon-heart{font-size:14px; color:#ff6b6b}
             /* Turn banner */
             .turnBanner{animation:turnslide 2600ms ease-in-out both; transform:translateZ(120px)}
             @keyframes turnslide{0%{transform:translateX(-120%) translateZ(120px)}20%{transform:translateX(0) translateZ(120px)}80%{transform:translateX(0) translateZ(120px)}100%{transform:translateX(140%) translateZ(120px)}}
          `}</style>
          <div className="max-w-7xl mx-auto grid grid-cols-1 gap-3 md:gap-4">
            <div>
              <h1 className="sr-only">Eye-of-Grid ‚Äî 3D</h1>
              {!gs ? (
                <div className="bg-slate-800/60 border border-slate-700 rounded-2xl p-4">
                  <p className="mb-3 opacity-90">–í—ã–±–µ—Ä–∏—Ç–µ —Å—Ç–∞—Ä—Ç–µ—Ä—ã –∏ –Ω–∞—á–Ω–∏—Ç–µ –ø–∞—Ä—Ç–∏—é. –ö–∞–∂–¥—ã–π —Ö–æ–¥: –¥–æ–±–æ—Ä 1, +2 –º–∞–Ω—ã (–∫–∞–ø 10). –ü–æ–±–µ–¥–∞ ‚Äî –∫–æ–Ω—Ç—Ä–æ–ª—å 5+ –∫–ª–µ—Ç–æ–∫.</p>
                  <div className="grid grid-cols-2 gap-4">
                    <div className="bg-slate-800 border border-slate-700 rounded-xl p-3">
                      <h2 className="font-medium mb-2">–ò–≥—Ä–æ–∫ A</h2>
                      <DeckChoice value={pre.d0} onChange={(v) => setPre((s) => ({ ...s, d0: v }))} />
                    </div>
                    <div className="bg-slate-800 border border-slate-700 rounded-xl p-3">
                      <h2 className="font-medium mb-2">–ò–≥—Ä–æ–∫ B</h2>
                      <DeckChoice value={pre.d1} onChange={(v) => setPre((s) => ({ ...s, d1: v }))} />
                    </div>
                  </div>
                  <div className="mt-4 flex gap-2">
                    <button onClick={start} className="px-4 py-2 rounded-xl bg-blue-500 hover:bg-blue-600">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
                    <button onClick={reset} className="px-4 py-2 rounded-xl bg-slate-700 hover:bg-slate-600">–°–±—Ä–æ—Å</button>
                  </div>
                </div>
              ) : (
                <>

                  {/* Fixed sidebar with controls */}
                  <div className="fixed right-3 top-3 z-40 space-y-2">
                    <div className="px-3 py-2 rounded-xl bg-slate-800/90 border border-slate-700">Turn: {gs.turn}</div>
                    <div className="px-3 py-2 rounded-xl bg-slate-800/90 border border-slate-700">Active: {gs.players[gs.active].name}</div>
                    <ManaBar mana={gs.players[gs.active].mana} gain={manaGain?.player===gs.active?manaGain.count:0} onGainShown={()=>setManaGain(null)} />
                    <div className="px-3 py-2 rounded-xl bg-slate-800/90 border border-slate-700">Control: A {countControlled(gs,0)} ‚Ä¢ B {countControlled(gs,1)}</div>
                    <div className="flex gap-2"><button onClick={endTurn} disabled={gs.winner != null} className="px-4 py-2 rounded-xl bg-amber-500 hover:bg-amber-600 disabled:opacity-50">End Turn</button><button onClick={()=>setShowLog(s=>!s)} className="px-4 py-2 rounded-xl bg-slate-700 hover:bg-slate-600">{showLog?"Hide Log":"Log"}</button></div>
                    <div className="flex gap-2"><button onClick={()=>setShowHelp(true)} className="px-4 py-2 rounded-xl bg-slate-700 hover:bg-slate-600">Help</button><button onClick={()=>setShowLegendPanel(true)} className="px-4 py-2 rounded-xl bg-slate-700 hover:bg-slate-600">Legend</button><button onClick={reset} className="px-4 py-2 rounded-xl bg-slate-700 hover:bg-slate-600">New</button></div>
                  </div>

                    <div className="scene mt-6" onMouseMove={onSceneMove} onMouseLeave={onSceneLeave}>
                    <div className="grid grid-cols-3 gap-2 md:gap-3 max-w-[900px] mx-auto board3d" style={{ transform: `rotateX(${18 + tilt.rx}deg) rotateY(${tilt.ry}deg) translateY(${boardY}px)` }}>
                      {Array.from({ length: 3 }).map((_, r) => (
                        <Fragment key={r}>
                          {Array.from({ length: 3 }).map((__, c) => renderCell(r, c))}
                        </Fragment>
                      ))}
                    </div>
                  </div>

                  {/* –†—É–∫–∞ –∏–≥—Ä–æ–∫–∞ ‚Äî —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–Ω–∏–∑—É, –≤–µ–µ—Ä–æ–º */}
                  <div className="hand">
                     {(() => {
                      const cards = gs.players[gs.active].hand.filter(Boolean);
                      const n = cards.length;
                      const spread = Math.min(60, Math.max(32, 480 / (n + 4))); // px
                      const angleSpread = Math.min(8, 28 / (n + 1)); // deg
                      return cards.map((card, idx) => {
                        const offset = (idx - (n - 1) / 2) * spread;
                        const ang = (idx - (n - 1) / 2) * angleSpread;
                        return (
                          <div
                            key={idx}
                            className="hand-card"
                            onMouseEnter={()=>setHandHover(idx)}
                            onMouseLeave={()=>setHandHover(null)}
                            style={{ left: `calc(50% + ${offset}px)`, transform: `translateX(-50%) rotate(${ang}deg)` , zIndex: (handHover===idx?2000:1000) + idx }}
                          >
                            <div
                              draggable={card.type === 'UNIT'}
                              onDragStart={(e) => {
                                setDragIdx(idx);
                                e.currentTarget.classList.add('dragging');
                                // –ü–æ–ª–Ω–æ—Å—Ç—å—é —É–±—Ä–∞—Ç—å –Ω–∞—Ç–∏–≤–Ω—ã–π –ø–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π ghost –∏ —Ä–∏—Å–æ–≤–∞—Ç—å —Å–≤–æ–π –æ–≤–µ—Ä–ª–µ–π
                                const img = new Image();
                                img.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8Xw8AAoMBgVIH8t0AAAAASUVORK5CYII=';
                                e.dataTransfer.setDragImage(img, 0, 0);
                                e.dataTransfer.dropEffect='copy';
                                e.dataTransfer.effectAllowed='copyMove';
                                // –ü–æ–∫–∞–∑–∞—Ç—å –Ω–∞—à –æ–≤–µ—Ä–ª–µ–π –ø–æ–¥ –∫—É—Ä—Å–æ—Ä–æ–º
                                setDragOverlay({ card, x: e.clientX, y: e.clientY, tiltX: 0, tiltY: 0, angle: 0 });
                                dragPrevRef.current = { x: e.clientX, y: e.clientY, t: performance.now() };
                              }}
                              onDrag={(e)=>{
                                if (!dragOverlay) return;
                                const cx = e.clientX || e.pageX; const cy = e.clientY || e.pageY;
                                if (!cx && !cy) return;
                                const now = performance.now();
                                const dt = Math.max(1, now - dragPrevRef.current.t);
                                const vx = (cx - dragPrevRef.current.x) / dt; // px per ms
                                const vy = (cy - dragPrevRef.current.y) / dt;
                                const clamp = (v, a) => Math.max(-a, Math.min(a, v));
                                const tiltX = clamp(-vy * 120, 10); // up/down tilt
                                const tiltY = clamp(vx * 120, 10);  // left/right tilt
                                const angle = clamp(vx * -30, 8);
                                setDragOverlay((s)=> s ? { ...s, x: cx, y: cy, tiltX, tiltY, angle } : s);
                                dragPrevRef.current = { x: cx, y: cy, t: now };
                              }}
                              onDragEnd={(e) => {
                                setDragIdx(null);
                                e.currentTarget.classList.remove('dragging');
                                setDragOverlay(null);
                              }}
                              className={`relative overflow-hidden text-left p-3 rounded-xl border ${gs.selectedCard?.index === idx ? 'border-blue-400' : 'border-slate-700'} bg-slate-800/90 hover:bg-slate-700 w-[240px] cursor-grab active:cursor-grabbing card3d`}
                              style={{ transformStyle: 'preserve-3d', transform: handHover===idx? 'translateZ(30px) scale(1.08)': undefined }}
                             >
                               <CardFace card={{...card, desc: card.desc || card.text }} />
                              {card.type === 'SPELL' && (
                                <button
                                  onClick={() => { const n = structuredClone(gs); n.selectedCard = { index: idx }; setGs(n); }}
                                  className="mt-2 px-3 py-1 rounded-lg bg-blue-600"
                                >
                                  –í—ã–±—Ä–∞—Ç—å –¥–ª—è –∫–∞—Å—Ç–∞
                                </button>
                              )}
                            </div>
                          </div>
                        );
                      });
                    })()}
                  </div>

                  {dropSpot && (
                    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
                      <div className="bg-slate-800 border border-slate-700 rounded-2xl p-4 w-[320px] card3d" style={{ transform: "translateZ(30px)" }}>
                          <div className="text-center mb-3">–í—ã–±–µ—Ä–∏—Ç–µ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—é</div>
                          <div className="grid grid-cols-3 gap-2 w-[220px] mx-auto">
                            <div></div>
                            <button className="p-3 rounded-xl bg-slate-700 hover:bg-slate-600" onClick={() => placeUnitWithFacing(dropSpot.r, dropSpot.c, dropSpot.idx, 'N')} title="–°–µ–≤–µ—Ä">{dirIcon['N']}</button>
                            <div></div>
                            <button className="p-3 rounded-xl bg-slate-700 hover:bg-slate-600" onClick={() => placeUnitWithFacing(dropSpot.r, dropSpot.c, dropSpot.idx, 'W')} title="–ó–∞–ø–∞–¥">{dirIcon['W']}</button>
                            <div className="p-3 rounded-xl bg-slate-800/60 text-center select-none">‚Ä¢</div>
                            <button className="p-3 rounded-xl bg-slate-700 hover:bg-slate-600" onClick={() => placeUnitWithFacing(dropSpot.r, dropSpot.c, dropSpot.idx, 'E')} title="–í–æ—Å—Ç–æ–∫">{dirIcon['E']}</button>
                            <div></div>
                            <button className="p-3 rounded-xl bg-slate-700 hover:bg-slate-600" onClick={() => placeUnitWithFacing(dropSpot.r, dropSpot.c, dropSpot.idx, 'S')} title="–Æ–≥">{dirIcon['S']}</button>
                            <div></div>
                          </div>
                        <div className="mt-3 text-center">
                          <button className="px-3 py-1 rounded-xl bg-slate-700" onClick={() => setDropSpot(null)}>–û—Ç–º–µ–Ω–∞</button>
                        </div>
                      </div>
                    </div>
                  )}

                  {dragOverlay && (
                    <div className="fixed z-[2000] pointer-events-none" style={{ left: dragOverlay.x, top: dragOverlay.y }}>
                      <div style={{ transformStyle: 'preserve-3d', transform: `translate(-50%,-60%) rotate(${dragOverlay.angle}deg) rotateX(${dragOverlay.tiltX}deg) rotateY(${dragOverlay.tiltY}deg)`, transition: 'transform 60ms linear' }}>
                        <CardFace card={dragOverlay.card} />
                      </div>
                    </div>
                  )}

                  {unitAction && (() => {
                    const { r, c } = unitAction;
                    const u = gs.board[r][c].unit;
                    const tpl = CARDS[u.tplId];
                    const already = u.lastAttackTurn === gs.turn;
                    return (
                      <div className="fixed inset-0 bg-black/40 flex items-center justify-center z-50">
                        <div className="bg-slate-800 border border-slate-700 rounded-2xl p-4 w-[380px] space-y-2 card3d" style={{ transform: "translateZ(30px)" }}>
                          <div className="text-center mb-1">–î–µ–π—Å—Ç–≤–∏–µ –Ω–∞–¥: {tpl.name} ({r + 1},{c + 1})</div>
                              <button
                                className="w-full px-3 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500 disabled:opacity-50"
                                disabled={already || computeHits(gs, r, c).length===0}
                                onClick={() => {
                                  const n = structuredClone(gs);
                                  const pl = n.players[n.active];
                                  const cost = attackCost(CARDS[u.tplId]);
                                  // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–µ–π –î–û —Å–ø–∏—Å–∞–Ω–∏—è –º–∞–Ω—ã
                                  const plannedHits = computeHits(n, r, c);
                                  if (!plannedHits.length) {
                                    addLog('–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ü–µ–ª–µ–π –¥–ª—è –∞—Ç–∞–∫–∏.');
                                    setUnitAction(null);
                                    setGs(n);
                                    return;
                                  }
                                  if (pl.mana < cost) {
                                    addLog(`–ù—É–∂–Ω–æ ${cost} –º–∞–Ω—ã –¥–ª—è –∞—Ç–∞–∫–∏.`);
                                    setUnitAction(null);
                                    setGs(n);
                                    return;
                                  }
                                  pl.mana -= cost;
                                  // If magic unit: enter targeting mode instead of immediate battle
                                  if (CARDS[u.tplId].attackType === 'MAGIC') {
                                    setGs(n);
                                    setUnitAction(null);
                                    setMagicTarget({ from: { r, c } });
                                  } else {
                                    setGs(n);
                                    setUnitAction(null);
                                    beginBattleSequence(r, c, true);
                                  }
                                }}
                              >
                                {CARDS[u.tplId].attackType === 'MAGIC' ? '–ê—Ç–∞–∫–æ–≤–∞—Ç—å (–º–∞–≥–∏—è: –≤—ã–±–æ—Ä —Ü–µ–ª–∏)' : '–ê—Ç–∞–∫–æ–≤–∞—Ç—å'} (‚àí{attackCost(tpl)} –º–∞–Ω–∞){already ? " ‚Äî —É–∂–µ –∞—Ç–∞–∫–æ–≤–∞–ª" : ""}
                              </button>
                          <div className="grid grid-cols-2 gap-2">
                            <button
                              className="px-3 py-2 rounded-xl bg-slate-700 hover:bg-slate-600"
                              onClick={() => {
                                const n = structuredClone(gs);
                                const U = n.board[r][c].unit;
                                U.facing = turnCW[U.facing];
                                setGs(n);
                                setUnitAction(null);
                              }}
                            >
                              –ü–æ–≤–µ—Ä–Ω—É—Ç—å ‚Ü∑
                            </button>
                            <button
                              className="px-3 py-2 rounded-xl bg-slate-700 hover:bg-slate-600"
                              onClick={() => {
                                const n = structuredClone(gs);
                                const U = n.board[r][c].unit;
                                U.facing = turnCCW[U.facing];
                                setGs(n);
                                setUnitAction(null);
                              }}
                            >
                              –ü–æ–≤–µ—Ä–Ω—É—Ç—å ‚Ü∂
                            </button>
                          </div>
                          <button className="w-full px-3 py-2 rounded-xl bg-slate-700" onClick={() => setUnitAction(null)}>–ù–∏—á–µ–≥–æ</button>
                        </div>
                      </div>
                    );
                  })()}

                   {battle.show && (
                    <div className="fixed inset-0 flex items-center justify-center z-40 pointer-events-none">
                      <div className="text-6xl font-extrabold bg-gradient-to-br from-red-600/80 to-yellow-500/80 px-10 py-5 rounded-3xl battlePop shadow-2xl ring-4 ring-yellow-400/40">{battle.text}</div>
                    </div>
                  )}

                   {turnBanner && (
                     <div className="fixed inset-0 flex items-center justify-center z-40 pointer-events-none">
                      <div className="turnBanner text-3xl md:text-5xl font-extrabold bg-gradient-to-br from-blue-600/80 to-cyan-500/80 px-6 md:px-10 py-4 md:py-5 rounded-3xl shadow-2xl ring-4 ring-cyan-400/30">
                         Turn {turnBanner.turn} ‚Äî {turnBanner.playerName}
                       </div>
                     </div>
                   )}

                  {preview.show && preview.tpl && (
                    <div className="fixed z-[70]" style={{ left: preview.x, top: preview.y }}>
                      <div className="rounded-2xl border border-slate-600 bg-slate-900/95 p-3 w-[260px] shadow-2xl">
                        <div className="text-sm opacity-70 mb-1">{preview.tpl.type} ‚Ä¢ {elementEmoji[preview.tpl.element]}</div>
                        <div className="font-semibold mb-1">{preview.tpl.name}</div>
                        {preview.tpl.type === "UNIT" && (
                          <>
                            <div className="text-sm mb-1">ATK/HP: {preview.tpl.atk}/{preview.tpl.hp}</div>
                            <div className="text-sm mb-1">–ü—Ä–∏–∑—ã–≤: {preview.tpl.cost} ‚Ä¢ –ê—Ç–∞–∫–∞: {attackCost(preview.tpl)}</div>
                            <div className="text-2xl">{dirsForPattern("N", preview.tpl.pattern || "FRONT").map(d => dirIcon[d]).join(" ")}</div>
                          </>
                        )}
                        {preview.tpl.type === "SPELL" && (
                          <div className="text-xs opacity-80">{preview.tpl.text}</div>
                        )}
                      </div>
                    </div>
                  )}
                </>
              )}
            </div>

            {/* –ü–∞–Ω–µ–ª–∏ –ø–æ –∫–Ω–æ–ø–∫–∞–º */}
            {showLog && (
              <div className="fixed right-3 top-3 bg-slate-800/90 border border-slate-700 rounded-2xl p-3 w-[360px] h-[420px] overflow-auto z-[60]">
                <div className="flex items-center justify-between mb-2"><h2 className="font-medium">–ñ—É—Ä–Ω–∞–ª</h2><button className="px-2 py-1 bg-slate-700 rounded" onClick={()=>setShowLog(false)}>√ó</button></div>
                <div className="space-y-1 text-sm">{log.map((line, i) => (<div key={i} className="opacity-90">‚Ä¢ {line}</div>))}</div>
              </div>
            )}
            {showHelp && (
              <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-[55]">
                <div className="bg-slate-800 border border-slate-700 rounded-2xl p-4 w-[520px]">
                  <div className="flex items-center justify-between mb-2"><h2 className="font-medium">–ü–æ–¥—Å–∫–∞–∑–∫–∏</h2><button className="px-2 py-1 bg-slate-700 rounded" onClick={()=>setShowHelp(false)}>–ó–∞–∫—Ä—ã—Ç—å</button></div>
                  <ul className="text-sm list-disc pl-5 space-y-1 opacity-90">
                    <li>–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –∫–∞—Ä—Ç—É —Å—É—â–µ—Å—Ç–≤–∞ –Ω–∞ –∫–ª–µ—Ç–∫—É, –∑–∞—Ç–µ–º –≤—ã–±–µ—Ä–∏—Ç–µ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—é. –ï—Å–ª–∏ –µ—Å—Ç—å —Ü–µ–ª—å ‚Äî –ø—Ä–æ–∏–∑–æ–π–¥—ë—Ç –±–µ—Å–ø–ª–∞—Ç–Ω–∞—è –∞—Ç–∞–∫–∞.</li>
                    <li>–ö–ª–∏–∫ –ø–æ —Å–≤–æ–µ–º—É —Å—É—â–µ—Å—Ç–≤—É ‚Äî –º–µ–Ω—é: –∞—Ç–∞–∫–æ–≤–∞—Ç—å (—Å—Ç–æ–∏–º–æ—Å—Ç—å = –ø—Ä–∏–∑—ã–≤‚àí1), –ø–æ–≤–µ—Ä–Ω—É—Ç—å ‚Ü∑/‚Ü∂.</li>
                    <li>–ó–∞–∫–ª–∏–Ω–∞–Ω–∏–µ: –Ω–∞–∂–º–∏—Ç–µ –∫–∞—Ä—Ç—É –≤ —Ä—É–∫–µ, –∑–∞—Ç–µ–º –∫–ª–∏–∫–Ω–∏—Ç–µ —Ü–µ–ª—å.</li>
                    <li>–ü–æ–±–µ–¥–∞: –∫ –∫–æ–Ω—Ü—É —Å–≤–æ–µ–≥–æ —Ö–æ–¥–∞ –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–π—Ç–µ 5+ –∫–ª–µ—Ç–æ–∫.</li>
                  </ul>
                </div>
              </div>
            )}
            {showLegendPanel && (
              <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-[55]">
                <div className="bg-slate-800 border border-slate-700 rounded-2xl p-4 w-[420px]">
                  <div className="flex items-center justify-between mb-2"><h2 className="font-medium">–õ–µ–≥–µ–Ω–¥–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤</h2><button className="px-2 py-1 bg-slate-700 rounded" onClick={()=>setShowLegendPanel(false)}>–ó–∞–∫—Ä—ã—Ç—å</button></div>
                  <div className="grid grid-cols-2 gap-2 text-sm opacity-90">
                    {["FIRE", "WATER", "EARTH", "FOREST"].map((e) => (
                      <div key={e} className="flex items-center gap-2">
                        <span>{elementEmoji[e]}</span>
                        <span>{labelElement(e)}</span>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
      );
    }

    // –†–µ–Ω–¥–µ—Ä –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>
