<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Eye of Grid ‚Äî Complete 3D</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #0f172a; color: #e2e8f0; font-family: system-ui, sans-serif; }
    #ui { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
    .ui-panel { pointer-events: auto; }
    #three-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }
    
    /* –ú–∞–Ω–∞ –æ—Ä–±—ã */
    .mana-bar { display: flex; gap: 6px; align-items: center; }
    .mana-orb { 
      width: 18px; height: 18px; border-radius: 50%; 
      background: radial-gradient(circle at 30% 30%, #fff, #8bd5ff 30%, #1ea0ff 70%, #0a67b7); 
      box-shadow: 0 0 10px rgba(30,160,255,0.8); 
    }
    .mana-slot { 
      width: 18px; height: 18px; border-radius: 50%; 
      border: 1px solid rgba(255,255,255,0.25); 
      background: rgba(255,255,255,0.06); 
      box-shadow: inset 0 2px 6px rgba(0,0,0,0.5); 
    }
    
    /* –ü–∞–Ω–µ–ª–∏ */
    .overlay-panel { background: rgba(30, 41, 59, 0.95); backdrop-filter: blur(10px); border: 1px solid rgba(148, 163, 184, 0.3); border-radius: 16px; }
    /* –û–≤–µ—Ä–ª–µ–∏ –±–∞–Ω–Ω–µ—Ä–æ–≤ */
    .banner { pointer-events:none; }
    .turnBanner { animation: turnslide 2600ms ease-in-out both; }
    @keyframes turnslide { 0%{ transform:translateX(-120%)} 20%{ transform:translateX(0)} 80%{ transform:translateX(0)} 100%{ transform:translateX(140%) } }
    .battlePop { animation: pop 1100ms ease both; }
    @keyframes pop { 0%{ transform:scale(.6); opacity:0 } 40%{ transform:scale(1.06); opacity:1 } 100%{ transform:scale(1); opacity:.96 } }
  </style>
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
</head>
<body>
  <canvas id="three-canvas"></canvas>
  
  <div id="ui">
    <!-- –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–Ω—Ç—Ä–æ–ª—ã -->
    <div id="controls" class="ui-panel fixed right-4 top-4 space-y-3 z-20">
      <div class="overlay-panel px-4 py-2 text-sm">
        <div id="turn-info">–•–æ–¥: 1</div>
        <div id="active-player">–ê–∫—Ç–∏–≤–Ω—ã–π: –ò–≥—Ä–æ–∫ A</div>
      </div>
      
      <div class="overlay-panel px-4 py-2">
        <div class="text-sm mb-2">–ú–∞–Ω–∞:</div>
        <div class="mana-bar" id="mana-display"></div>
      </div>
      
      <div class="overlay-panel px-4 py-2 text-sm" id="control-info">
        –ö–æ–Ω—Ç—Ä–æ–ª—å: A 0 ‚Ä¢ B 0
      </div>
      
      <div class="flex gap-2">
        <button id="end-turn-btn" class="overlay-panel px-4 py-2 text-sm bg-amber-600 hover:bg-amber-700 transition-colors">
          –ó–∞–≤–µ—Ä—à–∏—Ç—å —Ö–æ–¥
        </button>
        <button id="log-btn" class="overlay-panel px-4 py-2 text-sm bg-slate-600 hover:bg-slate-700 transition-colors">
          –õ–æ–≥
        </button>
      </div>
      
      <div class="flex gap-2">
        <button id="help-btn" class="overlay-panel px-4 py-2 text-sm bg-slate-600 hover:bg-slate-700 transition-colors">
          –ü–æ–º–æ—â—å
        </button>
        <button id="new-game-btn" class="overlay-panel px-4 py-2 text-sm bg-slate-600 hover:bg-slate-700 transition-colors">
          –ù–æ–≤–∞—è –∏–≥—Ä–∞
        </button>
      </div>
    </div>
    
    <!-- –ü–∞–Ω–µ–ª—å –ª–æ–≥–æ–≤ -->
    <div id="log-panel" class="ui-panel fixed right-4 w-96 h-96 overlay-panel p-4 hidden z-30" style="top: 260px;">
      <div class="flex justify-between items-center mb-3">
        <h3 class="text-lg font-semibold">–ñ—É—Ä–Ω–∞–ª —Å–æ–±—ã—Ç–∏–π</h3>
        <button id="close-log-btn" class="text-xl">&times;</button>
      </div>
      <div id="log-content" class="h-full overflow-y-auto text-sm space-y-1"></div>
    </div>
    
    <!-- –ü–∞–Ω–µ–ª—å –ø–æ–º–æ—â–∏ -->
    <div id="help-panel" class="ui-panel fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden z-40">
      <div class="overlay-panel p-6 max-w-lg">
        <div class="flex justify-between items-center mb-4">
          <h3 class="text-xl font-semibold">–ö–∞–∫ –∏–≥—Ä–∞—Ç—å</h3>
          <button id="close-help-btn" class="text-xl">&times;</button>
        </div>
        <div class="space-y-3 text-sm">
          <p>‚Ä¢ –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–π—Ç–µ –∫–∞—Ä—Ç—ã —Å—É—â–µ—Å—Ç–≤ –Ω–∞ –∏–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ</p>
          <p>‚Ä¢ –í—ã–±–∏—Ä–∞–π—Ç–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ—Å–ª–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è</p>
          <p>‚Ä¢ –ö–ª–∏–∫–∞–π—Ç–µ –ø–æ —Å–≤–æ–∏–º —Å—É—â–µ—Å—Ç–≤–∞–º –¥–ª—è –∞—Ç–∞–∫–∏ –∏–ª–∏ –ø–æ–≤–æ—Ä–æ—Ç–∞</p>
          <p>‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∑–∞–∫–ª–∏–Ω–∞–Ω–∏—è, –≤—ã–±—Ä–∞–≤ –∫–∞—Ä—Ç—É –∏ —Ü–µ–ª—å</p>
          <p>‚Ä¢ –ü–æ–±–µ–¥–∞: –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–π—Ç–µ 5+ –∫–ª–µ—Ç–æ–∫ –≤ –∫–æ–Ω—Ü–µ —Ö–æ–¥–∞</p>
        </div>
      </div>
    </div>
    
    <!-- –ü–∞–Ω–µ–ª—å –≤—ã–±–æ—Ä–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è -->
    <div id="orientation-panel" class="ui-panel fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden z-40">
      <div class="overlay-panel p-6">
        <div class="text-center mb-4">–í—ã–±–µ—Ä–∏—Ç–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</div>
        <div class="grid grid-cols-3 gap-2 w-48 mx-auto">
          <div></div>
          <button data-dir="N" class="overlay-panel px-4 py-2 hover:bg-slate-700">‚Üë</button>
          <div></div>
          <button data-dir="W" class="overlay-panel px-4 py-2 hover:bg-slate-700">‚Üê</button>
          <div class="overlay-panel px-4 py-2 text-center">‚Ä¢</div>
          <button data-dir="E" class="overlay-panel px-4 py-2 hover:bg-slate-700">‚Üí</button>
          <div></div>
          <button data-dir="S" class="overlay-panel px-4 py-2 hover:bg-slate-700">‚Üì</button>
          <div></div>
        </div>
        <div class="text-center mt-4">
          <button id="cancel-orient-btn" class="overlay-panel px-4 py-2 bg-red-600 hover:bg-red-700">–û—Ç–º–µ–Ω–∞</button>
        </div>
      </div>
    </div>
    
    <!-- –ü–∞–Ω–µ–ª—å –¥–µ–π—Å—Ç–≤–∏–π —Å —Å—É—â–µ—Å—Ç–≤–æ–º -->
    <div id="unit-action-panel" class="ui-panel fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden z-40">
      <div class="overlay-panel p-6 space-y-3">
        <div id="unit-info" class="text-center mb-4"></div>
        <button id="attack-btn" class="w-full overlay-panel px-4 py-2 bg-red-600 hover:bg-red-700">–ê—Ç–∞–∫–æ–≤–∞—Ç—å</button>
        <div class="grid grid-cols-2 gap-2">
          <button id="rotate-cw-btn" class="overlay-panel px-4 py-2 hover:bg-slate-700">–ü–æ–≤–µ—Ä–Ω—É—Ç—å ‚Üª</button>
          <button id="rotate-ccw-btn" class="overlay-panel px-4 py-2 hover:bg-slate-700">–ü–æ–≤–µ—Ä–Ω—É—Ç—å ‚Ü∫</button>
        </div>
        <button id="cancel-action-btn" class="w-full overlay-panel px-4 py-2 bg-gray-600 hover:bg-gray-700">–û—Ç–º–µ–Ω–∞</button>
      </div>
    </div>
    
    <!-- –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è -->
    <div id="notifications" class="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-50 pointer-events-none"></div>

    <!-- –ë–∞–Ω–Ω–µ—Ä—ã: Turn –∏ Battle -->
    <div id="turn-banner" class="banner fixed inset-0 hidden items-center justify-center z-40">
      <div class="turnBanner text-3xl md:text-5xl font-extrabold bg-gradient-to-br from-blue-600/80 to-cyan-500/80 px-6 md:px-10 py-4 md:py-5 rounded-3xl shadow-2xl ring-4 ring-cyan-400/30"></div>
    </div>
    <div id="battle-banner" class="banner fixed inset-0 hidden items-center justify-center z-40">
      <div class="battlePop text-5xl font-extrabold bg-gradient-to-br from-red-600/80 to-yellow-500/80 px-10 py-5 rounded-3xl shadow-2xl ring-4 ring-yellow-400/40">BATTLE</div>
    </div>
  </div>

  <script>
    // ====== –ò–ì–†–û–í–ê–Ø –õ–û–ì–ò–ö–ê (–ø–æ–ª–Ω–∞—è –≤–µ—Ä—Å–∏—è –∏–∑ 2D) ======
    
    const DIR_VECTORS = { N: [-1, 0], E: [0, 1], S: [1, 0], W: [0, -1] };
    const OPPOSITE_ELEMENT = { FIRE: 'WATER', WATER: 'FIRE', EARTH: 'FOREST', FOREST: 'EARTH' };
    const elementEmoji = { FIRE: 'üî•', WATER: 'üíß', EARTH: 'ü™®', FOREST: 'üå≤' };
    const turnCW = { N: 'E', E: 'S', S: 'W', W: 'N' };
    const turnCCW = { N: 'W', W: 'S', S: 'E', E: 'N' };
    // –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è–µ–º –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏: N –¥–æ–ª–∂–µ–Ω —Å–º–æ—Ç—Ä–µ—Ç—å –∫ –≤–µ—Ä—Ö–Ω–µ–º—É –∫—Ä–∞—é (‚àíZ), S ‚Äî –∫ –Ω–∏–∂–Ω–µ–º—É (+Z)
    // –í three.js ¬´–≤–ø–µ—Ä—ë–¥¬ª –º–µ—à–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —ç—Ç–æ +Z (0¬∞), –ø–æ—ç—Ç–æ–º—É:
    // S: 0¬∞, E: -90¬∞, W: 90¬∞, N: 180¬∞
    // –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: N (—Å—Ç—Ä–µ–ª–∫–∞ –≤–≤–µ—Ä—Ö) = 0¬∞, S (—Å—Ç—Ä–µ–ª–∫–∞ –≤–Ω–∏–∑) = 180¬∞; E/W –æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –µ—Å—Ç—å
    const facingDeg = { N: 0, E: -90, S: 180, W: 90 };
    
    const uid = () => Math.random().toString(36).slice(2, 9);
    const inBounds = (r, c) => r >= 0 && r < 3 && c >= 0 && c < 3;
    const capMana = (m) => Math.min(10, m);
    const attackCost = (tpl) => (tpl.activation != null ? tpl.activation : Math.max(0, (tpl.cost || 0) - 1));
    
    // –ö–∞—Ä—Ç—ã
    const CARDS = {
      // Fire Set (—é–Ω–∏—Ç—ã)
      FIRE_FLAME_MAGUS: { id:'FIRE_FLAME_MAGUS', name:'Flame Magus', type:'UNIT', cost:1, activation:1, element:'FIRE', atk:1, hp:1, pattern:'FRONT', range:3, attackType:'MAGIC', blindspots:['N','E','S','W'], desc:'Magic Attack: target any creature; no retaliation.' },
      FIRE_HELLFIRE_SPITTER: { id:'FIRE_HELLFIRE_SPITTER', name:'Hellfire Spitter', type:'UNIT', cost:1, activation:1, element:'FIRE', atk:1, hp:1, pattern:'ALL', range:1, firstStrike:true, blindspots:[], desc:'Quickness: always strikes first.' },
      FIRE_FREEDONIAN: { id:'FIRE_FREEDONIAN', name:'Freedonian Wanderer', type:'UNIT', cost:2, activation:1, element:'FIRE', atk:1, hp:2, pattern:'FRONT', range:1, blindspots:['S'], auraGainManaOnSummon:true, desc:'While not on Fire tile, you gain 1 mana on allied summon.' },
      FIRE_FLAME_LIZARD: { id:'FIRE_FLAME_LIZARD', name:'Partmole Flame Lizard', type:'UNIT', cost:2, activation:1, element:'FIRE', atk:2, hp:2, pattern:'FRONT', range:1, blindspots:['S'], firstStrike:true, desc:'Quickness.' },
      FIRE_GREAT_MINOS: { id:'FIRE_GREAT_MINOS', name:'Great Minos of Sciondar', type:'UNIT', cost:3, activation:2, element:'FIRE', atk:2, hp:1, pattern:'FRONT', range:2, blindspots:['S'], dodge50:true, diesOffElement:'FIRE', desc:'Dodge 50% (non-magic). Destroy if not on Fire tile.' },
      FIRE_FLAME_ASCETIC: { id:'FIRE_FLAME_ASCETIC', name:'Flame Ascetic', type:'UNIT', cost:3, activation:2, element:'FIRE', atk:2, hp:3, pattern:'FRONT', range:1, blindspots:['S'], randomPlus2:true, desc:'Attack +2 half the time.' },
      FIRE_TRICEPTAUR: { id:'FIRE_TRICEPTAUR', name:'Triceptaur Behemoth', type:'UNIT', cost:5, activation:4, element:'FIRE', atk:5, hp:4, pattern:'FRONT_SIDES', range:1, blindspots:['S'], penaltyByTargets:true, desc:'If attacks 2 creatures, -2 ATK; if 3 creatures, -4 ATK.' },
      FIRE_PURSUER: { id:'FIRE_PURSUER', name:'Pursuer of Saint Dhees', type:'UNIT', cost:6, activation:3, element:'FIRE', atk:5, hp:4, pattern:'FRONT', range:1, blindspots:['S'], dynamicAtk:'OTHERS_ON_BOARD', desc:'ATK = 5 + number of other creatures on board.' },
      // –°–ø–µ–ª–ª—ã –∏–∑ –¥—Ä—É–≥–∏—Ö –Ω–∞–±–æ—Ä–æ–≤ (–∏–∑ 2D)
      FREEZE_STREAM: { id:'FREEZE_STREAM', name:'–°—Ç—ã–ª—ã–π –ø–æ—Ç–æ–∫', type:'SPELL', cost:2, element:'WATER', text:'–ù–∞–Ω–æ—Å–∏—Ç 1 —É—Ä–æ–Ω–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–º—É —é–Ω–∏—Ç—É.' },
      RAISE_STONE: { id:'RAISE_STONE', name:'–ü–æ–¥—ä—ë–º –ø–æ—Ä–æ–¥—ã', type:'SPELL', cost:2, element:'EARTH', text:'+2 HP –¥—Ä—É–∂–µ—Å—Ç–≤–µ–Ω–Ω–æ–º—É —é–Ω–∏—Ç—É.' },
      WIND_SHIFT: { id:'WIND_SHIFT', name:'–õ–µ—Å–Ω–æ–π –ø–æ—Ä—ã–≤', type:'SPELL', cost:2, element:'FOREST', text:'–ü–æ–≤–µ—Ä–Ω—É—Ç—å –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —é–Ω–∏—Ç–∞ –ø–æ —á–∞—Å–æ–≤–æ–π —Å—Ç—Ä–µ–ª–∫–µ.' }
    };
    
    // –°—Ç–∞—Ä—Ç–µ—Ä: —Ç–æ–ª—å–∫–æ Fire Set + –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–ø–µ–ª–ª–æ–≤
    const STARTER_FIRESET = [
      CARDS.FIRE_FLAME_MAGUS,
      CARDS.FIRE_HELLFIRE_SPITTER,
      CARDS.FIRE_FREEDONIAN,
      CARDS.FIRE_FLAME_LIZARD,
      CARDS.FIRE_GREAT_MINOS,
      CARDS.FIRE_FLAME_ASCETIC,
      CARDS.FIRE_TRICEPTAUR,
      CARDS.FIRE_PURSUER,
      CARDS.FIRE_FLAME_MAGUS,
      CARDS.FIRE_HELLFIRE_SPITTER,
      CARDS.FIRE_FLAME_LIZARD,
      CARDS.FIRE_FREEDONIAN,
      CARDS.FREEZE_STREAM,
      CARDS.RAISE_STONE,
      CARDS.WIND_SHIFT
    ];
    
    // –§—É–Ω–∫—Ü–∏–∏ –∏–≥—Ä–æ–≤–æ–π –ª–æ–≥–∏–∫–∏
    const dirsForPattern = (facing, pattern) => {
      const f = facing, l = turnCCW[f], r = turnCW[f];
      if (pattern === 'FRONT') return [f];
      if (pattern === 'SIDES') return [l, r];
      if (pattern === 'ALL') return ['N', 'E', 'S', 'W'];
      return [f, l, r];
    };
    
    const computeCellBuff = (cellElement, unitElement) => {
      if (cellElement === unitElement) return { atk: 0, hp: 2 };
      const opp = OPPOSITE_ELEMENT[unitElement];
      if (cellElement === opp) return { atk: 0, hp: -2 };
      return { atk: 0, hp: 0 };
    };
    
    const effectiveStats = (cell, unit) => {
      const tpl = CARDS[unit.tplId];
      const buff = computeCellBuff(cell.element, tpl.element);
      return { 
        atk: (tpl.atk || 0) + buff.atk, 
        hp: (tpl.hp || 0) + buff.hp 
      };
    };
    
    const randomBoard = () => {
      const elements = ['FIRE', 'WATER', 'EARTH', 'FOREST'];
      return Array.from({ length: 3 }, () => 
        Array.from({ length: 3 }, () => ({ 
          element: elements[Math.floor(Math.random() * elements.length)] 
        }))
      );
    };
    
    const shuffle = (array) => {
      const result = [...array];
      for (let i = result.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [result[i], result[j]] = [result[j], result[i]];
      }
      return result;
    };
    
    const drawOne = (gameState, player) => {
      if (!gameState.players[player].deck.length) return;
      const card = gameState.players[player].deck.shift();
      if (card) gameState.players[player].hand.push(card);
    };
    
    const countControlled = (gameState, player) => {
      let count = 0;
      for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 3; c++) {
          if (gameState.board[r][c].unit?.owner === player) count++;
        }
      }
      return count;
    };
    
    const startGame = (deck0, deck1) => {
      const gameState = {
        board: randomBoard(),
        players: [
          { 
            name: '–ò–≥—Ä–æ–∫ A', 
            deck: shuffle(deck0.filter(Boolean)), 
            hand: [], 
            discard: [], 
            mana: 2 
          },
          { 
            name: '–ò–≥—Ä–æ–∫ B', 
            deck: shuffle(deck1.filter(Boolean)), 
            hand: [], 
            discard: [], 
            mana: 0 
          }
        ],
        active: 0,
        turn: 1,
        selectedCard: null,
        pending: null,
        winner: null
      };
      
      for (let i = 0; i < 5; i++) {
        drawOne(gameState, 0);
        drawOne(gameState, 1);
      }
      
      return gameState;
    };
    
    // ====== –ë–û–ï–í–ê–Ø –°–ò–°–¢–ï–ú–ê (–ø–æ—Ä—Ç –∏–∑ 2D) ======
    function hasAdjacentGuard(state, r, c) {
      const target = state.board[r][c].unit;
      if (!target) return false;
      for (const [dr, dc] of Object.values(DIR_VECTORS)) {
        const nr = r + dr, nc = c + dc;
        if (!inBounds(nr, nc)) continue;
        const u = state.board[nr][nc].unit;
        if (u && u.owner === target.owner && (CARDS[u.tplId].keywords || []).includes('GUARD')) return true;
      }
      return false;
    }
    
    function computeHits(state, r, c) {
      const attacker = state.board[r][c].unit;
      if (!attacker) return [];
      const tplA = CARDS[attacker.tplId];
      const dirs = dirsForPattern(attacker.facing, tplA.pattern || 'FRONT');
      const { atk } = effectiveStats(state.board[r][c], attacker);
      const hits = [];
      for (const d of dirs) {
        const [dr, dc] = DIR_VECTORS[d];
        const maxRange = Math.max(1, tplA.range || 1);
        for (let step = 1; step <= maxRange; step++) {
          const nr = r + dr * step, nc = c + dc * step;
          if (!inBounds(nr, nc)) break;
          const B = state.board[nr][nc].unit;
          if (!B) continue;
          if (B.owner === attacker.owner) break;
          const aFlying = (tplA.keywords || []).includes('FLYING');
          if (!aFlying && hasAdjacentGuard(state, nr, nc) && !(CARDS[B.tplId].keywords || []).includes('GUARD')) {
            break;
          }
          const backDir = turnCW[turnCW[B.facing]];
          const [bdr, bdc] = DIR_VECTORS[backDir];
          const isBack = (nr + bdr === r && nc + bdc === c);
          let extra = 0;
          const blind = CARDS[B.tplId].blindspots || ['S'];
          const dirFromBtoA = (() => {
            if (r === nr - 1 && c === nc) return 'N';
            if (r === nr + 1 && c === nc) return 'S';
            if (r === nr && c === nc - 1) return 'W';
            return 'E';
          })();
          if (blind.includes(dirFromBtoA)) extra += 1;
          const dmg = Math.max(0, atk + (isBack ? 1 : 0) + extra);
          hits.push({ r: nr, c: nc, dmg, backstab: isBack });
          break; // –ø–µ—Ä–≤–∞—è —Ü–µ–ª—å –ø–æ –ª—É—á—É
        }
      }
      return hits;
    }
    
    function stagedAttack(state, r, c) {
      const n1 = structuredClone(state);
      const attacker = n1.board[r][c].unit;
      if (!attacker) return null;
      const tplA = CARDS[attacker.tplId];
      const hits = computeHits(n1, r, c);
      if (!hits.length) return { empty: true };
      const logLines = [];
      const applyDeaths = () => {
        for (let rr = 0; rr < 3; rr++) for (let cc = 0; cc < 3; cc++) {
          const u = n1.board[rr][cc].unit; if (u && u.currentHP <= 0) n1.board[rr][cc].unit = null;
        }
      };
      const step1 = () => {
        for (const h of hits) {
          const B = n1.board[h.r][h.c].unit; if (!B) continue;
          const before = B.currentHP;
          const attackerTpl = CARDS[attacker.tplId];
          const isMagic = attackerTpl.attackType === 'MAGIC';
          const dodge = CARDS[B.tplId].dodge50 && !isMagic && Math.random() < 0.5;
          const dealt = dodge ? 0 : h.dmg;
          B.currentHP = Math.max(0, B.currentHP - dealt);
          const afterHP = B.currentHP;
          logLines.push(`${CARDS[attacker.tplId].name} ‚Üí ${CARDS[B.tplId].name}: ${dealt} —É—Ä–æ–Ω–∞${h.backstab ? ' (+1 –≤ —Å–ø–∏–Ω—É)' : ''}${dodge ? ' (—É–∫–ª–æ–Ω–µ–Ω–∏–µ)' : ''} (HP ${before}‚Üí${afterHP})`);
        }
      };
      const step2 = () => {
        const still = hits.map(h => ({ h, B: n1.board[h.r][h.c].unit })).filter(x => x.B && x.B.currentHP > 0);
        if (!still.length) return 0;
        let totalRetaliation = 0;
        for (const { h, B } of still) {
          const tplB = CARDS[B.tplId];
          const dirsB = dirsForPattern(B.facing, tplB.pattern || 'FRONT');
          let retaliates = false;
          for (const d of dirsB) {
            const [dr, dc] = DIR_VECTORS[d];
            if (h.r + dr === r && h.c + dc === c) { retaliates = true; break; }
          }
          if (retaliates) {
            const { atk: batk } = effectiveStats(n1.board[h.r][h.c], B);
            totalRetaliation += Math.max(0, batk);
          }
        }
        const attackerTpl = CARDS[attacker.tplId];
        const preventRetaliation = attackerTpl.attackType === 'MAGIC';
        if (!preventRetaliation && totalRetaliation > 0 && n1.board[r][c].unit) {
          const A = n1.board[r][c].unit;
          const before = A.currentHP;
          A.currentHP = Math.max(0, A.currentHP - totalRetaliation);
          const afterHP = A.currentHP;
          logLines.push(`–û—Ç–≤–µ—Ç–Ω—ã–π —É—Ä–æ–Ω –ø–æ ${CARDS[A.tplId].name}: ${totalRetaliation} (HP ${before}‚Üí${afterHP})`);
        }
        return totalRetaliation;
      };
      const finish = () => {
        applyDeaths();
        return { n1, logLines, targets: hits.map(h => ({ r: h.r, c: h.c, dmg: h.dmg })) };
      };
      return { step1, step2, finish, n1 };
    }
    
    function magicAttack(state, fr, fc, tr, tc) {
      const n1 = structuredClone(state);
      const attacker = n1.board[fr][fc].unit; const target = n1.board[tr][tc].unit;
      if (!attacker || !target || target.owner === attacker.owner) return null;
      const atkStats = effectiveStats(n1.board[fr][fc], attacker, n1);
      const tplA = CARDS[attacker.tplId];
      const dmg = Math.max(0, (atkStats.atk || 0) + (tplA.randomPlus2 && Math.random() < 0.5 ? 2 : 0));
      const before = target.currentHP;
      target.currentHP = Math.max(0, target.currentHP - dmg);
      const afterHP = target.currentHP;
      // cleanup deaths
      for (let rr = 0; rr < 3; rr++) for (let cc = 0; cc < 3; cc++) {
        const u = n1.board[rr][cc].unit; if (u && u.currentHP <= 0) n1.board[rr][cc].unit = null;
      }
      const logLines = [`${CARDS[attacker.tplId].name} (Magic) ‚Üí ${CARDS[target.tplId].name}: ${dmg} dmg (HP ${before}‚Üí${afterHP})`];
      return { n1, logLines, dmg, died: afterHP <= 0 };
    }
    
    // ====== THREE.JS –°–¶–ï–ù–ê ======
    
    let scene, camera, renderer, raycaster, mouse;
    let boardGroup, cardGroup, effectsGroup;
    let tileMeshes = [];
    let tileFrames = [];
    let unitMeshes = [];
    let handCardMeshes = [];
    let gameState = null;
    let logEntries = [];
    let TILE_TEXTURES = {};
    let PROC_TILE_TEXTURES = {};
    
    // –°–æ—Å—Ç–æ—è–Ω–∏–µ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è
    let draggedCard = null;
    let hoveredTile = null;
    let hoveredHandCard = null;
    let selectedCard = null;
    let pendingPlacement = null;
    let selectedUnit = null;
    let magicFrom = null; // { r, c }
    
    function initThreeJS() {
      const canvas = document.getElementById('three-canvas');
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.setClearColor(0x0b1220);
      // –¶–≤–µ—Ç–æ–≤–æ–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –∏ —ç–∫—Å–ø–æ–∑–∏—Ü–∏—è ‚Äî –ø–æ–≤—ã—Å–∏–º —á–∏—Ç–∞–µ–º–æ—Å—Ç—å —Ç–µ–∫—Å—Ç—É—Ä
      if (THREE.SRGBColorSpace) {
        renderer.outputColorSpace = THREE.SRGBColorSpace;
      }
      renderer.toneMappingExposure = 1.08;
      
      scene = new THREE.Scene();
      // –°–¥–µ–ª–∞–µ–º –¥–∞–ª—å –º–µ–Ω–µ–µ —Ç—ë–º–Ω–æ–π: —É–±–∏—Ä–∞–µ–º —Ç—É–º–∞–Ω
      scene.fog = null;
      
      camera = new THREE.PerspectiveCamera(54, window.innerWidth / window.innerHeight, 0.1, 120);
      camera.position.set(0, 22, 13);
      camera.lookAt(0, 0, 0);
      
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();
      
      boardGroup = new THREE.Group();
      cardGroup = new THREE.Group();
      effectsGroup = new THREE.Group();
      scene.add(boardGroup);
      scene.add(cardGroup);
      scene.add(effectsGroup);
      
      // –û—Å–≤–µ—â–µ–Ω–∏–µ
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
      directionalLight.position.set(10, 20, 10);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.set(2048, 2048);
      directionalLight.shadow.camera.near = 1;
      directionalLight.shadow.camera.far = 50;
      directionalLight.shadow.camera.left = -15;
      directionalLight.shadow.camera.right = 15;
      directionalLight.shadow.camera.top = 15;
      directionalLight.shadow.camera.bottom = -15;
      scene.add(directionalLight);
      // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –ø–æ–ª—É—à–∞—Ä–Ω–æ–π —Å–≤–µ—Ç, —á—Ç–æ–±—ã –≤–¥–∞–ª–∏ –±—ã–ª–æ —Å–≤–µ—Ç–ª–µ–µ
      const hemi = new THREE.HemisphereLight(0xcadfff, 0x1a2a3a, 0.6);
      scene.add(hemi);
      
      // –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞
      const platformGeometry = new THREE.CylinderGeometry(32, 32, 0.5, 48);
      const platformMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x1a2332, 
        metalness: 0.7, 
        roughness: 0.3 
      });
      const platform = new THREE.Mesh(platformGeometry, platformMaterial);
      platform.position.y = -0.5;
      platform.receiveShadow = true;
      scene.add(platform);
      // –ó–∞–≥—Ä—É–∑–∫–∞ —Ç–µ–∫—Å—Ç—É—Ä —Ç–∞–π–ª–æ–≤ –ø–æ–ª—è
      const loader = new THREE.TextureLoader();
      const texMap = { FIRE: 'tile-fire.png', WATER: 'tile-water.png', EARTH: 'tile-earth.png', FOREST: 'tile-forest.png' };
      for (const k in texMap) {
        try {
          const t = loader.load(texMap[k]);
          t.wrapS = THREE.RepeatWrapping; t.wrapT = THREE.RepeatWrapping;
          t.repeat.set(1, 1);
          t.anisotropy = renderer.capabilities.getMaxAnisotropy();
          if (THREE.SRGBColorSpace) t.colorSpace = THREE.SRGBColorSpace;
          TILE_TEXTURES[k] = t;
        } catch (e) {
          // —Ñ–æ–ª–±—ç–∫ —Å–æ–∑–¥–∞–¥–∏–º –Ω–∏–∂–µ –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω–æ
        }
      }
    }

    function createProceduralTileTexture(element) {
      if (PROC_TILE_TEXTURES[element]) return PROC_TILE_TEXTURES[element];
      const c = document.createElement('canvas');
      c.width = 256; c.height = 256; const ctx = c.getContext('2d');
      // —Ñ–æ–Ω
      const base = {
        FIRE: '#3b0d0d', WATER: '#0d243b', EARTH: '#2f2b24', FOREST: '#0f2b1a'
      }[element] || '#2a2a2a';
      ctx.fillStyle = base; ctx.fillRect(0,0,256,256);
      ctx.globalAlpha = 0.5;
      if (element === 'FIRE') {
        for (let i= -64; i<256; i+=24) {
          ctx.fillStyle = i % 48 === 0 ? '#b91c1c' : '#ef4444';
          ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i+64,0); ctx.lineTo(i+256,256); ctx.lineTo(i+192,256); ctx.closePath(); ctx.fill();
        }
      } else if (element === 'WATER') {
        ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 3; ctx.globalAlpha = 0.7;
        for (let y=20; y<256; y+=24) {
          ctx.beginPath(); for (let x=0; x<=256; x+=8) { ctx.lineTo(x, y + Math.sin((x+y)/20)*6); } ctx.stroke();
        }
      } else if (element === 'EARTH') {
        for (let y=0; y<256; y+=16) {
          for (let x=0; x<256; x+=16) {
            const v = 40 + Math.floor(Math.random()*30);
            ctx.fillStyle = `rgb(${v+60},${v+40},${v})`; ctx.fillRect(x,y,16,16);
          }
        }
      } else if (element === 'FOREST') {
        ctx.fillStyle = '#16a34a';
        for (let i=0; i<180; i++) {
          const x = Math.random()*256; const y = Math.random()*256; const r = Math.random()*3+1;
          ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
        }
        ctx.strokeStyle = '#22c55e'; ctx.globalAlpha = 0.35;
        for (let i=0; i<40; i++) { ctx.beginPath(); ctx.moveTo(Math.random()*256, Math.random()*256); ctx.lineTo(Math.random()*256, Math.random()*256); ctx.stroke(); }
      }
      const tex = new THREE.CanvasTexture(c); tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
      tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping; tex.repeat.set(1,1);
      PROC_TILE_TEXTURES[element] = tex; return tex;
    }
    
    // –ë–∞–∑–æ–≤—ã–µ —Ü–≤–µ—Ç–∞ –¥–ª—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ (—Ñ–æ–ª–±—ç–∫, –µ—Å–ª–∏ —Ç–µ–∫—Å—Ç—É—Ä—ã –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª–∏—Å—å)
    const ELEMENT_BASE_COLORS = {
      FIRE: 0xdc2626,
      WATER: 0x0369a1,
      EARTH: 0x525252,
      FOREST: 0x166534
    };

    function getTileMaterial(element) {
      let tex = TILE_TEXTURES[element];
      // –ï—Å–ª–∏ —Ç–µ–∫—Å—Ç—É—Ä–∞ –µ—â—ë –Ω–µ –≥–æ—Ç–æ–≤–∞, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—É—é
      if (!tex || !tex.image || !tex.image.width) tex = createProceduralTileTexture(element);
      if (tex) return new THREE.MeshBasicMaterial({ map: tex });
      return new THREE.MeshStandardMaterial({
        color: ELEMENT_BASE_COLORS[element] || 0x64748b,
        metalness: 0.12,
        roughness: 0.6,
        emissive: 0x1a1a1a,
        emissiveIntensity: 0.18
      });
    }
    
    function createBoard() {
      tileMeshes.forEach(row => row.forEach(tile => {
        if (tile) boardGroup.remove(tile);
      }));
      tileFrames.forEach(row => row.forEach(f => { if (f) boardGroup.remove(f); }));
      tileMeshes = [];
      tileFrames = [];
      
      if (!gameState) return;
      
      const tileSize = 6.2; // —É–≤–µ–ª–∏—á–µ–Ω–æ
      const tileHeight = 0.35;
      const spacing = 0.2;
      
      for (let r = 0; r < 3; r++) {
        const row = [];
        const frameRow = [];
        for (let c = 0; c < 3; c++) {
          const cell = gameState.board[r][c];
          
          const geometry = new THREE.BoxGeometry(tileSize, tileHeight, tileSize);
          const material = getTileMaterial(cell.element);
          const tile = new THREE.Mesh(geometry, material);
          
          const x = (c - 1) * (tileSize + spacing);
          const z = (r - 1) * (tileSize + spacing);
          tile.position.set(x, tileHeight / 2, z);
          tile.castShadow = false;
          tile.receiveShadow = true;
          
          tile.userData = { type: 'tile', row: r, col: c, element: cell.element };
          
          boardGroup.add(tile);
          row.push(tile);

          // –†–∞–º–∫–∞ –≤–ª–∞–¥–µ–Ω–∏—è (–ª–∏–Ω–∏–∏ –ø–æ –ø–µ—Ä–∏–º–µ—Ç—Ä—É)
          const edgeGeom = new THREE.EdgesGeometry(new THREE.BoxGeometry(tileSize + 0.02, 0.02, tileSize + 0.02));
          const edgeMat = new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.0, depthTest: false });
          const edges = new THREE.LineSegments(edgeGeom, edgeMat);
          edges.position.set(x, tileHeight + 0.011, z);
          edges.renderOrder = 997;
          boardGroup.add(edges);
          frameRow.push(edges);
        }
        tileMeshes.push(row);
        tileFrames.push(frameRow);
      }
    }
    
    function createCard3D(cardData, isInHand = false, hpOverride = null) {
      const cardWidth = 4.8;  // —É–≤–µ–ª–∏—á–µ–Ω–æ ~–≤ 2-3 —Ä–∞–∑–∞
      const cardHeight = 5.6; // –ø–æ—á—Ç–∏ –≤—Å—è —è—á–µ–π–∫–∞
      const cardThickness = 0.12;
      
      const geometry = new THREE.BoxGeometry(cardWidth, cardThickness, cardHeight);
      
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 356;
      const ctx = canvas.getContext('2d');
      
      drawCardFace(ctx, cardData, canvas.width, canvas.height, hpOverride);
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      
      const faceMaterial = new THREE.MeshStandardMaterial({ 
        map: texture, 
        metalness: 0.1, 
        roughness: 0.7 
      });
      
      const edgeMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x1e293b, 
        metalness: 0.3, 
        roughness: 0.8 
      });
      
      const backMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x0f172a, 
        metalness: 0.2, 
        roughness: 0.9 
      });
      
      const materials = [
        edgeMaterial, edgeMaterial, faceMaterial, backMaterial, edgeMaterial, edgeMaterial
      ];
      
      const card = new THREE.Mesh(geometry, materials);
      card.castShadow = true;
      card.receiveShadow = false;
      
      card.userData = {
        type: 'card',
        cardData: cardData,
        isInHand: isInHand,
        originalPosition: new THREE.Vector3(),
        originalRotation: new THREE.Euler()
      };
      
      // –ú–∞—Å—à—Ç–∞–± –¥–ª—è —Ä—É–∫–∏ (—Ñ–∞–Ω) ‚Äî —É–º–µ–Ω—å—à–∞–µ–º X/Z, —Ç–æ–ª—â–∏–Ω—É –æ—Å—Ç–∞–≤–ª—è–µ–º
      if (isInHand) {
        card.scale.set(0.36, 1, 0.36);
      }
      return card;
    }
    
    function drawCardFace(ctx, cardData, width, height, hpOverride = null) {
      const gradient = ctx.createLinearGradient(0, 0, 0, height);
      gradient.addColorStop(0, '#1e293b');
      gradient.addColorStop(1, '#0f172a');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);
      
      ctx.strokeStyle = getElementColor(cardData.element);
      ctx.lineWidth = 4;
      ctx.strokeRect(4, 4, width - 8, height - 8);
      
      ctx.fillStyle = '#f1f5f9';
      ctx.font = 'bold 18px Arial, sans-serif';
      ctx.textAlign = 'center';
      const name = cardData.name.length > 20 ? cardData.name.substring(0, 20) + '...' : cardData.name;
      ctx.fillText(name, width / 2, 30);
      
      ctx.font = '24px Arial';
      ctx.fillText(elementEmoji[cardData.element] || '', width / 2, 55);
      
      ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
      ctx.fillRect(16, 70, width - 32, 120);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.lineWidth = 2;
      ctx.strokeRect(16, 70, width - 32, 120);
      
      ctx.fillStyle = '#94a3b8';
      ctx.font = '12px Arial';
      ctx.fillText('Illustration', width / 2, 135);
      
      ctx.fillStyle = '#cbd5e1';
      ctx.font = '11px Arial';
      ctx.textAlign = 'left';
      const text = cardData.desc || cardData.text || (cardData.keywords ? cardData.keywords.join(', ') : '');
      wrapText(ctx, text, 16, 210, width - 32, 14);
      
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(0, height - 40, width, 40);
      
      ctx.fillStyle = '#f1f5f9';
      ctx.font = 'bold 14px Arial';
      ctx.textAlign = 'left';
      ctx.fillText(`üíé${cardData.cost || 0}`, 16, height - 15);
      // –°—Ç–æ–∏–º–æ—Å—Ç—å –∞—Ç–∞–∫–∏ –∫–∞–∫ –≤ 2D (‚ö°)
      if (cardData.type === 'UNIT') {
        ctx.textAlign = 'center';
        ctx.font = 'bold 13px Arial';
        const act = (cardData.activation != null) ? cardData.activation : Math.max(0, (cardData.cost || 0) - 1);
        ctx.fillText(`‚ö°${act}`, width/2, height - 16);
      }
      
      if (cardData.type === 'UNIT') {
        ctx.textAlign = 'right';
        const hpToShow = (hpOverride != null) ? hpOverride : (cardData.hp || 0);
        ctx.fillText(`‚öîÔ∏è${cardData.atk || 0}  ‚ù§Ô∏è${hpToShow}`, width - 16, height - 15);
        // 3x3 —Å—Ö–µ–º—ã: –∞—Ç–∞–∫–∞ –∏ blindspot
        drawPatternGrid(ctx, cardData, width - 76, 178, 10, 2);
        drawBlindspotGrid(ctx, cardData, width - 36, 178, 10, 2);
      }
    }
    
    function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
      if (!text) return;
      const words = text.split(' ');
      let line = '';
      
      for (let n = 0; n < words.length; n++) {
        const testLine = line + words[n] + ' ';
        const metrics = ctx.measureText(testLine);
        const testWidth = metrics.width;
        
        if (testWidth > maxWidth && n > 0) {
          ctx.fillText(line, x, y);
          line = words[n] + ' ';
          y += lineHeight;
        } else {
          line = testLine;
        }
      }
      ctx.fillText(line, x, y);
    }
    
    function getElementColor(element) {
      const colors = {
        FIRE: '#dc2626',
        WATER: '#0369a1', 
        EARTH: '#525252',
        FOREST: '#166534'
      };
      return colors[element] || '#64748b';
    }
    
    function drawPatternGrid(ctx, cardData, x, y, cell, gap) {
      const pattern = cardData.pattern || 'FRONT';
      const range = cardData.range || 1;
      // grid 3x3
      for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 3; c++) {
          const cx = x + c * (cell + gap);
          const cy = y + r * (cell + gap);
          ctx.fillStyle = 'rgba(148,163,184,0.35)';
          // center
          if (r === 1 && c === 1) ctx.fillStyle = 'rgba(250,204,21,0.7)';
          ctx.fillRect(cx, cy, cell, cell);
          // highlight directions from facing N
          const dirs = dirsForPattern('N', pattern);
          const isN = (r === 0 && c === 1);
          const isE = (r === 1 && c === 2);
          const isS = (r === 2 && c === 1);
          const isW = (r === 1 && c === 0);
          if ((isN && dirs.includes('N')) || (isE && dirs.includes('E')) || (isS && dirs.includes('S')) || (isW && dirs.includes('W'))) {
            ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 1.5; ctx.strokeRect(cx+0.5, cy+0.5, cell-1, cell-1);
          }
        }
      }
      // push center slightly if range>1
      if (range > 1) {
        ctx.fillStyle = 'rgba(148,163,184,0.5)';
        ctx.fillRect(x + 1*(cell+gap) + 0.5, y + 1*(cell+gap) + 2, cell-1, cell-1);
      }
    }
    function drawBlindspotGrid(ctx, cardData, x, y, cell, gap) {
      const blind = (cardData.blindspots && cardData.blindspots.length) ? cardData.blindspots : ['S'];
      for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 3; c++) {
          const cx = x + c * (cell + gap);
          const cy = y + r * (cell + gap);
          ctx.fillStyle = 'rgba(148,163,184,0.35)';
          if (r === 1 && c === 1) ctx.fillStyle = 'rgba(250,204,21,0.7)';
          ctx.fillRect(cx, cy, cell, cell);
          const isN = (r === 0 && c === 1);
          const isE = (r === 1 && c === 2);
          const isS = (r === 2 && c === 1);
          const isW = (r === 1 && c === 0);
          if ((isN && blind.includes('N')) || (isE && blind.includes('E')) || (isS && blind.includes('S')) || (isW && blind.includes('W'))) {
            ctx.strokeStyle = '#38bdf8'; ctx.lineWidth = 1.5; ctx.strokeRect(cx+0.5, cy+0.5, cell-1, cell-1);
          }
        }
      }
    }
    
    function updateHand() {
      handCardMeshes.forEach(card => {
        if (card.parent) card.parent.remove(card);
      });
      handCardMeshes = [];
      hoveredHandCard = null;
      
      if (!gameState) return;
      
      const hand = gameState.players[gameState.active].hand;
      const handSize = hand.length;
      
      if (handSize === 0) return;
      
      // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –≤–µ–µ—Ä–Ω–æ–≥–æ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è
      const spread = Math.min(4.0, Math.max(2.0, 20 / (handSize + 2)));
      const angleSpread = Math.min(0.3, 1.2 / (handSize + 1));
      const radius = 8.0;  // –†–∞–∑—É–º–Ω—ã–π —Ä–∞–¥–∏—É—Å –¥–ª—è –≤–∏–¥–∏–º–æ—Å—Ç–∏
      const baseY = 6.0;   // –†—É–∫–∞ –Ω–∞–¥ –ø–æ–ª–µ–º, –Ω–æ –Ω–µ —Å–ª–∏—à–∫–æ–º –≤—ã—Å–æ–∫–æ
      
      for (let i = 0; i < handSize; i++) {
        const cardData = hand[i];
        const card = createCard3D(cardData, true);
        
        // –í—ã—á–∏—Å–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –¥–ª—è –≤–µ–µ—Ä–Ω–æ–≥–æ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è
        const angle = (i - (handSize - 1) / 2) * angleSpread;
        const x = Math.sin(angle) * radius;
        const z = radius + Math.cos(angle) * radius * 0.3;
        const y = baseY + Math.sin(angle) * 1.5; // –ù–µ–±–æ–ª—å—à–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ –ø–æ Y –¥–ª—è –æ–±—ä–µ–º–∞
        
        card.position.set(x, y, z);
        
        // –ü–æ–≤–æ—Ä–æ—Ç –∫–∞—Ä—Ç—ã –¥–ª—è –≤–µ–µ—Ä–Ω–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞
        card.rotation.set(
            -0.2 + angle * 0.1,   // –ù–∞–∫–ª–æ–Ω –≤–ø–µ—Ä–µ–¥
            angle * 0.5,           // –ü–æ–≤–æ—Ä–æ—Ç –≤ —Å—Ç–æ—Ä–æ–Ω—É
            0                       // –ë–µ–∑ –∫—Ä–µ–Ω–∞
        );
        
        card.userData.originalPosition.copy(card.position);
        card.userData.originalRotation.copy(card.rotation);
        card.userData.handIndex = i;
        card.userData.cardData = cardData;
        
        cardGroup.add(card);
        handCardMeshes.push(card);
      }
    }
    
    function updateUnits() {
      unitMeshes.forEach(unit => {
        if (unit.parent) unit.parent.remove(unit);
      });
      unitMeshes = [];
      
      if (!gameState) return;
      
      const tileSize = 6.2;
      const spacing = 0.2;
      
      for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 3; c++) {
          const unit = gameState.board[r][c].unit;
          // –û–±–Ω–æ–≤–∏–º —Ä–∞–º–∫–∏ –≤–ª–∞–¥–µ–Ω–∏—è
          if (tileFrames[r] && tileFrames[r][c]) {
            const frame = tileFrames[r][c];
            if (unit) {
              const col = (unit.owner === 0) ? 0x22c55e : 0xef4444;
              frame.material.color = new THREE.Color(col);
              frame.material.opacity = 0.85;
            } else {
              frame.material.opacity = 0.0;
            }
          }
          if (!unit) continue;
          
          const cardData = CARDS[unit.tplId];
          const unitMesh = createCard3D(cardData, false, unit.currentHP);
          
          const x = (c - 1) * (tileSize + spacing);
          const z = (r - 1) * (tileSize + spacing);
          unitMesh.position.set(x, 0.5, z);
          
          const facingAngle = facingDeg[unit.facing] * Math.PI / 180;
          unitMesh.rotation.y = facingAngle;
          
          const ownerColor = unit.owner === 0 ? 0x22c55e : 0xef4444;
          const glowMaterial = new THREE.MeshStandardMaterial({
            color: ownerColor,
            emissive: ownerColor,
            emissiveIntensity: 0.2,
            transparent: true,
            opacity: 0.3
          });
          
          const glowGeometry = new THREE.BoxGeometry(1.8, 0.02, 2.4);
          const glow = new THREE.Mesh(glowGeometry, glowMaterial);
          glow.position.set(0, -0.05, 0);
          unitMesh.add(glow);
          
          unitMesh.userData = {
            type: 'unit',
            row: r,
            col: c,
            unitData: unit,
            cardData: cardData
          };
          // –¢–µ–∫—É—â–µ–µ HP –ø–æ–≤–µ—Ä—Ö –∫–∞—Ä—Ç—ã
          try { attachHpOverlay(unitMesh, unit.currentHP); } catch (e) {}
          
          cardGroup.add(unitMesh);
          unitMeshes.push(unitMesh);
        }
      }
    }

    function attachHpOverlay(unitMesh, hpValue) {
      const canvas = document.createElement('canvas');
      canvas.width = 128; canvas.height = 64;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0,0,128,64);
      ctx.font = 'bold 36px Arial';
      ctx.textAlign = 'right'; ctx.textBaseline = 'bottom';
      ctx.fillStyle = '#e11d48';
      ctx.strokeStyle = 'rgba(0,0,0,0.7)'; ctx.lineWidth = 6;
      const text = String(hpValue);
      ctx.strokeText(text, 124, 60);
      ctx.fillText(text, 124, 60);
      const tex = new THREE.CanvasTexture(canvas); tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false, depthWrite: false });
      const sprite = new THREE.Sprite(mat);
      sprite.scale.set(0.9, 0.45, 1);
      // –ø–æ–∑–∏—Ü–∏—è —É –Ω–∏–∂–Ω–µ–≥–æ –ø—Ä–∞–≤–æ–≥–æ —É–≥–ª–∞ –∫–∞—Ä—Ç—ã
      sprite.position.set(1.0, 0.08, 1.25);
      sprite.renderOrder = 999;
      unitMesh.add(sprite);
    }
    
    function updateUI() {
      if (!gameState) return;
      
      document.getElementById('turn-info').textContent = `–•–æ–¥: ${gameState.turn}`;
      document.getElementById('active-player').textContent = `–ê–∫—Ç–∏–≤–Ω—ã–π: ${gameState.players[gameState.active].name}`;
      // –ø–æ–∫–∞–∑–∞—Ç—å –±–∞–Ω–Ω–µ—Ä —Ö–æ–¥–∞ –ø—Ä–∏ —Å–º–µ–Ω–µ
      if (!updateUI.prevTurn || updateUI.prevTurn !== gameState.turn) {
        const tb = document.getElementById('turn-banner');
        const box = tb.querySelector('div');
        box.textContent = `Turn ${gameState.turn} ‚Äî ${gameState.players[gameState.active].name}`;
        tb.classList.remove('hidden'); tb.classList.add('flex');
        setTimeout(()=>{ tb.classList.add('hidden'); tb.classList.remove('flex'); }, 2600);
      }
      updateUI.prevTurn = gameState.turn;
      
      const manaDisplay = document.getElementById('mana-display');
      const prev = manaDisplay.querySelectorAll('.mana-orb').length;
      const currentMana = gameState.players[gameState.active].mana;
      // –ê–Ω–∏–º–∞—Ü–∏—è: –æ—á–∏—â–∞–µ–º –∏ –ø–µ—Ä–µ–ª—ë—Ç —à–∞—Ä–∏–∫–æ–≤ –ø—Ä–∏ —É–≤–µ–ª–∏—á–µ–Ω–∏–∏
      manaDisplay.innerHTML = '';
      const total = 10;
      for (let i = 0; i < total; i++) {
        const orb = document.createElement('div');
        const filled = i < currentMana;
        orb.className = filled ? 'mana-orb' : 'mana-slot';
        orb.style.opacity = filled ? '0' : '1';
        manaDisplay.appendChild(orb);
        if (filled) {
          // –Ω–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞, –∫–∞–∫ –±—É–¥—Ç–æ –æ—Ä–±—ã ¬´–≤–ª–µ—Ç–∞—é—Ç¬ª —Å–ø—Ä–∞–≤–∞
          const delay = 0.06 * Math.max(0, i - prev);
          setTimeout(()=>{
            orb.style.transform = 'translateX(16px) scale(0.6)';
            orb.style.transition = 'transform 220ms ease, opacity 220ms ease';
            requestAnimationFrame(()=>{
              orb.style.opacity = '1';
              orb.style.transform = 'translateX(0) scale(1)';
            });
          }, delay*1000);
        }
      }
      
      const controlA = countControlled(gameState, 0);
      const controlB = countControlled(gameState, 1);
      document.getElementById('control-info').textContent = `–ö–æ–Ω—Ç—Ä–æ–ª—å: A ${controlA} ‚Ä¢ B ${controlB}`;
      
      if (controlA >= 5) {
        showNotification('–ò–≥—Ä–æ–∫ A –ø–æ–±–µ–∂–¥–∞–µ—Ç!', 'success');
        gameState.winner = 0;
      } else if (controlB >= 5) {
        showNotification('–ò–≥—Ä–æ–∫ B –ø–æ–±–µ–∂–¥–∞–µ—Ç!', 'success');
        gameState.winner = 1;
      }
    }
    
    function showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.className = `overlay-panel p-4 mb-2 ${type === 'success' ? 'bg-green-600' : type === 'error' ? 'bg-red-600' : 'bg-blue-600'}`;
      notification.textContent = message;
      
      const container = document.getElementById('notifications');
      container.appendChild(notification);
      
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 3000);
    }
    
    function addLog(message) {
      logEntries.unshift(`‚Ä¢ ${message}`);
      if (logEntries.length > 100) logEntries.pop();
      
      const logContent = document.getElementById('log-content');
      if (logContent) {
        logContent.innerHTML = logEntries.map(entry => `<div>${entry}</div>`).join('');
      }
    }
    
    // –í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ
    function onMouseMove(event) {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      
      if (draggedCard) {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(tileMeshes.flat());
        
        if (hoveredTile) {
          hoveredTile.material.emissiveIntensity = 0.1;
        }
        
        if (intersects.length > 0) {
          hoveredTile = intersects[0].object;
          hoveredTile.material.emissiveIntensity = 0.3;
          
          const targetPos = hoveredTile.position.clone();
          targetPos.y = 2;
          gsap.to(draggedCard.position, {
            x: targetPos.x,
            y: targetPos.y,
            z: targetPos.z,
            duration: 0.1
          });
        } else {
          hoveredTile = null;
        }
      } else {
        // –•–æ–≤–µ—Ä –ø–æ –∫–∞—Ä—Ç–∞–º –≤ —Ä—É–∫–µ: —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º –Ω–∞–≤–µ–¥—ë–Ω–Ω—É—é, —É–º–µ–Ω—å—à–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â—É—é
        raycaster.setFromCamera(mouse, camera);
        const handHits = raycaster.intersectObjects(handCardMeshes);
        const newHover = handHits.length > 0 ? handHits[0].object : null;
        if (hoveredHandCard && hoveredHandCard !== newHover) {
          gsap.to(hoveredHandCard.scale, { x: 0.36, y: 1, z: 0.36, duration: 0.18 });
          hoveredHandCard = null;
        }
        if (newHover && newHover.userData && newHover.userData.isInHand) {
          hoveredHandCard = newHover;
          gsap.to(newHover.scale, { x: 0.45, y: 1, z: 0.45, duration: 0.18 });
        }
      }
      // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã—Ö —Ü–µ–ª–µ–π –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–æ–π –ø–∞–Ω–µ–ª–∏ –¥–µ–π—Å—Ç–≤–∏–π —é–Ω–∏—Ç–∞
      if (selectedUnit) {
        const r = selectedUnit.userData.row; const c = selectedUnit.userData.col;
        const hits = computeHits(gameState, r, c);
        // —É–±–∏—Ä–∞–µ–º –ø—Ä–æ—à–ª—É—é –ø–æ–¥—Å–≤–µ—Ç–∫—É
        unitMeshes.forEach(m => { if (m.material && m.material[2]) { /* no-op here */ } });
        // –ø–æ–¥—Å–≤–µ—Ç–∏–º —Ü–µ–ª–∏ –Ω–µ–±–æ–ª—å—à–∏–º –≤—Å–ø–ª–µ—Å–∫–æ–º –ø–æ Y
        for (const h of hits) {
          const m = unitMeshes.find(m => m.userData.row === h.r && m.userData.col === h.c);
          if (m) gsap.to(m.position, { y: 0.7, yoyo: true, repeat: 1, duration: 0.2 });
        }
      }
    }
    
    function onMouseDown(event) {
      if (!gameState || gameState.winner !== null) return;
      
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      
      const handIntersects = raycaster.intersectObjects(handCardMeshes);
      if (handIntersects.length > 0) {
        const card = handIntersects[0].object;
        const cardData = card.userData.cardData;
        
        if (cardData.type === 'UNIT') {
          startCardDrag(card);
        } else if (cardData.type === 'SPELL') {
          selectSpellCard(card);
        }
        return;
      }
      
      const unitIntersects = raycaster.intersectObjects(unitMeshes);
      if (unitIntersects.length > 0) {
        const unit = unitIntersects[0].object;
        // –µ—Å–ª–∏ –≤ —Ä–µ–∂–∏–º–µ –º–∞–≥–∏—á–µ—Å–∫–æ–π –∞—Ç–∞–∫–∏
        if (magicFrom) {
          performMagicAttack(magicFrom, unit);
          magicFrom = null;
          return;
        }
        if (selectedCard && selectedCard.userData.cardData.type === 'SPELL') {
          castSpellOnUnit(selectedCard, unit);
        } else if (unit.userData.unitData.owner === gameState.active) {
          showUnitActionPanel(unit);
        }
        return;
      }
      
      if (selectedCard) {
        resetCardSelection();
      }
    }
    
    function onMouseUp(event) {
      if (draggedCard && hoveredTile) {
        const row = hoveredTile.userData.row;
        const col = hoveredTile.userData.col;
        
        if (gameState.board[row][col].unit) {
          showNotification('–ö–ª–µ—Ç–∫–∞ —É–∂–µ –∑–∞–Ω—è—Ç–∞!', 'error');
          returnCardToHand(draggedCard);
        } else {
          pendingPlacement = {
            card: draggedCard,
            row: row,
            col: col,
            handIndex: draggedCard.userData.handIndex
          };
          showOrientationPanel();
        }
      } else if (draggedCard) {
        returnCardToHand(draggedCard);
      }
      
      endCardDrag();
    }
    
    function startCardDrag(card) {
      draggedCard = card;
      // –µ—Å–ª–∏ –∫–∞—Ä—Ç–∞ –±—ã–ª–∞ —É–≤–µ–ª–∏—á–µ–Ω–∞ —Ö–æ–≤–µ—Ä–æ–º ‚Äî –≤–µ—Ä–Ω—ë–º –∫ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–º—É –º–∞—Å—à—Ç–∞–±—É —Ä—É–∫–∏
      if (hoveredHandCard) {
        gsap.to(hoveredHandCard.scale, { x: 0.36, y: 1, z: 0.36, duration: 0.1 });
        hoveredHandCard = null;
      }
      
      gsap.to(card.position, {
        y: card.position.y + 1,
        duration: 0.2,
        ease: "power2.out"
      });
      
      gsap.to(card.rotation, {
        x: 0,
        z: 0,
        duration: 0.2
      });
      
      gsap.to(card.scale, {
        x: 1.1,
        y: 1.1,
        z: 1.1,
        duration: 0.2
      });
    }
    
    function endCardDrag() {
      if (hoveredTile) {
        hoveredTile.material.emissiveIntensity = 0.1;
        hoveredTile = null;
      }
      draggedCard = null;
    }
    
    function returnCardToHand(card) {
      gsap.to(card.position, {
        x: card.userData.originalPosition.x,
        y: card.userData.originalPosition.y,
        z: card.userData.originalPosition.z,
        duration: 0.3,
        ease: "power2.inOut"
      });
      
      gsap.to(card.rotation, {
        x: card.userData.originalRotation.x,
        y: card.userData.originalRotation.y,
        z: card.userData.originalRotation.z,
        duration: 0.3
      });
      
      gsap.to(card.scale, {
        x: card.userData && card.userData.isInHand ? 0.36 : 1,
        y: 1,
        z: card.userData && card.userData.isInHand ? 0.36 : 1,
        duration: 0.3
      });
    }
    
    function selectSpellCard(card) {
      if (selectedCard === card) {
        resetCardSelection();
        return;
      }
      
      if (selectedCard) {
        resetCardSelection();
      }
      
      selectedCard = card;
      
      gsap.to(card.position, {
        y: card.userData.originalPosition.y + 0.3,
        duration: 0.2
      });
      
      card.material[2].emissive = new THREE.Color(0x0066cc);
      card.material[2].emissiveIntensity = 0.3;
      
      showNotification(`–í—ã–±—Ä–∞–Ω–æ –∑–∞–∫–ª–∏–Ω–∞–Ω–∏–µ: ${card.userData.cardData.name}. –í—ã–±–µ—Ä–∏—Ç–µ —Ü–µ–ª—å.`);
    }
    
    function resetCardSelection() {
      if (selectedCard) {
        returnCardToHand(selectedCard);
        selectedCard.material[2].emissive = new THREE.Color(0x000000);
        selectedCard.material[2].emissiveIntensity = 0;
        selectedCard = null;
      }
    }
    
    function showOrientationPanel() {
      document.getElementById('orientation-panel').classList.remove('hidden');
    }
    
    function hideOrientationPanel() {
      document.getElementById('orientation-panel').classList.add('hidden');
      pendingPlacement = null;
    }
    
    function showUnitActionPanel(unitMesh) {
      selectedUnit = unitMesh;
      const unitData = unitMesh.userData.unitData;
      const cardData = unitMesh.userData.cardData;
      
      document.getElementById('unit-info').textContent = 
        `${cardData.name} (${unitMesh.userData.row + 1},${unitMesh.userData.col + 1})`;
      
      const alreadyAttacked = unitData.lastAttackTurn === gameState.turn;
      const attackBtn = document.getElementById('attack-btn');
      attackBtn.disabled = alreadyAttacked;
      const cost = attackCost(cardData);
      attackBtn.textContent = alreadyAttacked ? '–£–∂–µ –∞—Ç–∞–∫–æ–≤–∞–ª' : `–ê—Ç–∞–∫–æ–≤–∞—Ç—å (‚àí${cost})`;
      // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã—Ö —Ü–µ–ª–µ–π –≤ –ø–∞–Ω–µ–ª–∏ –¥–µ–π—Å—Ç–≤–∏–π
      const hits = computeHits(gameState, selectedUnit.userData.row, selectedUnit.userData.col);
      for (const h of hits) {
        const m = unitMeshes.find(m => m.userData.row === h.r && m.userData.col === h.c);
        if (!m) continue;
        const ringGeom = new THREE.RingGeometry(0.6, 0.8, 24);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0xf97316, transparent:true, opacity:0.7, side:THREE.DoubleSide });
        const ring = new THREE.Mesh(ringGeom, ringMat);
        ring.rotation.x = -Math.PI/2;
        ring.position.copy(m.position).add(new THREE.Vector3(0, -0.45, 0));
        effectsGroup.add(ring);
        gsap.to(ring.material, { opacity: 0, duration: 0.8, onComplete: ()=> effectsGroup.remove(ring) });
      }
      
      document.getElementById('unit-action-panel').classList.remove('hidden');
    }
    
    function hideUnitActionPanel() {
      document.getElementById('unit-action-panel').classList.add('hidden');
      selectedUnit = null;
    }
    
    function initGame() {
      gameState = startGame(STARTER_FIRESET, STARTER_FIRESET);
      
      createBoard();
      updateUnits();
      updateHand();
      updateUI();
      
      addLog('–ò–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å! –ò–≥—Ä–æ–∫ A —Ö–æ–¥–∏—Ç –ø–µ—Ä–≤—ã–º.');
      addLog('–ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–π—Ç–µ –∫–∞—Ä—Ç—ã —Å—É—â–µ—Å—Ç–≤ –Ω–∞ –ø–æ–ª–µ, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∑–∞–∫–ª–∏–Ω–∞–Ω–∏—è –∫–ª–∏–∫–æ–º.');
    }
    
    function endTurn() {
      if (!gameState || gameState.winner !== null) return;
      
      const controlledCells = countControlled(gameState, gameState.active);
      if (controlledCells >= 5) {
        gameState.winner = gameState.active;
        showNotification(`${gameState.players[gameState.active].name} –ø–æ–±–µ–∂–¥–∞–µ—Ç!`, 'success');
        return;
      }
      
      gameState.active = gameState.active === 0 ? 1 : 0;
      gameState.turn += 1;
      
      const player = gameState.players[gameState.active];
      player.mana = capMana(player.mana + 2);
      drawOne(gameState, gameState.active);
      
      resetCardSelection();
      
      updateHand();
      updateUnits();
      updateUI();
      
      addLog(`–•–æ–¥ ${gameState.turn}. ${player.name} –ø–æ–ª—É—á–∞–µ—Ç +2 –º–∞–Ω—ã –∏ –¥–æ–±–∏—Ä–∞–µ—Ç –∫–∞—Ä—Ç—É.`);
    }
    
    function placeUnitWithDirection(direction) {
      if (!pendingPlacement) return;
      
      const { card, row, col, handIndex } = pendingPlacement;
      const cardData = card.userData.cardData;
      const player = gameState.players[gameState.active];
      
      if (cardData.cost > player.mana) {
        showNotification('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–∞–Ω—ã!', 'error');
        returnCardToHand(card);
        hideOrientationPanel();
        return;
      }
      
      const unit = {
        uid: uid(),
        owner: gameState.active,
        tplId: cardData.id,
        currentHP: cardData.hp,
        facing: direction
      };
      
      gameState.board[row][col].unit = unit;
      
      player.mana -= cardData.cost;
      player.discard.push(cardData);
      player.hand.splice(handIndex, 1);
      
      const cellElement = gameState.board[row][col].element;
      const buff = computeCellBuff(cellElement, cardData.element);
      if (buff.hp !== 0) {
        const before = unit.currentHP;
        unit.currentHP = Math.max(0, unit.currentHP + buff.hp);
        if (buff.hp > 0) {
          addLog(`–≠–ª–µ–º–µ–Ω—Ç —É—Å–∏–ª–∏–≤–∞–µ—Ç ${cardData.name}: HP ${before}‚Üí${unit.currentHP}`);
        } else {
          addLog(`–≠–ª–µ–º–µ–Ω—Ç –æ—Å–ª–∞–±–ª—è–µ—Ç ${cardData.name}: HP ${before}‚Üí${unit.currentHP}`);
        }
      }
      
      if (unit.currentHP <= 0) {
        addLog(`${cardData.name} –ø–æ–≥–∏–±–∞–µ—Ç –æ—Ç –Ω–µ–±–ª–∞–≥–æ–ø—Ä–∏—è—Ç–Ω–æ–π —Å—Ç–∏—Ö–∏–∏!`);
        gameState.board[row][col].unit = null;
      }
      
      const targetPos = tileMeshes[row][col].position.clone();
      targetPos.y = 0.5;
      
      gsap.to(card.position, {
        x: targetPos.x,
        y: targetPos.y,
        z: targetPos.z,
        duration: 0.5,
        ease: "power2.inOut"
      });
      
      gsap.to(card.rotation, {
        x: 0,
        y: (facingDeg[direction]) * Math.PI / 180,
        z: 0,
        duration: 0.5,
        onComplete: () => {
          updateHand();
          updateUnits();
          updateUI();
        }
      });
      
      addLog(`${player.name} –ø—Ä–∏–∑—ã–≤–∞–µ—Ç ${cardData.name} –Ω–∞ (${row + 1},${col + 1})`);
      hideOrientationPanel();
      // –±–µ—Å–ø–ª–∞—Ç–Ω–∞—è –∞—Ç–∞–∫–∞ –ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏ —Ü–µ–ª–µ–π
      const hits = computeHits(gameState, row, col);
      if (hits && hits.length) {
        // –î–∞–¥–∏–º –∫–∞—Ä—Ç–µ –¥–æ–ª–µ—Ç–µ—Ç—å –∏ –ø–æ–≤–µ—Ä–Ω—É—Ç—å—Å—è –ø—Ä–µ–∂–¥–µ —á–µ–º –±–∏—Ç—å—Å—è
        setTimeout(() => performBattleSequence(row, col, false), 350);
      }
    }
    
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function init() {
      initThreeJS();
      initGame();
      
      renderer.domElement.addEventListener('mousemove', onMouseMove);
      renderer.domElement.addEventListener('mousedown', onMouseDown);
      renderer.domElement.addEventListener('mouseup', onMouseUp);
      window.addEventListener('resize', onWindowResize);
      
      animate();
    }
    
    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ UI
    document.getElementById('end-turn-btn').addEventListener('click', endTurn);
    document.getElementById('new-game-btn').addEventListener('click', () => location.reload());
    document.getElementById('log-btn').addEventListener('click', () => {
      const lp = document.getElementById('log-panel');
      lp.classList.toggle('hidden');
      // –ù–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π –∂—ë—Å—Ç–∫–æ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –Ω–∏–∂–µ –∫–æ–Ω—Ç—Ä–æ–ª–æ–≤
      lp.style.top = (document.getElementById('controls').offsetHeight + 40) + 'px';
      if (!lp.classList.contains('hidden')) lp.style.pointerEvents = 'auto';
    });
    document.getElementById('close-log-btn').addEventListener('click', () => {
      document.getElementById('log-panel').classList.add('hidden');
    });
    document.getElementById('help-btn').addEventListener('click', () => {
      document.getElementById('help-panel').classList.remove('hidden');
    });
    document.getElementById('close-help-btn').addEventListener('click', () => {
      document.getElementById('help-panel').classList.add('hidden');
    });
    document.getElementById('cancel-orient-btn').addEventListener('click', () => {
      if (pendingPlacement) {
        returnCardToHand(pendingPlacement.card);
      }
      hideOrientationPanel();
    });
    document.getElementById('cancel-action-btn').addEventListener('click', hideUnitActionPanel);
    // –î–µ–π—Å—Ç–≤–∏—è –≤ –ø–∞–Ω–µ–ª–∏ —é–Ω–∏—Ç–∞
    document.getElementById('rotate-cw-btn').addEventListener('click', () => {
      if (selectedUnit) rotateUnit(selectedUnit, 'cw');
    });
    document.getElementById('rotate-ccw-btn').addEventListener('click', () => {
      if (selectedUnit) rotateUnit(selectedUnit, 'ccw');
    });
    document.getElementById('attack-btn').addEventListener('click', () => {
      if (selectedUnit) performUnitAttack(selectedUnit);
    });
    
    document.querySelectorAll('[data-dir]').forEach(btn => {
      btn.addEventListener('click', () => {
        // –Ø–≤–Ω–æ–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Å–∏–º–≤–æ–ª–æ–≤ –Ω–∞ –∫–Ω–æ–ø–∫–∞—Ö –∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π
        const direction = btn.getAttribute('data-dir'); // 'N' | 'E' | 'S' | 'W'
        if (direction === 'N') return placeUnitWithDirection('N');
        if (direction === 'E') return placeUnitWithDirection('E');
        if (direction === 'S') return placeUnitWithDirection('S');
        if (direction === 'W') return placeUnitWithDirection('W');
      });
    });
    
    document.addEventListener('DOMContentLoaded', init);

    // ====== –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò –î–ï–ô–°–¢–í–ò–ô ======
    function rotateUnit(unitMesh, dir) {
      const u = unitMesh.userData.unitData;
      if (!u) return;
      u.facing = dir === 'cw' ? turnCW[u.facing] : turnCCW[u.facing];
      updateUnits();
    }
    
    function performUnitAttack(unitMesh) {
      if (!unitMesh) return;
      const r = unitMesh.userData.row; const c = unitMesh.userData.col;
      const unit = gameState.board[r][c].unit; if (!unit) return;
      const tpl = CARDS[unit.tplId];
      const cost = attackCost(tpl);
      if (tpl.attackType === 'MAGIC') {
        if (gameState.players[gameState.active].mana < cost) { showNotification(`–ù—É–∂–Ω–æ ${cost} –º–∞–Ω—ã –¥–ª—è –∞—Ç–∞–∫–∏`, 'error'); return; }
        gameState.players[gameState.active].mana -= cost;
        updateUI();
        magicFrom = { r, c };
        addLog(`${tpl.name}: –≤—ã–±–µ—Ä–∏—Ç–µ —Ü–µ–ª—å –¥–ª—è –º–∞–≥–∏—á–µ—Å–∫–æ–π –∞—Ç–∞–∫–∏.`);
        hideUnitActionPanel();
        return;
      }
      const hits = computeHits(gameState, r, c);
      if (!hits.length) { showNotification('–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ü–µ–ª–µ–π –¥–ª—è –∞—Ç–∞–∫–∏', 'error'); hideUnitActionPanel(); return; }
      if (gameState.players[gameState.active].mana < cost) { showNotification(`–ù—É–∂–Ω–æ ${cost} –º–∞–Ω—ã –¥–ª—è –∞—Ç–∞–∫–∏`, 'error'); hideUnitActionPanel(); return; }
      gameState.players[gameState.active].mana -= cost;
      updateUI();
      performBattleSequence(r, c, true);
      hideUnitActionPanel();
    }
    
    function performBattleSequence(r, c, markAttackTurn) {
      const staged = stagedAttack(gameState, r, c);
      if (!staged || staged.empty) return;
      // –±–∞–Ω–Ω–µ—Ä –±–æ—è
      const bb = document.getElementById('battle-banner');
      bb.classList.remove('hidden'); bb.classList.add('flex');
      setTimeout(()=>{ bb.classList.add('hidden'); bb.classList.remove('flex'); }, 1100);
      // –Ω–µ–±–æ–ª—å—à–∞—è –∞–Ω–∏–º–∞—Ü–∏—è –≤—ã–ø–∞–¥–∞/—Ç–æ–ª—á–∫–∞
      const aMesh = unitMeshes.find(m => m.userData.row === r && m.userData.col === c);
      const hitsPrev = computeHits(gameState, r, c);
      const fromPos = (aMesh ? aMesh.position.clone() : tileMeshes[r][c].position.clone().add(new THREE.Vector3(0, 0.5, 0)));
      if (aMesh && hitsPrev.length) {
        const firstTargetMesh = unitMeshes.find(m => m.userData.row === hitsPrev[0].r && m.userData.col === hitsPrev[0].c);
        if (firstTargetMesh) {
          const dir = new THREE.Vector3().subVectors(firstTargetMesh.position, aMesh.position).normalize();
          const push = dir.clone().multiplyScalar(0.55);
          const back = dir.clone().multiplyScalar(-0.55);
          const tl = gsap.timeline();
          tl.to(aMesh.position, { x: aMesh.position.x + push.x, z: aMesh.position.z + push.z, duration: 0.18, ease: 'power2.out' })
            .to(aMesh.position, { x: aMesh.position.x + back.x, z: aMesh.position.z + back.z, duration: 0.28, ease: 'power2.inOut' });
        } else {
          gsap.to(aMesh.position, { y: aMesh.position.y + 0.25, yoyo: true, repeat: 1, duration: 0.2 });
        }
      }
      // –í–∏–∑—É–∞–ª—å–Ω—ã–µ –ª—É—á–∏ –∏ —ç—Ñ—Ñ–µ–∫—Ç—ã –ø–æ–ø–∞–¥–∞–Ω–∏–π + —Ç—Ä—è—Å–∫–∞ —Ü–µ–ª–µ–π –∏ –≤—ã–ª–µ—Ç–∞—é—â–∏–µ —á–∏—Å–ª–∞
      for (const h of hitsPrev) {
        const toMesh = unitMeshes.find(m => m.userData.row === h.r && m.userData.col === h.c);
        if (toMesh) {
          const to = toMesh.position.clone();
          const from = fromPos.clone();
          const dir = new THREE.Vector3().subVectors(to, from);
          const len = dir.length(); dir.normalize();
          const geom = new THREE.CylinderGeometry(0.05, 0.05, len, 8);
          const mat = new THREE.MeshBasicMaterial({ color: 0xffd166, transparent: true, opacity: 0.95, depthTest: false, depthWrite: false });
          const beam = new THREE.Mesh(geom, mat);
          beam.position.copy(from.clone().add(to).multiplyScalar(0.5));
          beam.lookAt(to);
          beam.rotateX(Math.PI/2);
          beam.renderOrder = 998;
          effectsGroup.add(beam);
          gsap.to(beam.material, { opacity: 0, duration: 1.0, onComplete: ()=>{ effectsGroup.remove(beam); } });
          // –¢—Ä—è—Å–∫–∞ –∏ —á–∏—Å–ª–∞ —É—Ä–æ–Ω–∞
          shakeMesh(toMesh, 5, 0.22);
          spawnDamageText(toMesh, `-${h.dmg}`, '#ff5555');
        }
      }
      // –ü—Ä–∏–º–µ–Ω—è–µ–º —É—Ä–æ–Ω (—ç—Ç–∞–ø 1), –æ–±–Ω–æ–≤–ª—è–µ–º HP –Ω–∞ —Å—Ü–µ–Ω–µ, –Ω–æ –Ω–µ —É–¥–∞–ª—è–µ–º —é–Ω–∏—Ç–æ–≤
      staged.step1();
      gameState = staged.n1; updateUnits();
      // –¢–æ—Ç, –∫—Ç–æ —É–º—Ä—ë—Ç –ø–æ—Å–ª–µ step1
      const dying = hitsPrev.filter(h => {
        const u = gameState.board[h.r][h.c].unit; return u && u.currentHP <= 0;
      });
      // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ —Å–º–µ—Ä—Ç–∏, –∑–∞—Ç–µ–º –∞–Ω–∏–º–∞—Ü–∏—è ¬´—É–ª—ë—Ç–∞¬ª
      setTimeout(() => {
        for (const h of dying) {
          const tMesh = unitMeshes.find(m => m.userData.row === h.r && m.userData.col === h.c);
          if (tMesh) {
            const away = aMesh ? new THREE.Vector3().subVectors(tMesh.position, aMesh.position).normalize().multiplyScalar(1.2) : new THREE.Vector3(0, 0, 1);
            fadeOutAndFly(tMesh, away);
          }
        }
        const afterDeathDelay = dying.length ? 800 : 0;
        setTimeout(() => {
          // –û—Ç–≤–µ—Ç–Ω—ã–π —É—Ä–æ–Ω
          const retaliation = staged.step2() || 0;
          if (retaliation > 0) {
            if (aMesh) {
              shakeMesh(aMesh, 3, 0.2);
              spawnDamageText(aMesh, `-${retaliation}`, '#ffd166');
            }
          }
          // –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ: —É–¥–∞–ª–µ–Ω–∏–µ –º—ë—Ä—Ç–≤—ã—Ö –∏–∑ state, –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ü–µ–Ω—ã/UI –∏ –ª–æ–≥–æ–≤
          const res = staged.finish();
          gameState = res.n1; updateUnits(); updateUI();
          for (const l of res.logLines.reverse()) addLog(l);
          if (markAttackTurn && gameState.board[r][c].unit) gameState.board[r][c].unit.lastAttackTurn = gameState.turn;
        }, afterDeathDelay);
      }, 420);
    }

    function spawnDamageText(targetMesh, text, color = '#ff5555') {
      const canvas = document.createElement('canvas');
      canvas.width = 256; canvas.height = 128;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0,0,canvas.width, canvas.height);
      ctx.font = 'bold 64px Arial';
      ctx.fillStyle = color;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.lineWidth = 6;
      ctx.strokeText(text, canvas.width/2, canvas.height/2);
      ctx.fillText(text, canvas.width/2, canvas.height/2);
      const tex = new THREE.CanvasTexture(canvas);
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, opacity: 1, depthTest: false, depthWrite: false });
      const sprite = new THREE.Sprite(mat);
      sprite.scale.set(2.6, 1.4, 1);
      const pos = targetMesh.position.clone().add(new THREE.Vector3(0, 0.9, 0));
      sprite.position.copy(pos);
      sprite.renderOrder = 999;
      effectsGroup.add(sprite);
      gsap.to(sprite.position, { y: sprite.position.y + 1.5, duration: 1.2, ease: 'power1.out' });
      gsap.to(sprite.material, { opacity: 0, duration: 1.2, onComplete: () => { effectsGroup.remove(sprite); tex.dispose(); mat.dispose(); } });
    }

    function shakeMesh(mesh, times = 3, duration = 0.1) {
      const tl = gsap.timeline();
      const ox = mesh.position.x; const oz = mesh.position.z;
      for (let i = 0; i < times; i++) {
        const dx = (Math.random()*0.2 - 0.1);
        const dz = (Math.random()*0.2 - 0.1);
        tl.to(mesh.position, { x: ox + dx, z: oz + dz, duration: duration/2 })
          .to(mesh.position, { x: ox, z: oz, duration: duration/2 });
      }
      return tl;
    }

    function fadeOutAndFly(mesh, awayVec) {
      awayVec = awayVec || new THREE.Vector3(0, 0, 1);
      const mats = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
      mats.forEach(m => { m.transparent = true; });
      gsap.to(mesh.position, { x: mesh.position.x + awayVec.x, y: mesh.position.y + 1.6, z: mesh.position.z + awayVec.z, duration: 0.7, ease: 'power2.in' });
      gsap.to(mats, { opacity: 0, duration: 0.75 });
    }
    
    function performMagicAttack(from, targetMesh) {
      const tr = targetMesh.userData.row; const tc = targetMesh.userData.col;
      const res = magicAttack(gameState, from.r, from.c, tr, tc);
      if (!res) { showNotification('–¶–µ–ª—å –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞', 'error'); return; }
      gameState = res.n1; updateUnits(); updateUI();
      for (const l of res.logLines.reverse()) addLog(l);
      const aMesh = unitMeshes.find(m => m.userData.row === from.r && m.userData.col === from.c);
      if (aMesh) { gsap.fromTo(aMesh.position, { y: aMesh.position.y }, { y: aMesh.position.y + 0.3, yoyo: true, repeat: 1, duration: 0.12 }); }
      // –≤—Å–ø—ã—à–∫–∞ –ø–æ —Ü–µ–ª–∏
      const tMesh = unitMeshes.find(m => m.userData.row === tr && m.userData.col === tc);
      if (tMesh) {
        const flashGeom = new THREE.SphereGeometry(0.25, 12, 12);
        const flashMat = new THREE.MeshBasicMaterial({ color: 0xff6666, transparent: true, opacity: 0.8 });
        const flash = new THREE.Mesh(flashGeom, flashMat);
        flash.position.copy(tMesh.position).add(new THREE.Vector3(0, 0.4, 0));
        effectsGroup.add(flash);
        gsap.to(flash.scale, { x: 2, y: 2, z: 2, duration: 0.3 });
        gsap.to(flash.material, { opacity: 0, duration: 0.3, onComplete: ()=> effectsGroup.remove(flash) });
      }
      const attacker = gameState.board[from.r][from.c]?.unit; if (attacker) attacker.lastAttackTurn = gameState.turn;
    }
    
    function castSpellOnUnit(cardMesh, unitMesh) {
      const idx = cardMesh.userData.handIndex;
      const pl = gameState.players[gameState.active];
      if (idx == null || idx < 0 || idx >= pl.hand.length) { resetCardSelection(); return; }
      const tpl = pl.hand[idx]; if (!tpl || tpl.type !== 'SPELL') { resetCardSelection(); return; }
      if (tpl.cost > pl.mana) { showNotification('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–∞–Ω—ã', 'error'); resetCardSelection(); return; }
      const r = unitMesh.userData.row; const c = unitMesh.userData.col; const u = gameState.board[r][c].unit;
      if (tpl.id === 'WIND_SHIFT') { if (u) u.facing = turnCW[u.facing]; addLog(`${tpl.name}: ${CARDS[u.tplId].name} –ø–æ–≤—ë—Ä–Ω—É—Ç.`); }
      if (tpl.id === 'FREEZE_STREAM') { if (u) { const before = u.currentHP; u.currentHP = Math.max(0, u.currentHP - 1); addLog(`${tpl.name}: ${CARDS[u.tplId].name} –ø–æ–ª—É—á–∞–µ—Ç 1 —É—Ä–æ–Ω–∞ (HP ${before}‚Üí${u.currentHP})`); if (u.currentHP <= 0) gameState.board[r][c].unit = null; } }
      if (tpl.id === 'RAISE_STONE') { if (u && u.owner === gameState.active) { const before = u.currentHP; u.currentHP += 2; addLog(`${tpl.name}: ${CARDS[u.tplId].name} –ø–æ–ª—É—á–∞–µ—Ç +2 HP (HP ${before}‚Üí${u.currentHP})`); } }
      pl.mana -= tpl.cost; pl.discard.push(tpl); pl.hand.splice(idx, 1);
      resetCardSelection(); updateHand(); updateUnits(); updateUI();
    }

    // (—É–±—Ä–∞–Ω—ã –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ magic-btn –∏ draw-btn)
  </script>
</body>
</html>
