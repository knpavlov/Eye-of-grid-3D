      return r;
    };
  }
  TO_WRAP.forEach(wrap);

  // digest: быстрый снимок значимых полей
  function digest(state){
    try {
      if (!state) return '';
      const compact = {
        active: state.active,
        turn: state.turn,
        winner: state.winner ?? null,
        players: (state.players||[]).map(p => ({
          mana: p.mana, max: p.maxMana,
          hand: (p.hand||[]).map(c=>c.id),
          deckN: (p.deck||[]).length,
          discardN: (p.discard||[]).length
        })),
        board: (state.board||[]).map(row => row.map(cell => {
          const u = cell?.unit;
          return u ? {o:u.owner,h:u.hp,a:u.atk,f:u.facing,t:u.tplId} : null;
        }))
      };
      return JSON.stringify(compact);
    } catch { return '';}
  }

  let lastDigest = '';
  let pending = false;
  function schedulePush(reason='auto', {force=false}={}){
    if (!NET_ON() || !gameState) return;
    if (APPLYING && !force) return;              // не эхоим полученный снапшот
    // Не пушим во время анимаций, если не forced
    if (!force && (manaGainActive || drawAnimationActive || splashActive)) return;
    const myTurn = (typeof gameState.active === 'number') && (gameState.active === MY_SEAT);
    if (!force && !myTurn) return;               // только активный игрок пушит
    if (force) {
      // немедленная отправка, игнорируя pending
      try {
        // Версионируем состояние: защитимся от устаревших снапшотов, приходящих чуть позже
        gameState.__ver = (Number(gameState.__ver) || 0) + 1;
        try { window.__LAST_SENT_VER = gameState.__ver; } catch {}
        socket.emit('pushState', { state: gameState, reason });
      } catch{}
      lastDigest = digest(gameState);
      pending = false;
      return;
    }
    if (pending) return;
    pending = true;
    requestAnimationFrame(()=>{
      pending = false;
      try {
        gameState.__ver = (Number(gameState.__ver) || 0) + 1;
        try { window.__LAST_SENT_VER = gameState.__ver; } catch {}
        socket.emit('pushState', { state: gameState, reason });
      } catch{}
      lastDigest = digest(gameState);
    });
  }
  // Экспортируем наружу, чтобы ранние функции (например, endTurn) могли вызвать schedulePush
  try { window.schedulePush = schedulePush; } catch {}

  // Периодическая отправка при любом изменении (подстраховка, если обёртка не сработала)
  setInterval(()=>{
    if (!NET_ON() || !gameState) return;
    // пушит только тот, у кого сейчас ХОД (чтобы оба могли делать свои ходы)
    const myTurn = (typeof gameState.active === 'number') && (gameState.active === MY_SEAT);
    if (!myTurn) return;
    const d = digest(gameState);
    if (d && d !== lastDigest) schedulePush('digest');
  }, 250);

  // --- RECEIVING: применяем снапшот и перерисовываем ---
  socket.on('state', async (state)=>{
    if (!state) return;
    const prev = APPLYING ? null : (gameState ? JSON.parse(JSON.stringify(gameState)) : null);
    // Robust previous snapshot even if prev is null due to concurrent APPLYING
    let __lastTurnSeen = 0;
    try { __lastTurnSeen = (typeof window !== 'undefined' && typeof window.__lastTurnSeen === 'number') ? window.__lastTurnSeen : (gameState?.turn || 0); } catch {}
    const __hadNewTurn = (typeof state.turn === 'number') && (state.turn > (__lastTurnSeen || 0));
    let __lastManaSeen = (typeof window !== 'undefined' && window.__lastManaSeen && Array.isArray(window.__lastManaSeen)) ? window.__lastManaSeen.slice() : [0,0];
    try {
      if (!__lastManaSeen || __lastManaSeen.length < 2) __lastManaSeen = [0,0];
      if (gameState && gameState.players) {
        __lastManaSeen[0] = Number(gameState.players[0]?.mana || __lastManaSeen[0] || 0);
        __lastManaSeen[1] = Number(gameState.players[1]?.mana || __lastManaSeen[1] || 0);
      }
    } catch {}
    // Защита от поздних устаревших снапшотов: принимаем только если версия не меньше текущей
    try {
      const incomingVer = Number(state.__ver) || 0;
      const currentVer = Number(gameState && gameState.__ver) || 0;
      if (incomingVer <= currentVer && !((Number(state?.turn||0)) > (Number(gameState?.turn||0)))) {
        // проигнорируем устаревший снапшот
        return;
      }
    } catch {}
    
    // WebSocket анимации отключены, флаги не используются
    
    APPLYING = true;
    try {
      gameState = state;
      try { window.gameState = state; } catch {}
      lastDigest = digest(state);
      // Immediately reflect active seat and mana bars before any animations
        const leftSide = document.getElementById('left-side');
        const rightSide = document.getElementById('right-side');
        const t0 = document.getElementById('player-title-0');
        const t1 = document.getElementById('player-title-1');
        if (leftSide && rightSide && t0 && t1 && typeof gameState.active === 'number') {
          leftSide.querySelectorAll('.overlay-panel').forEach(el => el.classList.remove('active-player-panel'));
          rightSide.querySelectorAll('.overlay-panel').forEach(el => el.classList.remove('active-player-panel'));
          t0.classList.remove('title-pulse');
          t1.classList.remove('title-pulse');
          if (gameState.active === 0) {
            leftSide.querySelectorAll('.overlay-panel').forEach(el => el.classList.add('active-player-panel'));
            t0.classList.add('title-pulse');
          } else {
            rightSide.querySelectorAll('.overlay-panel').forEach(el => el.classList.add('active-player-panel'));
            t1.classList.add('title-pulse');
          }
        }
      try { updateIndicator(); } catch {}
      try { updateInputLock(); } catch {}
      // Сначала переcоберём доску/мета-объекты, затем юниты и UI (исправляет мерцание рамок)
      try{ createBoard && createBoard(); }catch{}
      try{ createMetaObjects && createMetaObjects(); }catch{}
      // Defer unit rebuild during remote lunge animation to avoid canceling the push
      try {
        const now = Date.now();
        const until = (typeof window !== 'undefined' && typeof window.__REMOTE_BATTLE_ANIM_UNTIL === 'number') ? window.__REMOTE_BATTLE_ANIM_UNTIL : __REMOTE_BATTLE_ANIM_UNTIL;
        if (until && now < until) {
          const delay = Math.min(900, Math.max(30, until - now + 20));
          if (window.__deferredUnitsTimer) { try { clearTimeout(window.__deferredUnitsTimer); } catch {} }
          window.__deferredUnitsTimer = setTimeout(()=>{ try { updateUnits(); } catch {} }, delay);
        } else {
          updateUnits();
        }
      } catch { updateUnits(); }
      // Обрабатываем отложенные WebSocket анимации
      try { flushPendingBattleQueues && flushPendingBattleQueues(); } catch {}
      try { if (prev) playDeltaAnimations(prev, state); } catch {}
      // Периодически пробуем воспроизвести отложенные анимации
      try {
        if (typeof window !== 'undefined') {
          if (window.__pendingBattleFlushTimer) clearInterval(window.__pendingBattleFlushTimer);
          window.__pendingBattleFlushTimer = setInterval(()=>{
            try { flushPendingBattleQueues && flushPendingBattleQueues(); } catch {}
          }, 120);
          setTimeout(()=>{ try { if (window.__pendingBattleFlushTimer) clearInterval(window.__pendingBattleFlushTimer); } catch {} }, 2500);
        }
      } catch {}
      // Если пришёл новый ход, заранее блокируем отображение новых орбов маны,
      // чтобы первая перерисовка UI не показывала их до вспышки
      try {
        const isNewTurnEarly = !!(prev && typeof prev.turn === 'number' && typeof state.turn === 'number' && state.turn > prev.turn);
        if (isNewTurnEarly) {
          const ownerEarly = (typeof state.active === 'number') ? state.active : (gameState?.active ?? 0);
          const beforeMEarly = (prev?.players?.[ownerEarly]?.mana ?? 0);
          const afterMEarly = (state?.players?.[ownerEarly]?.mana ?? 0);
          // Только устанавливаем PENDING_MANA_ANIM если нет текущей анимации маны
          if (!PENDING_MANA_ANIM && !manaGainActive) {
            PENDING_MANA_ANIM = window.PENDING_MANA_ANIM = { ownerIndex: ownerEarly, startIdx: Math.max(0, Math.min(9, beforeMEarly)), endIdx: Math.max(-1, Math.min(9, afterMEarly - 1)) };
            try { if (typeof window !== 'undefined' && window.gameState && window.gameState.players && window.gameState.players[ownerEarly]) { window.gameState.players[ownerEarly]._beforeMana = beforeMEarly; } } catch {}
          }
        }
      } catch {}
      // Guard: ensure start-of-turn +2 does not render before animation
      try {
        const __hadNewTurn = !!(typeof state.turn === 'number' && state.turn > (__lastTurnSeen || 0));
        if (__hadNewTurn && !PENDING_MANA_ANIM && !manaGainActive) {
          const __owner = (typeof state.active === 'number') ? state.active : (gameState?.active ?? 0);
          const __beforeM = Math.max(0, Number((__lastManaSeen && __lastManaSeen[__owner]) ?? 0));
          const __afterM = Math.max(0, Number(state?.players?.[__owner]?.mana ?? __beforeM));
          if (__afterM > __beforeM) {
            PENDING_MANA_ANIM = window.PENDING_MANA_ANIM = {
              ownerIndex: __owner,
              startIdx: Math.max(0, Math.min(9, __beforeM)),
              endIdx: Math.max(-1, Math.min(9, __afterM - 1))
            };
          }
        }
      } catch {}
      try { updateUI(); }catch{}
      // Если начался новый ход — синхронизируем порядок анимаций как в офлайне:
      // 1) Заставка хода с корректным заголовком, 2) Анимация маны, 3) Добор
      // Упрощенная и надежная система обработки нового хода
      try {
        const isNewTurn = (typeof state.turn === 'number') && (state.turn > ((prev && typeof prev.turn === 'number') ? prev.turn : (__lastTurnSeen || 0)));
        if (isNewTurn) {
          console.log(`[NETWORK] Processing new turn ${state.turn} (prev: ${prev?.turn || 'none'})`);
          
          // Ensure turn splash is visible (robust, idempotent)
          try {
            if (window.__ui && window.__ui.banner) {
              const b = window.__ui.banner;
              if (typeof b.ensureTurnSplashVisible === 'function') {
                await b.ensureTurnSplashVisible(3, state.turn);
              } else if (typeof b.forceTurnSplashWithRetry === 'function') {
                await b.forceTurnSplashWithRetry(3, state.turn);
              }
            } else if (typeof forceTurnSplashWithRetry === 'function') {
              await forceTurnSplashWithRetry(3);
            }
          } catch (e) {
            console.error('[NETWORK] Turn splash failed:', e);
          }
          
          // 1. Показываем заставку хода (если еще не показывали этот ход)
          if (lastSplashTurnShown < state.turn) {
            console.log(`[NETWORK] Showing turn splash for turn ${state.turn}`);
            try {
              if (window.__ui && window.__ui.banner) {
                const b = window.__ui.banner;
                if (typeof b.ensureTurnSplashVisible === 'function') {
                  await b.ensureTurnSplashVisible(3, state.turn);
                } else if (typeof b.forceTurnSplashWithRetry === 'function') {
                  await b.forceTurnSplashWithRetry(3, state.turn);
                }
              }
              lastSplashTurnShown = state.turn;
            } catch (e) {
              console.error('[NETWORK] Turn splash failed:', e);
            }
          }
          
          // 2. Анимация маны активного игрока
          const owner = (typeof state.active === 'number') ? state.active : 0;
          const beforeM = Math.max(0, (prev?.players?.[owner]?.mana ?? 0));
          const afterM = Math.max(0, (state?.players?.[owner]?.mana ?? 0));
          
          // Expose _beforeMana for UI clamping until animation completes
          try { if (typeof window !== 'undefined' && window.gameState && window.gameState.players && window.gameState.players[owner]) { window.gameState.players[owner]._beforeMana = beforeM; } } catch {}

          if (afterM > beforeM) {
            console.log(`[NETWORK] Animating mana for player ${owner}: ${beforeM} -> ${afterM}`);
            try {
              if (window.__ui && window.__ui.mana && typeof window.__ui.mana.animateTurnManaGain === 'function') {
                await window.__ui.mana.animateTurnManaGain(owner, beforeM, afterM, 1500);
              }
            } catch (e) {
              console.error('[NETWORK] Mana animation failed:', e);
            }
          }
        }
      } catch (e) {
        console.error('[NETWORK] Error processing new turn:', e);
      }
      // Анимация добора у приёмника (только для своей руки)
      try {
        const mySeat = (typeof window !== 'undefined' && typeof window.MY_SEAT === 'number') ? window.MY_SEAT : null;
        if (mySeat !== null && prev && prev.players && state.players) {
          const prevHand = (prev.players[mySeat]?.hand) || [];
          const nextHand = (state.players[mySeat]?.hand) || [];
          const delta = Math.max(0, nextHand.length - prevHand.length);
          if (delta > 0) {
            // Спрячем последние delta карт на время анимации
            pendingDrawCount = delta; updateHand();
            // Определим какие именно шаблоны анимировать — возьмём последние delta карт
            const newCards = nextHand.slice(-delta);
            for (let i = 0; i < newCards.length; i++) {
              const tpl = newCards[i];
              await animateDrawnCardToHand(tpl);
              // По одной открываем карту в руке
              pendingDrawCount = Math.max(0, pendingDrawCount - 1);
              updateHand();
            }
          } else {
            updateHand();
          }
        } else {
          updateHand();
        }
      } catch { updateHand(); }
    try { __endTurnInProgress = false; } catch {}
    updateIndicator();
    updateInputLock();
      // Persist last seen turn/mana for robust next-frame animations
      try {
        if (typeof window !== 'undefined') {
          window.__lastTurnSeen = Number(state.turn || 0);
          if (!window.__lastManaSeen) window.__lastManaSeen = [0,0];
          try { window.__lastManaSeen[0] = Number(state.players?.[0]?.mana || 0); } catch {}
          try { window.__lastManaSeen[1] = Number(state.players?.[1]?.mana || 0); } catch {}
        }
      } catch {}
    } finally {
      APPLYING=false;
      try { __endTurnInProgress = false; refreshInputLockUI(); } catch {}
    }
  });

  // Явный сигнал о смене хода (ускоряет разблокировку у оппонента в заанимированных кейсах)
  socket.on('turnSwitched', ({ activeSeat })=>{
    try {
      if (typeof activeSeat === 'number') {
        if (!gameState) gameState = {};
        gameState.active = activeSeat;
      }
    } catch {}
    try {
      const leftSide = document.getElementById('left-side');
      const rightSide = document.getElementById('right-side');
      const t0 = document.getElementById('player-title-0');
      const t1 = document.getElementById('player-title-1');
      if (leftSide && rightSide && t0 && t1 && typeof gameState.active === 'number') {
        leftSide.querySelectorAll('.overlay-panel').forEach(el => el.classList.remove('active-player-panel'));
        rightSide.querySelectorAll('.overlay-panel').forEach(el => el.classList.remove('active-player-panel'));
        t0.classList.remove('title-pulse');
        t1.classList.remove('title-pulse');
        if (gameState.active === 0) {
          leftSide.querySelectorAll('.overlay-panel').forEach(el => el.classList.add('active-player-panel'));
          t0.classList.add('title-pulse');
        } else {
          rightSide.querySelectorAll('.overlay-panel').forEach(el => el.classList.add('active-player-panel'));
          t1.classList.add('title-pulse');
        }
      }
    } catch {}
    updateIndicator();
    updateInputLock();
    // Show splash reliably; state event will drive full UI/mana sync
    try {
      if (typeof forceTurnSplashWithRetry === 'function') forceTurnSplashWithRetry(2);
    } catch {}
  });

  // ===== 9) Battle animation sync =====
  // Small guard to delay unit rebuild during remote lunge
  let __REMOTE_BATTLE_ANIM_UNTIL = 0; try { window.__REMOTE_BATTLE_ANIM_UNTIL = __REMOTE_BATTLE_ANIM_UNTIL; } catch {}

  function tryPlayBattleAnim(attacker, targets){
    try {
      if (!attacker || !Array.isArray(targets) || targets.length===0) return false;
      const aMesh = unitMeshes.find(m => m.userData.row === attacker.r && m.userData.col === attacker.c);
      const first = targets[0];
      if (!aMesh || !tileMeshes?.[first.r]?.[first.c]) return false;
      const targetPos = tileMeshes[first.r][first.c].position;
      const dir = new THREE.Vector3().subVectors(targetPos, aMesh.position).normalize();
      const push = { x: dir.x * 0.6, z: dir.z * 0.6 };
      // Wrap target mesh into a transient group to ensure movement is visible
      const parent = aMesh.parent; if (!parent) return false;
      const fromPos = aMesh.position.clone();
