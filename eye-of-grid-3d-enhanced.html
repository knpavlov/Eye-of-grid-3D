<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Eye of Grid ‚Äî Enhanced 3D</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #0f172a; color: #e2e8f0; font-family: system-ui, sans-serif; }
    #ui { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
    .ui-panel { pointer-events: auto; }
    #three-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }
    
    /* –ê–Ω–∏–º–∞—Ü–∏–∏ */
    @keyframes cardHover { 0% { transform: translateY(0); } 100% { transform: translateY(-10px); } }
    @keyframes cardSlam { 0% { transform: translateY(-100px) rotateX(30deg); } 70% { transform: translateY(5px) rotateX(-5deg); } 100% { transform: translateY(0) rotateX(0); } }
    @keyframes manaGain { 0% { opacity: 0; transform: scale(0.5); } 50% { opacity: 1; transform: scale(1.2); } 100% { opacity: 0; transform: scale(1); } }
    @keyframes battleFlash { 0% { opacity: 0; } 50% { opacity: 1; } 100% { opacity: 0; } }
    
    .card-hover { animation: cardHover 0.3s ease-in-out; }
    .card-slam { animation: cardSlam 0.6s cubic-bezier(0.25, 0.9, 0.2, 1.1); }
    .mana-gain { animation: manaGain 1s ease-out; }
    .battle-flash { animation: battleFlash 0.8s ease-in-out; }
    
    /* –ú–∞–Ω–∞ –æ—Ä–±—ã */
    .mana-bar { display: flex; gap: 6px; align-items: center; }
    .mana-orb { 
      width: 18px; height: 18px; border-radius: 50%; 
      background: radial-gradient(circle at 30% 30%, #fff, #8bd5ff 30%, #1ea0ff 70%, #0a67b7); 
      box-shadow: 0 0 10px rgba(30,160,255,0.8); 
    }
    .mana-slot { 
      width: 18px; height: 18px; border-radius: 50%; 
      border: 1px solid rgba(255,255,255,0.25); 
      background: rgba(255,255,255,0.06); 
      box-shadow: inset 0 2px 6px rgba(0,0,0,0.5); 
    }
    
    /* –ö–∞—Ä—Ç–æ—á–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã */
    .hand-area { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); width: 100%; max-width: 1200px; height: 200px; pointer-events: none; }
    .hand-card { position: absolute; bottom: 0; transform-origin: 50% 150px; pointer-events: auto; transition: all 0.3s ease; cursor: grab; }
    .hand-card:hover { transform: translateY(-20px) scale(1.05); }
    .hand-card.dragging { z-index: 1000; transform: scale(1.1); box-shadow: 0 20px 40px rgba(0,0,0,0.5); }
    
    /* –ü–∞–Ω–µ–ª–∏ */
    .overlay-panel { background: rgba(30, 41, 59, 0.95); backdrop-filter: blur(10px); border: 1px solid rgba(148, 163, 184, 0.3); border-radius: 16px; }
  </style>
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
</head>
<body>
  <canvas id="three-canvas"></canvas>
  
  <div id="ui">
    <!-- –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–Ω—Ç—Ä–æ–ª—ã -->
    <div class="ui-panel fixed right-4 top-4 space-y-3 z-20">
      <div class="overlay-panel px-4 py-2 text-sm">
        <div id="turn-info">–•–æ–¥: 1</div>
        <div id="active-player">–ê–∫—Ç–∏–≤–Ω—ã–π: –ò–≥—Ä–æ–∫ A</div>
      </div>
      
      <div class="overlay-panel px-4 py-2">
        <div class="text-sm mb-2">–ú–∞–Ω–∞:</div>
        <div class="mana-bar" id="mana-display"></div>
      </div>
      
      <div class="overlay-panel px-4 py-2 text-sm" id="control-info">
        –ö–æ–Ω—Ç—Ä–æ–ª—å: A 0 ‚Ä¢ B 0
      </div>
      
      <div class="flex gap-2">
        <button id="end-turn-btn" class="overlay-panel px-4 py-2 text-sm bg-amber-600 hover:bg-amber-700 transition-colors">
          –ó–∞–≤–µ—Ä—à–∏—Ç—å —Ö–æ–¥
        </button>
        <button id="log-btn" class="overlay-panel px-4 py-2 text-sm bg-slate-600 hover:bg-slate-700 transition-colors">
          –õ–æ–≥
        </button>
      </div>
      
      <div class="flex gap-2">
        <button id="help-btn" class="overlay-panel px-4 py-2 text-sm bg-slate-600 hover:bg-slate-700 transition-colors">
          –ü–æ–º–æ—â—å
        </button>
        <button id="new-game-btn" class="overlay-panel px-4 py-2 text-sm bg-slate-600 hover:bg-slate-700 transition-colors">
          –ù–æ–≤–∞—è –∏–≥—Ä–∞
        </button>
      </div>
    </div>
    
    <!-- –ü–∞–Ω–µ–ª—å –ª–æ–≥–æ–≤ -->
    <div id="log-panel" class="ui-panel fixed right-4 top-4 w-96 h-96 overlay-panel p-4 hidden z-30">
      <div class="flex justify-between items-center mb-3">
        <h3 class="text-lg font-semibold">–ñ—É—Ä–Ω–∞–ª —Å–æ–±—ã—Ç–∏–π</h3>
        <button id="close-log-btn" class="text-xl">&times;</button>
      </div>
      <div id="log-content" class="h-full overflow-y-auto text-sm space-y-1"></div>
    </div>
    
    <!-- –ü–∞–Ω–µ–ª—å –ø–æ–º–æ—â–∏ -->
    <div id="help-panel" class="ui-panel fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden z-40">
      <div class="overlay-panel p-6 max-w-lg">
        <div class="flex justify-between items-center mb-4">
          <h3 class="text-xl font-semibold">–ö–∞–∫ –∏–≥—Ä–∞—Ç—å</h3>
          <button id="close-help-btn" class="text-xl">&times;</button>
        </div>
        <div class="space-y-3 text-sm">
          <p>‚Ä¢ –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–π—Ç–µ –∫–∞—Ä—Ç—ã —Å—É—â–µ—Å—Ç–≤ –Ω–∞ –∏–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ</p>
          <p>‚Ä¢ –í—ã–±–∏—Ä–∞–π—Ç–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ—Å–ª–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è</p>
          <p>‚Ä¢ –ö–ª–∏–∫–∞–π—Ç–µ –ø–æ —Å–≤–æ–∏–º —Å—É—â–µ—Å—Ç–≤–∞–º –¥–ª—è –∞—Ç–∞–∫–∏ –∏–ª–∏ –ø–æ–≤–æ—Ä–æ—Ç–∞</p>
          <p>‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∑–∞–∫–ª–∏–Ω–∞–Ω–∏—è, –≤—ã–±—Ä–∞–≤ –∫–∞—Ä—Ç—É –∏ —Ü–µ–ª—å</p>
          <p>‚Ä¢ –ü–æ–±–µ–¥–∞: –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–π—Ç–µ 5+ –∫–ª–µ—Ç–æ–∫ –≤ –∫–æ–Ω—Ü–µ —Ö–æ–¥–∞</p>
        </div>
      </div>
    </div>
    
    <!-- –ü–∞–Ω–µ–ª—å –≤—ã–±–æ—Ä–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è -->
    <div id="orientation-panel" class="ui-panel fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden z-40">
      <div class="overlay-panel p-6">
        <div class="text-center mb-4">–í—ã–±–µ—Ä–∏—Ç–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</div>
        <div class="grid grid-cols-3 gap-2 w-48 mx-auto">
          <div></div>
          <button data-dir="N" class="overlay-panel px-4 py-2 hover:bg-slate-700">‚Üë</button>
          <div></div>
          <button data-dir="W" class="overlay-panel px-4 py-2 hover:bg-slate-700">‚Üê</button>
          <div class="overlay-panel px-4 py-2 text-center">‚Ä¢</div>
          <button data-dir="E" class="overlay-panel px-4 py-2 hover:bg-slate-700">‚Üí</button>
          <div></div>
          <button data-dir="S" class="overlay-panel px-4 py-2 hover:bg-slate-700">‚Üì</button>
          <div></div>
        </div>
        <div class="text-center mt-4">
          <button id="cancel-orient-btn" class="overlay-panel px-4 py-2 bg-red-600 hover:bg-red-700">–û—Ç–º–µ–Ω–∞</button>
        </div>
      </div>
    </div>
    
    <!-- –ü–∞–Ω–µ–ª—å –¥–µ–π—Å—Ç–≤–∏–π —Å —Å—É—â–µ—Å—Ç–≤–æ–º -->
    <div id="unit-action-panel" class="ui-panel fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 hidden z-40">
      <div class="overlay-panel p-6 space-y-3">
        <div id="unit-info" class="text-center mb-4"></div>
        <button id="attack-btn" class="w-full overlay-panel px-4 py-2 bg-red-600 hover:bg-red-700">–ê—Ç–∞–∫–æ–≤–∞—Ç—å</button>
        <div class="grid grid-cols-2 gap-2">
          <button id="rotate-cw-btn" class="overlay-panel px-4 py-2 hover:bg-slate-700">–ü–æ–≤–µ—Ä–Ω—É—Ç—å ‚Üª</button>
          <button id="rotate-ccw-btn" class="overlay-panel px-4 py-2 hover:bg-slate-700">–ü–æ–≤–µ—Ä–Ω—É—Ç—å ‚Ü∫</button>
        </div>
        <button id="cancel-action-btn" class="w-full overlay-panel px-4 py-2 bg-gray-600 hover:bg-gray-700">–û—Ç–º–µ–Ω–∞</button>
      </div>
    </div>
    
    <!-- –û–±–ª–∞—Å—Ç—å –¥–ª—è –∫–∞—Ä—Ç –≤ —Ä—É–∫–µ -->
    <div class="hand-area" id="hand-area"></div>
    
    <!-- –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è -->
    <div id="notifications" class="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-50 pointer-events-none"></div>
  </div>

  <script>
    // ====== –ò–ì–†–û–í–ê–Ø –õ–û–ì–ò–ö–ê (–ø–æ—Ä—Ç –∏–∑ 2D –≤–µ—Ä—Å–∏–∏) ======
    
    // –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –∏ —É—Ç–∏–ª–∏—Ç—ã
    const DIR_VECTORS = { N: [-1, 0], E: [0, 1], S: [1, 0], W: [0, -1] };
    const OPPOSITE_ELEMENT = { FIRE: 'WATER', WATER: 'FIRE', EARTH: 'FOREST', FOREST: 'EARTH' };
    const elementEmoji = { FIRE: 'üî•', WATER: 'üíß', EARTH: 'ü™®', FOREST: 'üå≤' };
    const turnCW = { N: 'E', E: 'S', S: 'W', W: 'N' };
    const turnCCW = { N: 'W', W: 'S', S: 'E', E: 'N' };
    const facingDeg = { N: 0, E: 90, S: 180, W: 270 };
    
    const uid = () => Math.random().toString(36).slice(2, 9);
    const inBounds = (r, c) => r >= 0 && r < 3 && c >= 0 && c < 3;
    const capMana = (m) => Math.min(10, m);
    const attackCost = (tpl) => (tpl.activation != null ? tpl.activation : Math.max(0, (tpl.cost || 0) - 1));
    
    // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –∫–∞—Ä—Ç (–ø–æ–ª–Ω—ã–π –Ω–∞–±–æ—Ä –∏–∑ 2D –≤–µ—Ä—Å–∏–∏)
    const CARDS = {
      SALAMANDER: { id: 'SALAMANDER', name: '–°–∞–ª–∞–º–∞–Ω–¥—Ä–∞ –ö–æ–ø–µ–π—â–∏—Ü–∞', type: 'UNIT', cost: 2, element: 'FIRE', atk: 2, hp: 2, pattern: 'FRONT', keywords: [] },
      PYROMANCER: { id: 'PYROMANCER', name: '–ü–∏—Ä–æ–º–∞–Ω—Ç', type: 'UNIT', cost: 3, element: 'FIRE', atk: 2, hp: 3, pattern: 'FRONT_SIDES', keywords: [] },
      NAIAD: { id: 'NAIAD', name: '–ù–∞—è–¥–∞-–õ–µ–∫–∞—Ä—å', type: 'UNIT', cost: 2, element: 'WATER', atk: 1, hp: 3, pattern: 'SIDES', keywords: [] },
      GOLEM: { id: 'GOLEM', name: '–ì–æ–ª–µ–º-–ë–∞—Å—Ç–∏–æ–Ω', type: 'UNIT', cost: 4, element: 'EARTH', atk: 2, hp: 5, pattern: 'FRONT_SIDES', keywords: ['GUARD'] },
      DRYAD: { id: 'DRYAD', name: '–î—Ä–∏–∞–¥–∞', type: 'UNIT', cost: 3, element: 'FOREST', atk: 3, hp: 2, pattern: 'SIDES', keywords: [] },
      FREEZE_STREAM: { id: 'FREEZE_STREAM', name: '–°—Ç—ã–ª—ã–π –ø–æ—Ç–æ–∫', type: 'SPELL', cost: 2, element: 'WATER', text: '–ù–∞–Ω–æ—Å–∏—Ç 1 —É—Ä–æ–Ω–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–º—É —é–Ω–∏—Ç—É.' },
      RAISE_STONE: { id: 'RAISE_STONE', name: '–ü–æ–¥—ä—ë–º –ø–æ—Ä–æ–¥—ã', type: 'SPELL', cost: 2, element: 'EARTH', text: '+2 HP –¥—Ä—É–∂–µ—Å—Ç–≤–µ–Ω–Ω–æ–º—É —é–Ω–∏—Ç—É.' },
      WIND_SHIFT: { id: 'WIND_SHIFT', name: '–õ–µ—Å–Ω–æ–π –ø–æ—Ä—ã–≤', type: 'SPELL', cost: 2, element: 'FOREST', text: '–ü–æ–≤–µ—Ä–Ω—É—Ç—å –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —é–Ω–∏—Ç–∞ –ø–æ —á–∞—Å–æ–≤–æ–π —Å—Ç—Ä–µ–ª–∫–µ.' },
      
      // Fire Set
      FIRE_FLAME_MAGUS: { id:'FIRE_FLAME_MAGUS', name:'Flame Magus', type:'UNIT', cost:1, activation:1, element:'FIRE', atk:1, hp:1, pattern:'FRONT', range:3, attackType:'MAGIC', blindspots:['N','E','S','W'], desc:'Magic Attack: target any creature; no retaliation.' },
      FIRE_HELLFIRE_SPITTER: { id:'FIRE_HELLFIRE_SPITTER', name:'Hellfire Spitter', type:'UNIT', cost:1, activation:1, element:'FIRE', atk:1, hp:1, pattern:'ALL', range:1, firstStrike:true, blindspots:[], desc:'Quickness: always strikes first.' },
      FIRE_FREEDONIAN: { id:'FIRE_FREEDONIAN', name:'Freedonian Wanderer', type:'UNIT', cost:2, activation:1, element:'FIRE', atk:1, hp:2, pattern:'FRONT', range:1, blindspots:['S'], auraGainManaOnSummon:true, desc:'While not on Fire tile, you gain 1 mana on allied summon.' },
      FIRE_FLAME_LIZARD: { id:'FIRE_FLAME_LIZARD', name:'Partmole Flame Lizard', type:'UNIT', cost:2, activation:1, element:'FIRE', atk:2, hp:2, pattern:'FRONT', range:1, blindspots:['S'], firstStrike:true, desc:'Quickness.' },
      FIRE_GREAT_MINOS: { id:'FIRE_GREAT_MINOS', name:'Great Minos of Sciondar', type:'UNIT', cost:3, activation:2, element:'FIRE', atk:2, hp:1, pattern:'FRONT', range:2, blindspots:['S'], dodge50:true, diesOffElement:'FIRE', desc:'Dodge 50% (non-magic). Destroy if not on Fire tile.' },
      FIRE_FLAME_ASCETIC: { id:'FIRE_FLAME_ASCETIC', name:'Flame Ascetic', type:'UNIT', cost:3, activation:2, element:'FIRE', atk:2, hp:3, pattern:'FRONT', range:1, blindspots:['S'], randomPlus2:true, desc:'Attack +2 half the time.' },
      FIRE_TRICEPTAUR: { id:'FIRE_TRICEPTAUR', name:'Triceptaur Behemoth', type:'UNIT', cost:5, activation:4, element:'FIRE', atk:5, hp:4, pattern:'FRONT_SIDES', range:1, blindspots:['S'], penaltyByTargets:true, desc:'If attacks 2 creatures, -2 ATK; if 3 creatures, -4 ATK.' },
      FIRE_PURSUER: { id:'FIRE_PURSUER', name:'Pursuer of Saint Dhees', type:'UNIT', cost:6, activation:3, element:'FIRE', atk:5, hp:4, pattern:'FRONT', range:1, blindspots:['S'], dynamicAtk:'OTHERS_ON_BOARD', desc:'ATK = 5 + number of other creatures on board.' },
    };
    
    // –°—Ç–∞—Ä—Ç–æ–≤—ã–µ –∫–æ–ª–æ–¥—ã
    const STARTER_TEMPO = [
      CARDS.SALAMANDER, CARDS.SALAMANDER, CARDS.SALAMANDER,
      CARDS.PYROMANCER, CARDS.PYROMANCER, CARDS.PYROMANCER,
      CARDS.DRYAD, CARDS.DRYAD, CARDS.DRYAD,
      CARDS.GOLEM,
      CARDS.NAIAD, CARDS.NAIAD,
      CARDS.FREEZE_STREAM, CARDS.FREEZE_STREAM,
      CARDS.WIND_SHIFT, CARDS.WIND_SHIFT,
      CARDS.RAISE_STONE, CARDS.RAISE_STONE,
      CARDS.SALAMANDER, CARDS.PYROMANCER, CARDS.DRYAD,
    ];
    
    const STARTER_FIRESET = [
      CARDS.FIRE_FLAME_MAGUS, CARDS.FIRE_FLAME_MAGUS, CARDS.FIRE_FLAME_MAGUS,
      CARDS.FIRE_HELLFIRE_SPITTER, CARDS.FIRE_HELLFIRE_SPITTER,
      CARDS.FIRE_FREEDONIAN, CARDS.FIRE_FREEDONIAN,
      CARDS.FIRE_FLAME_LIZARD, CARDS.FIRE_FLAME_LIZARD,
      CARDS.FIRE_GREAT_MINOS,
      CARDS.FIRE_FLAME_ASCETIC,
      CARDS.FIRE_TRICEPTAUR,
      CARDS.FIRE_PURSUER,
      CARDS.SALAMANDER, CARDS.PYROMANCER, CARDS.DRYAD, CARDS.GOLEM, CARDS.NAIAD, CARDS.FREEZE_STREAM
    ];
    
    // –ò–≥—Ä–æ–≤—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
    const dirsForPattern = (facing, pattern) => {
      const f = facing, l = turnCCW[f], r = turnCW[f];
      if (pattern === 'FRONT') return [f];
      if (pattern === 'SIDES') return [l, r];
      if (pattern === 'ALL') return ['N', 'E', 'S', 'W'];
      return [f, l, r]; // FRONT_SIDES
    };
    
    const computeCellBuff = (cellElement, unitElement) => {
      if (cellElement === unitElement) return { atk: 0, hp: 2 };
      const opp = OPPOSITE_ELEMENT[unitElement];
      if (cellElement === opp) return { atk: 0, hp: -2 };
      return { atk: 0, hp: 0 };
    };
    
    const effectiveStats = (cell, unit) => {
      const tpl = CARDS[unit.tplId];
      const buff = computeCellBuff(cell.element, tpl.element);
      return { 
        atk: (tpl.atk || 0) + buff.atk, 
        hp: (tpl.hp || 0) + buff.hp 
      };
    };
    
    const randomBoard = () => {
      const elements = ['FIRE', 'WATER', 'EARTH', 'FOREST'];
      return Array.from({ length: 3 }, () => 
        Array.from({ length: 3 }, () => ({ 
          element: elements[Math.floor(Math.random() * elements.length)] 
        }))
      );
    };
    
    const shuffle = (array) => {
      const result = [...array];
      for (let i = result.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [result[i], result[j]] = [result[j], result[i]];
      }
      return result;
    };
    
    const drawOne = (gameState, player) => {
      if (!gameState.players[player].deck.length) return;
      const card = gameState.players[player].deck.shift();
      if (card) gameState.players[player].hand.push(card);
    };
    
    const countControlled = (gameState, player) => {
      let count = 0;
      for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 3; c++) {
          if (gameState.board[r][c].unit?.owner === player) count++;
        }
      }
      return count;
    };
    
    const startGame = (deck0, deck1) => {
      const gameState = {
        board: randomBoard(),
        players: [
          { 
            name: '–ò–≥—Ä–æ–∫ A', 
            deck: shuffle(deck0.filter(Boolean)), 
            hand: [], 
            discard: [], 
            mana: 2 
          },
          { 
            name: '–ò–≥—Ä–æ–∫ B', 
            deck: shuffle(deck1.filter(Boolean)), 
            hand: [], 
            discard: [], 
            mana: 0 
          }
        ],
        active: 0,
        turn: 1,
        selectedCard: null,
        pending: null,
        winner: null
      };
      
      // –ù–∞—á–∞–ª—å–Ω—ã–µ –∫–∞—Ä—Ç—ã
      for (let i = 0; i < 5; i++) {
        drawOne(gameState, 0);
        drawOne(gameState, 1);
      }
      
      return gameState;
    };
    
    // –ë–æ–µ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞
    const hasAdjacentGuard = (gameState, r, c) => {
      const target = gameState.board[r][c].unit;
      if (!target) return false;
      
      for (const [dr, dc] of Object.values(DIR_VECTORS)) {
        const nr = r + dr, nc = c + dc;
        if (!inBounds(nr, nc)) continue;
        const unit = gameState.board[nr][nc].unit;
        if (unit && unit.owner === target.owner && CARDS[unit.tplId].keywords?.includes('GUARD')) {
          return true;
        }
      }
      return false;
    };
    
    const computeHits = (gameState, r, c) => {
      const attacker = gameState.board[r][c].unit;
      if (!attacker) return [];
      
      const tpl = CARDS[attacker.tplId];
      const dirs = dirsForPattern(attacker.facing, tpl.pattern || 'FRONT');
      const { atk } = effectiveStats(gameState.board[r][c], attacker);
      const hits = [];
      
      for (const dir of dirs) {
        const [dr, dc] = DIR_VECTORS[dir];
        const maxRange = Math.max(1, tpl.range || 1);
        
        for (let step = 1; step <= maxRange; step++) {
          const nr = r + dr * step, nc = c + dc * step;
          if (!inBounds(nr, nc)) break;
          
          const defender = gameState.board[nr][nc].unit;
          if (!defender) continue;
          if (defender.owner === attacker.owner) break;
          
          // –ü—Ä–æ–≤–µ—Ä–∫–∞ Guard
          const attackerFlying = tpl.keywords?.includes('FLYING');
          if (!attackerFlying && hasAdjacentGuard(gameState, nr, nc) && !CARDS[defender.tplId].keywords?.includes('GUARD')) {
            break;
          }
          
          // –†–∞—Å—á–µ—Ç —É—Ä–æ–Ω–∞
          const backDir = turnCW[turnCW[defender.facing]];
          const [bdr, bdc] = DIR_VECTORS[backDir];
          const isBackstab = (nr + bdr === r && nc + bdc === c);
          
          let extraDamage = 0;
          const blindspots = CARDS[defender.tplId].blindspots || ['S'];
          const dirFromDefenderToAttacker = (() => {
            if (r === nr - 1 && c === nc) return 'N';
            if (r === nr + 1 && c === nc) return 'S';
            if (r === nr && c === nc - 1) return 'W';
            return 'E';
          })();
          
          if (blindspots.includes(dirFromDefenderToAttacker)) {
            extraDamage += 1;
          }
          
          const damage = Math.max(0, atk + (isBackstab ? 1 : 0) + extraDamage);
          hits.push({ r: nr, c: nc, damage, backstab: isBackstab });
          break; // –ü–µ—Ä–≤–∞—è —Ü–µ–ª—å –≤ —ç—Ç–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏
        }
      }
      
      return hits;
    };
    
    // ====== THREE.JS –°–¶–ï–ù–ê ======
    
    let scene, camera, renderer, raycaster, mouse;
    let boardGroup, cardGroup, effectsGroup;
    let tileMeshes = [];
    let unitMeshes = [];
    let handCardMeshes = [];
    let gameState = null;
    let logEntries = [];
    
    // –°–æ—Å—Ç–æ—è–Ω–∏–µ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è
    let draggedCard = null;
    let hoveredTile = null;
    let selectedCard = null;
    let pendingPlacement = null;
    let selectedUnit = null;
    let magicTargeting = null;
    
    function initThreeJS() {
      // –†–µ–Ω–¥–µ—Ä–µ—Ä
      const canvas = document.getElementById('three-canvas');
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.setClearColor(0x0b1220);
      
      // –°—Ü–µ–Ω–∞
      scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x0b1220, 15, 30);
      
      // –ö–∞–º–µ—Ä–∞ (—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å–≤–µ—Ä—Ö—É)
      camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.set(0, 15, 8);
      camera.lookAt(0, 0, 0);
      
      // Raycaster –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();
      
      // –ì—Ä—É–ø–ø—ã –æ–±—ä–µ–∫—Ç–æ–≤
      boardGroup = new THREE.Group();
      cardGroup = new THREE.Group();
      effectsGroup = new THREE.Group();
      scene.add(boardGroup);
      scene.add(cardGroup);
      scene.add(effectsGroup);
      
      // –û—Å–≤–µ—â–µ–Ω–∏–µ
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(10, 20, 10);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.set(2048, 2048);
      directionalLight.shadow.camera.near = 1;
      directionalLight.shadow.camera.far = 50;
      directionalLight.shadow.camera.left = -15;
      directionalLight.shadow.camera.right = 15;
      directionalLight.shadow.camera.top = 15;
      directionalLight.shadow.camera.bottom = -15;
      scene.add(directionalLight);
      
      // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏ —Å–≤–µ—Ç–∞
      const fillLight = new THREE.DirectionalLight(0x4a90e2, 0.3);
      fillLight.position.set(-10, 10, -10);
      scene.add(fillLight);
      
      const rimLight = new THREE.DirectionalLight(0xff6b35, 0.2);
      rimLight.position.set(0, 5, -15);
      scene.add(rimLight);
      
      // –ë–∞–∑–æ–≤–∞—è –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞
      const platformGeometry = new THREE.CylinderGeometry(12, 12, 0.5, 32);
      const platformMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x1a2332, 
        metalness: 0.7, 
        roughness: 0.3 
      });
      const platform = new THREE.Mesh(platformGeometry, platformMaterial);
      platform.position.y = -0.5;
      platform.receiveShadow = true;
      scene.add(platform);
      
      console.log('Three.js —Å—Ü–µ–Ω–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞');
    }
    
    // –ú–∞—Ç–µ—Ä–∏–∞–ª—ã –¥–ª—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤
    const ELEMENT_MATERIALS = {
      FIRE: new THREE.MeshStandardMaterial({ 
        color: 0xdc2626, 
        emissive: 0x450000, 
        metalness: 0.1, 
        roughness: 0.8 
      }),
      WATER: new THREE.MeshStandardMaterial({ 
        color: 0x0369a1, 
        emissive: 0x001a2e, 
        metalness: 0.3, 
        roughness: 0.4 
      }),
      EARTH: new THREE.MeshStandardMaterial({ 
        color: 0x525252, 
        emissive: 0x0a0a0a, 
        metalness: 0.05, 
        roughness: 0.95 
      }),
      FOREST: new THREE.MeshStandardMaterial({ 
        color: 0x166534, 
        emissive: 0x001a0a, 
        metalness: 0.1, 
        roughness: 0.9 
      })
    };
    
    function createBoard() {
      // –û—á–∏—Å—Ç–∫–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö —Ç–∞–π–ª–æ–≤
      tileMeshes.forEach(row => row.forEach(tile => {
        if (tile) boardGroup.remove(tile);
      }));
      tileMeshes = [];
      
      if (!gameState) return;
      
      const tileSize = 2.5;
      const tileHeight = 0.3;
      const spacing = 0.1;
      
      for (let r = 0; r < 3; r++) {
        const row = [];
        for (let c = 0; c < 3; c++) {
          const cell = gameState.board[r][c];
          
          // –û—Å–Ω–æ–≤–Ω–æ–π —Ç–∞–π–ª
          const geometry = new THREE.BoxGeometry(tileSize, tileHeight, tileSize);
          const material = ELEMENT_MATERIALS[cell.element].clone();
          const tile = new THREE.Mesh(geometry, material);
          
          const x = (c - 1) * (tileSize + spacing);
          const z = (r - 1) * (tileSize + spacing);
          tile.position.set(x, tileHeight / 2, z);
          tile.castShadow = false;
          tile.receiveShadow = true;
          
          // –î–æ–±–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è
          tile.userData = { type: 'tile', row: r, col: c };
          
          // –î–µ–∫–æ—Ä–∞—Ç–∏–≤–Ω–∞—è —Ä–∞–º–∫–∞
          const frameGeometry = new THREE.BoxGeometry(tileSize + 0.1, 0.05, tileSize + 0.1);
          const frameMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x64748b, 
            metalness: 0.8, 
            roughness: 0.2 
          });
          const frame = new THREE.Mesh(frameGeometry, frameMaterial);
          frame.position.set(x, tileHeight + 0.025, z);
          
          boardGroup.add(tile);
          boardGroup.add(frame);
          row.push(tile);
        }
        tileMeshes.push(row);
      }
      
      console.log('–ò–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ —Å–æ–∑–¥–∞–Ω–æ');
    }
    
    // –°–æ–∑–¥–∞–Ω–∏–µ 3D –∫–∞—Ä—Ç—ã
    function createCard3D(cardData, isInHand = false) {
      const cardWidth = 1.6;
      const cardHeight = 2.2;
      const cardThickness = 0.08;
      
      // –ì–µ–æ–º–µ—Ç—Ä–∏—è –∫–∞—Ä—Ç—ã
      const geometry = new THREE.BoxGeometry(cardWidth, cardThickness, cardHeight);
      
      // –°–æ–∑–¥–∞–µ–º —Ç–µ–∫—Å—Ç—É—Ä—É –¥–ª—è –ª–∏—Ü–µ–≤–æ–π —Å—Ç–æ—Ä–æ–Ω—ã
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 356;
      const ctx = canvas.getContext('2d');
      
      // –†–∏—Å—É–µ–º –∫–∞—Ä—Ç—É –Ω–∞ –∫–∞–Ω–≤–∞—Å–µ
      drawCardFace(ctx, cardData, canvas.width, canvas.height);
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      
      // –ú–∞—Ç–µ—Ä–∏–∞–ª—ã –¥–ª—è –≥—Ä–∞–Ω–µ–π
      const faceMaterial = new THREE.MeshStandardMaterial({ 
        map: texture, 
        metalness: 0.1, 
        roughness: 0.7 
      });
      
      const edgeMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x1e293b, 
        metalness: 0.3, 
        roughness: 0.8 
      });
      
      const backMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x0f172a, 
        metalness: 0.2, 
        roughness: 0.9 
      });
      
      // –ü–æ—Ä—è–¥–æ–∫ –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤ –¥–ª—è BoxGeometry: +X, -X, +Y (–≤–µ—Ä—Ö), -Y (–Ω–∏–∑), +Z, -Z
      const materials = [
        edgeMaterial,  // +X (–ø—Ä–∞–≤—ã–π –∫—Ä–∞–π)
        edgeMaterial,  // -X (–ª–µ–≤—ã–π –∫—Ä–∞–π)  
        faceMaterial,  // +Y (–≤–µ—Ä—Ö/–ª–∏—Ü–æ)
        backMaterial,  // -Y (–Ω–∏–∑/—Ä—É–±–∞—à–∫–∞)
        edgeMaterial,  // +Z (–ø–µ—Ä–µ–¥–Ω–∏–π –∫—Ä–∞–π)
        edgeMaterial   // -Z (–∑–∞–¥–Ω–∏–π –∫—Ä–∞–π)
      ];
      
      const card = new THREE.Mesh(geometry, materials);
      card.castShadow = true;
      card.receiveShadow = false;
      
      // –î–∞–Ω–Ω—ã–µ –∫–∞—Ä—Ç—ã
      card.userData = {
        type: 'card',
        cardData: cardData,
        isInHand: isInHand,
        originalPosition: new THREE.Vector3(),
        originalRotation: new THREE.Euler()
      };
      
      return card;
    }
    
    function drawCardFace(ctx, cardData, width, height) {
      // –§–æ–Ω –∫–∞—Ä—Ç—ã
      const gradient = ctx.createLinearGradient(0, 0, 0, height);
      gradient.addColorStop(0, '#1e293b');
      gradient.addColorStop(1, '#0f172a');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);
      
      // –†–∞–º–∫–∞
      ctx.strokeStyle = getElementColor(cardData.element);
      ctx.lineWidth = 4;
      ctx.strokeRect(4, 4, width - 8, height - 8);
      
      // –ù–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ä—Ç—ã
      ctx.fillStyle = '#f1f5f9';
      ctx.font = 'bold 18px Arial, sans-serif';
      ctx.textAlign = 'center';
      const name = cardData.name.length > 20 ? cardData.name.substring(0, 20) + '...' : cardData.name;
      ctx.fillText(name, width / 2, 30);
      
      // –≠–ª–µ–º–µ–Ω—Ç
      ctx.font = '24px Arial';
      ctx.fillText(elementEmoji[cardData.element] || '', width / 2, 55);
      
      // –û–±–ª–∞—Å—Ç—å –∏–ª–ª—é—Å—Ç—Ä–∞—Ü–∏–∏
      ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
      ctx.fillRect(16, 70, width - 32, 120);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.lineWidth = 2;
      ctx.strokeRect(16, 70, width - 32, 120);
      
      ctx.fillStyle = '#94a3b8';
      ctx.font = '12px Arial';
      ctx.fillText('Illustration', width / 2, 135);
      
      // –û–ø–∏—Å–∞–Ω–∏–µ/—Ç–µ–∫—Å—Ç
      ctx.fillStyle = '#cbd5e1';
      ctx.font = '11px Arial';
      ctx.textAlign = 'left';
      const text = cardData.desc || cardData.text || (cardData.keywords ? cardData.keywords.join(', ') : '');
      wrapText(ctx, text, 16, 210, width - 32, 14);
      
      // –ù–∏–∂–Ω—è—è –ø–∞–Ω–µ–ª—å —Å–æ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞–º–∏
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(0, height - 40, width, 40);
      
      ctx.fillStyle = '#f1f5f9';
      ctx.font = 'bold 14px Arial';
      ctx.textAlign = 'left';
      ctx.fillText(`üíé${cardData.cost || 0}`, 16, height - 15);
      
      if (cardData.type === 'UNIT') {
        ctx.textAlign = 'right';
        ctx.fillText(`‚öîÔ∏è${cardData.atk || 0}  ‚ù§Ô∏è${cardData.hp || 0}`, width - 16, height - 15);
        
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç–æ–∏–º–æ—Å—Ç—å –∞—Ç–∞–∫–∏
        ctx.textAlign = 'center';
        ctx.font = '12px Arial';
        ctx.fillText(`‚ö°${attackCost(cardData)}`, width / 2, height - 18);
      }
    }
    
    function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
      if (!text) return;
      const words = text.split(' ');
      let line = '';
      
      for (let n = 0; n < words.length; n++) {
        const testLine = line + words[n] + ' ';
        const metrics = ctx.measureText(testLine);
        const testWidth = metrics.width;
        
        if (testWidth > maxWidth && n > 0) {
          ctx.fillText(line, x, y);
          line = words[n] + ' ';
          y += lineHeight;
        } else {
          line = testLine;
        }
      }
      ctx.fillText(line, x, y);
    }
    
    function getElementColor(element) {
      const colors = {
        FIRE: '#dc2626',
        WATER: '#0369a1', 
        EARTH: '#525252',
        FOREST: '#166534'
      };
      return colors[element] || '#64748b';
    }
    
    // –ü—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ –≤ —Å–ª–µ–¥—É—é—â–µ–π —á–∞—Å—Ç–∏...
  </script>
</body>
</html>
