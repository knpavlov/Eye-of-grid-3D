<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Three.js Dissolve Shader Demo (module)</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0b1020; color: #e6e9ef; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #app { position: relative; height: 100%; }
    #ui {
      position: absolute; left: 12px; top: 12px; display: flex; gap: 8px; align-items: center; z-index: 5;
      background: rgba(17, 24, 39, 0.7); border: 1px solid #334155; border-radius: 8px; padding: 10px 12px; backdrop-filter: blur(6px);
    }
    button, input[type=range] {
      cursor: pointer; color: #e6e9ef; background: #1f2937; border: 1px solid #334155; border-radius: 6px; padding: 8px 12px;
    }
    button:hover { background: #263241; }
    label { font-size: 12px; opacity: 0.9; }
    #credit { position: absolute; right: 10px; bottom: 8px; font-size: 12px; opacity: 0.7; }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="app">
    <div id="ui">
      <button id="btnDissolve">Dissolve</button>
      <button id="btnAppear">Appear</button>
      <label style="margin-left:8px;">Edge width
        <input id="edge" type="range" min="0" max="0.2" step="0.005" value="0.08">
      </label>
      <label style="margin-left:8px;">Speed
        <input id="speed" type="range" min="0.1" max="3" step="0.1" value="1">
      </label>
    </div>
    <div id="credit">Three.js dissolve shader â€¢ ES modules</div>
  </div>

  <!-- Use ES modules: import Three.js explicitly -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.161.0/build/three.module.js';

    const app = document.getElementById('app');
    const w = window.innerWidth, h = window.innerHeight;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(w, h);
    app.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b1020);

    const camera = new THREE.PerspectiveCamera(50, w/h, 0.1, 100);
    camera.position.set(0, 0.7, 2.6);
    scene.add(camera);

    // Lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x334466, 1.0);
    hemi.position.set(0, 1, 0);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(2, 2, 2);
    scene.add(dir);

    // Geometry
    const geo = new THREE.SphereGeometry(0.8, 96, 64);

    // Dissolve ShaderMaterial (procedural fbm noise)
    const mat = new THREE.ShaderMaterial({
      transparent: true,
      uniforms: {
        uTime:       { value: 0.0 },
        uThreshold:  { value: 0.0 },  // 0.0 = fully visible, 1.0 = fully dissolved
        uEdgeWidth:  { value: 0.08 },
        uEdgeColor:  { value: new THREE.Color(1.0, 0.5, 0.0) }, // fiery orange
        uBaseColor:  { value: new THREE.Color(0.82, 0.87, 1.0) }, // subtle bluish
        uNoiseScale: { value: 3.0 }, // frequency of noise
        uNoiseMove:  { value: new THREE.Vector2(0.15, -0.1) }, // scrolling
      },
      vertexShader: `
        varying vec2 vUv;
        varying vec3 vPos;
        void main(){
          vUv = uv;
          vec4 mv = modelViewMatrix * vec4(position, 1.0);
          vPos = (modelMatrix * vec4(position, 1.0)).xyz;
          gl_Position = projectionMatrix * mv;
        }
      `,
      fragmentShader: `
        precision highp float;
        varying vec2 vUv;
        varying vec3 vPos;

        uniform float uTime;
        uniform float uThreshold;
        uniform float uEdgeWidth;
        uniform vec3  uEdgeColor;
        uniform vec3  uBaseColor;
        uniform float uNoiseScale;
        uniform vec2  uNoiseMove;

        float hash(vec2 p){
          p = fract(p * vec2(123.34, 345.45));
          p += dot(p, p + 34.345);
          return fract(p.x * p.y);
        }
        float noise(vec2 p){
          vec2 i = floor(p);
          vec2 f = fract(p);
          float a = hash(i);
          float b = hash(i + vec2(1.0, 0.0));
          float c = hash(i + vec2(0.0, 1.0));
          float d = hash(i + vec2(1.0, 1.0));
          vec2 u = f * f * (3.0 - 2.0 * f);
          return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }
        float fbm(vec2 p){
          float v = 0.0;
          float a = 0.5;
          for (int i = 0; i < 5; i++){
            v += a * noise(p);
            p *= 2.02;
            a *= 0.5;
          }
          return v;
        }

        void main(){
          float heightBias = clamp((vPos.y + 0.9) * 0.3, 0.0, 1.0);
          vec2  uv = vUv * uNoiseScale + uNoiseMove * uTime;
          float n = fbm(uv) * 0.9 + heightBias * 0.3;

          float d = n - uThreshold;
          if (d < 0.0) discard;

          float edge = smoothstep(0.0, uEdgeWidth, d) - smoothstep(uEdgeWidth, uEdgeWidth * 2.0, d);
          vec3 color = mix(uBaseColor, uEdgeColor, edge);

          gl_FragColor = vec4(color, 1.0);
        }
      `
    });

    const mesh = new THREE.Mesh(geo, mat);
    scene.add(mesh);

    const floor = new THREE.Mesh(
      new THREE.CircleGeometry(3, 64),
      new THREE.MeshBasicMaterial({ color: 0x0d1328 })
    );
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -0.9;
    scene.add(floor);

    // UI
    const btnDissolve = document.getElementById('btnDissolve');
    const btnAppear   = document.getElementById('btnAppear');
    const edgeSlider  = document.getElementById('edge');
    const speedSlider = document.getElementById('speed');

    let target = 0.0; // target threshold
    let speed = 1.0;  // multiplier
    btnDissolve.onclick = () => { target = 1.0; };
    btnAppear.onclick   = () => { target = 0.0; };
    edgeSlider.oninput  = (e) => { mat.uniforms.uEdgeWidth.value = parseFloat(e.target.value); };
    speedSlider.oninput = (e) => { speed = parseFloat(e.target.value); };

    const clock = new THREE.Clock();
    function tick(){
      const dt = Math.min(clock.getDelta(), 0.033);
      mat.uniforms.uTime.value += dt;

      const th = mat.uniforms.uThreshold.value;
      const delta = target - th;
      const step = Math.sign(delta) * Math.min(Math.abs(delta), dt * 0.5 * speed);
      mat.uniforms.uThreshold.value = THREE.MathUtils.clamp(th + step, 0, 1);

      mesh.rotation.y += 0.3 * dt;
      mesh.rotation.x = Math.sin(mat.uniforms.uTime.value * 0.3) * 0.08;

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    tick();

    window.addEventListener('resize', () => {
      const W = window.innerWidth, H = window.innerHeight;
      renderer.setSize(W, H);
      camera.aspect = W / H;
      camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
